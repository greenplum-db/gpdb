/*
 * deprecated_objects.c
 *
 * Helpers to detect deprecated objects.
 *
 * Portions Copyright (c) 2021-Present Pivotal Software, Inc.
 */

#include "postgres.h"

#include "catalog/namespace.h"
#include "optimizer/walkers.h"
#include "utils/lsyscache.h"

#include "deprecated_objects.h"

static bool is_deprecated_table(Oid reloid);

/*
 * List of deprecated tables generated by performing a set difference over the
 * tables listed in pg_class for GPDB 5X as opposed to 6X in the template1
 * database.
 * Tables under pg_catalog have static Oids, whereas tables under gp_toolkit
 * don't (as gp_toolkit can be dropped and recreated), which is why we have to
 * look up their Oids at runtime.
 */
static const Oid deprecated_tables_pg_catalog[]   = {
	5000,	/* pg_catalog.gp_configuration */
	5029,	/* pg_catalog.gp_db_interfaces */
	5039,	/* pg_catalog.gp_fault_strategy */
	5096,	/* pg_catalog.gp_global_sequence */
	5030,	/* pg_catalog.gp_interfaces */
	5091,	/* pg_catalog.gp_persistent_database_node */
	5093,	/* pg_catalog.gp_persistent_filespace_node */
	5090,	/* pg_catalog.gp_persistent_relation_node */
	5092,	/* pg_catalog.gp_persistent_tablespace_node */
	5094,	/* pg_catalog.gp_relation_node */
	1248,	/* pg_catalog.pg_autovacuum */
	5009,	/* pg_catalog.pg_filespace */
	5033,	/* pg_catalog.pg_filespace_entry */
	2614,	/* pg_catalog.pg_listener */
	5004,	/* pg_catalog.pg_window */
};
static const int num_deprecated_tables_pg_catalog = sizeof(deprecated_tables_pg_catalog) / sizeof(Oid);

static const char *deprecated_tables_gp_toolkit[2] = {
	"__gp_localid",
	"__gp_masterid"
};
static const int num_deprecated_tables_gp_toolkit = sizeof(deprecated_tables_gp_toolkit) / sizeof(const char *);

static bool is_deprecated_table(Oid reloid)
{
	Oid gp_toolkit_oid;

	for (int i = 0; i < num_deprecated_tables_pg_catalog; i++)
	{
		if (reloid == deprecated_tables_pg_catalog[i])
			return true;
	}

	gp_toolkit_oid = LookupExplicitNamespace("gp_toolkit");
	if (OidIsValid(gp_toolkit_oid))
	{
		for (int i = 0; i < num_deprecated_tables_gp_toolkit; i++)
		{
			if (reloid == get_relname_relid(deprecated_tables_gp_toolkit[i], gp_toolkit_oid))
				return true;
		}
	}
	return false;
}

bool
check_node_deprecated_tables_walker(Node *node, void *context)
{
	Assert(context == NULL);

	if (node == NULL)
		return false;

	if (IsA(node, RangeTblEntry))
	{
		RangeTblEntry *rte = (RangeTblEntry *) node;
		return is_deprecated_table(rte->relid);
	}
	if (IsA(node, List))
	{
		ListCell		*lc;
		List 			*list = (List *) node;
		CommonTableExpr	*cte;

		if (list_length(list) == 0)
			return false;

		if (IsA(linitial(list), CommonTableExpr))
		{
			/*
			 * Recurse into each CTE subquery to look for deprecated relations.
			 */
			foreach(lc, list)
			{
				cte = (CommonTableExpr *) lfirst(lc);
				return query_tree_walker((Query *) cte->ctequery,
										 check_node_deprecated_tables_walker,
										 NULL,
										 QTW_EXAMINE_RTES);
			}
		}
	}
	else if(IsA(node, Query))
	{
		/*
		 * Recurse into each subquery to look for deprecated relations.
		 */
		Query	*subquery = (Query *) node;
		return query_tree_walker(subquery,
								 check_node_deprecated_tables_walker,
								 NULL,
								 QTW_EXAMINE_RTES);
	}

	return false;
}
