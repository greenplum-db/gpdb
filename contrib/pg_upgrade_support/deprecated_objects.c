/*
 * deprecated_objects.c
 *
 * Helpers to detect deprecated objects.
 *
 * Portions Copyright (c) 2021-Present Pivotal Software, Inc.
 */

#include "postgres.h"

#include "catalog/namespace.h"
#include "optimizer/walkers.h"
#include "utils/lsyscache.h"

#include "deprecated_objects.h"

static bool is_deprecated_table(Oid reloid);
static bool is_deprecated_column(Oid reloid, int attnum);

/*
 * List of deprecated tables generated by performing a set difference over the
 * tables listed in pg_class for GPDB 5X as opposed to 6X in the template1
 * database.
 * Tables under pg_catalog have static Oids, whereas tables under gp_toolkit
 * don't (as gp_toolkit can be dropped and recreated), which is why we have to
 * look up their Oids at runtime.
 */
static const Oid deprecated_tables_static[] = {
	5000,	/* pg_catalog.gp_configuration */
	5029,	/* pg_catalog.gp_db_interfaces */
	5039,	/* pg_catalog.gp_fault_strategy */
	5096,	/* pg_catalog.gp_global_sequence */
	5030,	/* pg_catalog.gp_interfaces */
	5091,	/* pg_catalog.gp_persistent_database_node */
	5093,	/* pg_catalog.gp_persistent_filespace_node */
	5090,	/* pg_catalog.gp_persistent_relation_node */
	5092,	/* pg_catalog.gp_persistent_tablespace_node */
	5094,	/* pg_catalog.gp_relation_node */
	1248,	/* pg_catalog.pg_autovacuum */
	5009,	/* pg_catalog.pg_filespace */
	5033,	/* pg_catalog.pg_filespace_entry */
	2614,	/* pg_catalog.pg_listener */
	5004,	/* pg_catalog.pg_window */
};
static const int num_deprecated_tables_static = sizeof(deprecated_tables_static) / sizeof(Oid);

static const char *deprecated_tables_dynamic[]  = {
	"__gp_localid",
	"__gp_masterid"
};
static const int num_deprecated_tables_dynamic = sizeof(deprecated_tables_dynamic) / sizeof(const char *);

static bool is_deprecated_table(Oid reloid)
{
	Oid gp_toolkit_oid;

	for (int i = 0; i < num_deprecated_tables_static; i++)
	{
		if (reloid == deprecated_tables_static[i])
			return true;
	}

	gp_toolkit_oid = LookupExplicitNamespace("gp_toolkit");
	if (OidIsValid(gp_toolkit_oid))
	{
		for (int i = 0; i < num_deprecated_tables_dynamic; i++)
		{
			if (reloid == get_relname_relid(deprecated_tables_dynamic[i], gp_toolkit_oid))
				return true;
		}
	}
	return false;
}

/*
 * List of deprecated columns generated by performing a set difference over the
 * columns listed in pg_attribute in GPDB 5X as opposed to 6X template1.
 * Tables under pg_catalog and information_schema have static Oids, whereas
 * tables under gp_toolkit don't (as gp_toolkit can be dropped and recreated),
 * which is why we have to look up their Oids at runtime. Thus, we maintain two
 * separate lists - one for static Oids and one for dynamic Oids.
 *
 * Note: We exclude columns from deprecated tables in this list as references to
 * deprecated tables are covered by the deprecated tables check. It is
 * impossible to make a column reference without referring to a table.
 */

static const DeprecatedColumnStatic deprecated_columns_static[]   = {
	{ 1213, 7 }, /* pg_catalog.pg_tablespace.spcfsoid */
	{ 1213, 3 }, /* pg_catalog.pg_tablespace.spclocation */
	{ 1213, 6 }, /* pg_catalog.pg_tablespace.spcmirlocations */
	{ 1213, 5 }, /* pg_catalog.pg_tablespace.spcprilocations */
	{ 1255, 16 }, /* pg_catalog.pg_proc.proiswin */
	{ 1259, 20 }, /* pg_catalog.pg_class.relfkeys */
	{ 1259, 21 }, /* pg_catalog.pg_class.relrefs */
	{ 1259, 11 }, /* pg_catalog.pg_class.reltoastidxid */
	{ 1259, 18 }, /* pg_catalog.pg_class.reltriggers */
	{ 1259, 19 }, /* pg_catalog.pg_class.relukeys */
	{ 1260, 11 }, /* pg_catalog.pg_authid.rolconfig */
	{ 1260, 16 }, /* pg_catalog.pg_authid.rolcreaterexthdfs */
	{ 1260, 17 }, /* pg_catalog.pg_authid.rolcreatewexthdfs */
	{ 1262, 10 }, /* pg_catalog.pg_database.datconfig */
	{ 2600, 5 }, /* pg_catalog.pg_aggregate.agginvprelimfn */
	{ 2600, 3 }, /* pg_catalog.pg_aggregate.agginvtransfn */
	{ 2600, 10 }, /* pg_catalog.pg_aggregate.aggordered */
	{ 2600, 4 }, /* pg_catalog.pg_aggregate.aggprelimfn */
	{ 2601, 12 }, /* pg_catalog.pg_am.amcanshrink */
	{ 2601, 16 }, /* pg_catalog.pg_am.amgetmulti */
	{ 2601, 8 }, /* pg_catalog.pg_am.amindexnulls */
	{ 2602, 5 }, /* pg_catalog.pg_amop.amopreqcheck */
	{ 2618, 3 }, /* pg_catalog.pg_rewrite.ev_attr */
	{ 2620, 7 }, /* pg_catalog.pg_trigger.tgconstrname */
	{ 2620, 6 }, /* pg_catalog.pg_trigger.tgisconstraint */
	{ 5002, 2 }, /* pg_catalog.gp_distribution_policy.attrnums */
	{ 5036, 10 }, /* pg_catalog.gp_segment_configuration.replication_port */
	{ 6040, 10 }, /* pg_catalog.pg_exttable.fmterrtbl */
	{ 6439, 4 }, /* pg_catalog.pg_resgroupcapability.proposed */
	{ 11316, 17 }, /* pg_catalog.pg_roles.rolcreaterexthdfs */
	{ 11316, 18 }, /* pg_catalog.pg_roles.rolcreatewexthdfs */
	{ 11417, 7 }, /* pg_catalog.pg_stat_activity.current_query */
	{ 11417, 3 }, /* pg_catalog.pg_stat_activity.procpid */
	{ 11420, 1 }, /* pg_catalog.pg_stat_replication.procpid */
	{ 11874, 16 }, /* information_schema.triggers.condition_reference_new_row */
	{ 11874, 14 }, /* information_schema.triggers.condition_reference_new_table */
	{ 11874, 15 }, /* information_schema.triggers.condition_reference_old_row */
	{ 11874, 13 }, /* information_schema.triggers.condition_reference_old_table */
	{ 11874, 12 }, /* information_schema.triggers.condition_timing */
};
static const int num_deprecated_columns_static = sizeof(deprecated_columns_static) / sizeof(DeprecatedColumnStatic);

static const DeprecatedColumnDynamic deprecated_columns_dynamic[] = {
	{ "gp_resgroup_config", 4 }, /* gp_toolkit.gp_resgroup_config.proposed_concurrency */
	{ "gp_resgroup_config", 7 }, /* gp_toolkit.gp_resgroup_config.proposed_memory_limit */
	{ "gp_resgroup_config", 9 }, /* gp_toolkit.gp_resgroup_config.proposed_memory_shared_quota */
	{ "gp_resgroup_config", 11 }, /* gp_toolkit.gp_resgroup_config.proposed_memory_spill_ratio */
	{ "gp_workfile_entries", 6 }, /* gp_toolkit.workfile_entries.current_query */
	{ "gp_workfile_entries", 13 }, /* gp_toolkit.workfile_entries.directory */
	{ "gp_workfile_entries", 2 }, /* gp_toolkit.workfile_entries.procpid */
	{ "gp_workfile_entries", 14 }, /* gp_toolkit.workfile_entries.state */
	{ "gp_workfile_entries", 10 }, /* gp_toolkit.workfile_entries.workmem */
	{ "gp_workfile_usage_per_query", 6 }, /* gp_toolkit.gp_workfile_usage_per_query.current_query */
	{ "gp_workfile_usage_per_query", 2 }, /* gp_toolkit.gp_workfile_usage_per_query.procpid */
	{ "gp_workfile_usage_per_query", 8 } /* gp_toolkit.gp_workfile_usage_per_query.state */
};
static const int num_deprecated_columns_dynamic = sizeof(deprecated_columns_dynamic) / sizeof(DeprecatedColumnDynamic);

static bool is_deprecated_column(Oid reloid, int attnum)
{
	Oid gp_toolkit_oid;

	for (int i = 0; i < num_deprecated_columns_static; i++)
	{
		if (reloid == deprecated_columns_static[i].reloid &&
			attnum == deprecated_columns_static[i].attnum)
			return true;
	}

	gp_toolkit_oid = LookupExplicitNamespace("gp_toolkit");
	if (OidIsValid(gp_toolkit_oid))
	{
		for (int i = 0; i < num_deprecated_columns_dynamic; i++)
		{
			if (reloid == get_relname_relid(deprecated_columns_dynamic[i].relname, gp_toolkit_oid) &&
				attnum == deprecated_columns_dynamic[i].attnum)
				return true;
		}
	}

	return false;
}

bool
check_node_deprecated_tables_walker(Node *node, void *context)
{
	Assert(context == NULL);

	if (node == NULL)
		return false;

	if (IsA(node, RangeTblEntry))
	{
		RangeTblEntry *rte = (RangeTblEntry *) node;
		return is_deprecated_table(rte->relid);
	}
	else if(IsA(node, Query))
	{
		/*
		 * Recurse into (sub)queries to look for deprecated tables.
		 */
		return query_tree_walker((Query *) node,
								 check_node_deprecated_tables_walker,
								 NULL,
								 QTW_EXAMINE_RTES);
	}

	/*
	 * This ensures that we look for deprecated tables embedded inside
	 * expressions (e.g. CTEs, sublinks etc.) which can contain range tables.
	 */
	return expression_tree_walker(node, check_node_deprecated_tables_walker, context);
}

bool
check_node_deprecated_columns_walker(Node *node, DeprecatedColumnsWalkerContext *context)
{
	Assert(context != NULL);

	if (node == NULL)
	{
		return false;
	}

	if (IsA(node, Var))
	{
		Var * var = (Var *) node;
		List *rtable = (List *) list_nth(context->rtableStack, var->varlevelsup);
		RangeTblEntry *rte = (RangeTblEntry *) list_nth(rtable, var->varno - 1);
		return is_deprecated_column(rte->relid, var->varattno);
	}
	else if (IsA(node, Query))
	{
		/*
		 * Recurse into (sub)queries to search for deprecated columns.
		 */
		bool	retval;
		Query	*query = (Query *) node;
		context->rtableStack = lcons(query->rtable, context->rtableStack);
		retval = query_tree_walker(query,
								 check_node_deprecated_columns_walker,
								 context,
								 0);
		context->rtableStack = list_delete_first(context->rtableStack);
		return retval;
	}

	/*
	 * This ensures we look at all expressions, including entities that contain
	 * subqueries (such as CTEs and sublinks)
	 */
	return expression_tree_walker(node, check_node_deprecated_columns_walker, context);
}
