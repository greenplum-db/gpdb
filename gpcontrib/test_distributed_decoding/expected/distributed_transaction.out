-- Now Coordinator's logical decoding can decode distributed_forget logs.
-- This test-case is to verify this function.
-- Mainly use pg_logical_slot_get_changes to get the decoded distributed_forget log content
-- and verify whether the contents are as expected.
-- table and function defination
CREATE TABLE test_table(col_id int PRIMARY KEY, col_gxid int8);
-- This transaction will insert data on some segments 
CREATE OR REPLACE FUNCTION execute_distributed_transaction() RETURNS void AS $$
DECLARE
  ret int8;
BEGIN
  BEGIN
    -- We don't know how many segments the gpdb in the test environment has,
    -- so we insert a few pieces of data at will.
    INSERT INTO test_table VALUES (100);
    INSERT INTO test_table VALUES (200);
    INSERT INTO test_table VALUES (300);
    INSERT INTO test_table VALUES (400);
    INSERT INTO test_table VALUES (500);
    SELECT * FROM gp_distributed_xid() INTO ret;
    update test_table set col_gxid = ret;
  END;
END;
$$ language plpgsql;
-- pg_logical_slot_get_changes will get the decoded distributed_forget log.
-- We get the distributed-transaction-id and the number of segments executing the distributed transactions,
-- and check if they are correct.
-- This is an example of the content get by pg_logical_slot_get_changes:
-- 'DISTRIBUTED_FORGET 486272,3 segments'
-- These are generated by the pg_decode_distributed_forget function in test_distributed_decoding.c.
CREATE OR REPLACE FUNCTION test_distributed_forget() RETURNS text AS $$
DECLARE
  gxid int8;
  nsegs int;
  get_change_gxid int8;
  get_change_nsegs int;
  get_change_result text;
  get_change_part1 text;
  get_change_part2 text;
  ret text;
BEGIN
  BEGIN
    -- Get the actual gxid.
    SELECT col_gxid FROM test_table limit 1 INTO gxid;

    -- Get the actual number of segments executing the distributed transaction.
    select count(distinct gp_segment_id) from test_table into nsegs;

    SELECT data FROM pg_logical_slot_get_changes('regression_slot_p', NULL, NULL) INTO get_change_result;

    -- Get the distributed-transaction-id from decoded log content.
    SELECT * FROM SPLIT_PART(get_change_result, ',', 1) INTO get_change_part1;
    SELECT * FROM SPLIT_PART(get_change_part1, ' ', 2) INTO get_change_gxid;

    -- Get the number of segments executing the distributed transactions from  decoded log content.
    SELECT * FROM SPLIT_PART(get_change_result, ',', 2) INTO get_change_part2;
    SELECT * FROM SPLIT_PART(get_change_part2, ' ', 1) INTO get_change_nsegs;

    IF gxid = get_change_gxid AND nsegs = get_change_nsegs THEN
       ret := 'result match';
    ELSE
       ret := 'result not match';
    END IF;
    
  END;
  RETURN ret;
END;
$$ language plpgsql;
-- Start test
SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot_p', 'test_distributed_decoding');
 ?column? 
----------
 init
(1 row)

SELECT 'init' FROM execute_distributed_transaction();
 ?column? 
----------
 init
(1 row)

SELECT 'init' FROM pg_sleep(5); -- distributed_forget will be generated later
 ?column? 
----------
 init
(1 row)

SELECT * FROM test_distributed_forget();
 test_distributed_forget 
-------------------------
 result match
(1 row)

-- Clean
DROP TABLE test_table;
SELECT pg_drop_replication_slot('regression_slot_p');
 pg_drop_replication_slot 
--------------------------
 
(1 row)

DROP FUNCTION execute_distributed_transaction;
DROP FUNCTION test_distributed_forget;
