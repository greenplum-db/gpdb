<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta name="copyright" content="(C) Copyright 2022" />
<meta name="DC.rights.owner" content="(C) Copyright 2022" />
<meta name="generator" content="DITA-OT" /><meta name="DC.type" content="topic" />
<meta name="DC.title" content="CREATE TABLE" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="topic1" />
<link rel="stylesheet" type="text/css" href="../../out/commonltr.css" />
<title>CREATE TABLE</title>
</head>
<body id="topic1">

  <h1 class="title topictitle1" id="topic1__cd20941">CREATE TABLE</h1>

  <div class="body">
    <p class="p" id="topic1__sql_command_desc">Defines a new table.</p>

    <div class="note"><span class="notetitle">Note:</span> Referential integrity syntax (foreign key constraints) is accepted but not
      enforced.</div>

    <div class="section" id="topic1__section2"><h2 class="title sectiontitle">Synopsis</h2>
      
      <pre class="pre codeblock" id="topic1__sql_command_synopsis"><code>
CREATE [ [GLOBAL | LOCAL] {TEMPORARY | TEMP } | UNLOGGED] TABLE [IF NOT EXISTS] 
  &lt;table_name&gt; ( 
  [ { &lt;column_name&gt; &lt;data_type&gt; [ COLLATE &lt;collation&gt; ] [&lt;column_constraint&gt; [ ... ] ]
[ ENCODING ( &lt;storage_directive&gt; [, ...] ) ]
    | &lt;table_constraint&gt;
    | LIKE &lt;source_table&gt; [ &lt;like_option&gt; ... ] }
    | [ &lt;column_reference_storage_directive&gt; [, ...]
    [, ... ]
] )
[ INHERITS ( &lt;parent_table&gt; [, ... ] ) ]
[ WITH ( &lt;storage_parameter&gt; [=&lt;value&gt;] [, ... ] ) ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE &lt;tablespace_name&gt; ]
[ DISTRIBUTED BY (&lt;column&gt; [&lt;opclass&gt;], [ ... ] ) 
       | DISTRIBUTED RANDOMLY | DISTRIBUTED REPLICATED ]

{ --partitioned table using SUBPARTITION TEMPLATE
[ PARTITION BY &lt;partition_type&gt; (&lt;column&gt;) 
  {  [ SUBPARTITION BY &lt;partition_type&gt; (&lt;column1&gt;) 
       SUBPARTITION TEMPLATE ( &lt;template_spec&gt; ) ]
          [ SUBPARTITION BY partition_type (&lt;column2&gt;) 
            SUBPARTITION TEMPLATE ( &lt;template_spec&gt; ) ]
              [...]  }
  ( &lt;partition_spec&gt; ) ]
} |

{ -- partitioned table without SUBPARTITION TEMPLATE
[ PARTITION BY &lt;partition_type&gt; (&lt;column&gt;)
   [ SUBPARTITION BY &lt;partition_type&gt; (&lt;column1&gt;) ]
      [ SUBPARTITION BY &lt;partition_type&gt; (&lt;column2&gt;) ]
         [...]
  ( &lt;partition_spec&gt;
     [ ( &lt;subpartition_spec_column1&gt;
          [ ( &lt;subpartition_spec_column2&gt;
               [...] ) ] ) ],
  [ &lt;partition_spec&gt;
     [ ( &lt;subpartition_spec_column1&gt;
        [ ( &lt;subpartition_spec_column2&gt;
             [...] ) ] ) ], ]
    [...]
  ) ]
}

CREATE [ [GLOBAL | LOCAL] {TEMPORARY | TEMP} | UNLOGGED ] TABLE [IF NOT EXISTS] 
   &lt;table_name&gt;
    OF &lt;type_name&gt; [ (
  { &lt;column_name&gt; WITH OPTIONS [ &lt;column_constraint&gt; [ ... ] ]
    | &lt;table_constraint&gt; } 
    [, ... ]
) ]
[ WITH ( &lt;storage_parameter&gt; [=&lt;value&gt;] [, ... ] ) ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE &lt;tablespace_name&gt; ]
</code></pre>
      <p class="p">where <var class="keyword varname">column_constraint</var> is:</p>

      <pre class="pre codeblock"><code>[ CONSTRAINT &lt;constraint_name&gt;]
{ NOT NULL 
  | NULL 
  | CHECK  ( &lt;expression&gt; ) [ NO INHERIT ]
  | DEFAULT &lt;default_expr&gt;
  | UNIQUE &lt;index_parameters&gt;
  | PRIMARY KEY &lt;index_parameters&gt;
  | REFERENCES &lt;reftable&gt; [ ( refcolumn ) ] 
      [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]  
      [ ON DELETE &lt;key_action&gt; ] [ ON UPDATE &lt;key_action&gt; ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]</code></pre>
      <p class="p">and <var class="keyword varname">table_constraint</var> is:</p>

      <pre class="pre codeblock"><code>[ CONSTRAINT &lt;constraint_name&gt; ]
{ CHECK ( &lt;expression&gt; ) [ NO INHERIT ]
  | UNIQUE ( &lt;column_name&gt; [, ... ] ) &lt;index_parameters&gt;
  | PRIMARY KEY ( &lt;column_name&gt; [, ... ] ) &lt;index_parameters&gt;
  | FOREIGN KEY ( &lt;column_name&gt; [, ... ] ) 
      REFERENCES &lt;reftable&gt; [ ( &lt;refcolumn&gt; [, ... ] ) ]
      [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] 
      [ ON DELETE &lt;key_action&gt; ] [ ON UPDATE &lt;key_action&gt; ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]</code></pre>
      <div class="p">and <em class="ph i">like_option</em>
        is:<pre class="pre codeblock"><code>{INCLUDING|EXCLUDING} {DEFAULTS|CONSTRAINTS|INDEXES|STORAGE|COMMENTS|ALL}</code></pre></div>

      <p class="p">and <var class="keyword varname">index_parameters</var> in <code class="ph codeph">UNIQUE</code> and <code class="ph codeph">PRIMARY
          KEY</code> constraints are:</p>

      <pre class="pre codeblock"><code>[ WITH ( &lt;storage_parameter&gt; [=&lt;value&gt;] [, ... ] ) ]
[ USING INDEX TABLESPACE &lt;tablespace_name&gt; ] </code></pre>
      <p class="p">and <var class="keyword varname">storage_directive</var> for a column is:</p>

      <pre class="pre codeblock"><code>   compresstype={ZLIB|ZSTD|QUICKLZ|RLE_TYPE|NONE}
    [compresslevel={0-9}]
    [blocksize={8192-2097152} ]</code></pre>
      <p class="p">and <var class="keyword varname">storage_parameter</var> for the table is:</p>

      <pre class="pre codeblock"><code>   appendoptimized={TRUE|FALSE}
   blocksize={8192-2097152}
   orientation={COLUMN|ROW}
   checksum={TRUE|FALSE}
   compresstype={ZLIB|ZSTD|QUICKLZ|RLE_TYPE|NONE}
   compresslevel={0-9}
   fillfactor={10-100}
   [oids=FALSE]</code></pre>
      <p class="p">and <var class="keyword varname">key_action</var> is:</p>

      <pre class="pre codeblock"><code>    ON DELETE 
  | ON UPDATE
  | NO ACTION
  | RESTRICT
  | CASCADE
  | SET NULL
  | SET DEFAULT</code></pre>
      <p class="p">and <var class="keyword varname">partition_type</var> is:</p>

      <pre class="pre codeblock"><code>    LIST | RANGE</code></pre>
      <p class="p">and <var class="keyword varname">partition_specification</var> is:</p>

      <pre class="pre codeblock"><code>&lt;partition_element&gt; [, ...]</code></pre>
      <p class="p">and <var class="keyword varname">partition_element</var> is:</p>

      <pre class="pre codeblock"><code>   DEFAULT PARTITION &lt;name&gt;
  | [PARTITION &lt;name&gt;] VALUES (&lt;list_value&gt; [,...] )
  | [PARTITION &lt;name&gt;] 
     START ([&lt;datatype&gt;] '&lt;start_value&gt;') [INCLUSIVE | EXCLUSIVE]
     [ END ([&lt;datatype&gt;] '&lt;end_value&gt;') [INCLUSIVE | EXCLUSIVE] ]
     [ EVERY ([&lt;datatype&gt;] [&lt;number | &gt;INTERVAL] '&lt;interval_value&gt;') ]
  | [PARTITION &lt;name&gt;] 
     END ([&lt;datatype&gt;] '&lt;end_value&gt;') [INCLUSIVE | EXCLUSIVE]
     [ EVERY ([&lt;datatype&gt;] [&lt;number | &gt;INTERVAL] '&lt;interval_value&gt;') ]
[ WITH ( &lt;partition_storage_parameter&gt;=&lt;value&gt; [, ... ] ) ]
[ &lt;column_reference_storage_directive&gt; [, ...] ]
[ TABLESPACE &lt;tablespace&gt; ]</code></pre>
      <p class="p">where <var class="keyword varname">subpartition_spec</var> or <var class="keyword varname">template_spec</var> is:</p>

      <pre class="pre codeblock"><code>&lt;subpartition_element&gt; [, ...]</code></pre>
      <p class="p">and <var class="keyword varname">subpartition_element</var> is:</p>

      <pre class="pre codeblock"><code>   DEFAULT SUBPARTITION &lt;name&gt;
  | [SUBPARTITION &lt;name&gt;] VALUES (&lt;list_value&gt; [,...] )
  | [SUBPARTITION &lt;name&gt;] 
     START ([&lt;datatype&gt;] '&lt;start_value&gt;') [INCLUSIVE | EXCLUSIVE]
     [ END ([&lt;datatype&gt;] '&lt;end_value&gt;') [INCLUSIVE | EXCLUSIVE] ]
     [ EVERY ([&lt;datatype&gt;] [&lt;number | &gt;INTERVAL] '&lt;interval_value&gt;') ]
  | [SUBPARTITION &lt;name&gt;] 
     END ([&lt;datatype&gt;] '&lt;end_value&gt;') [INCLUSIVE | EXCLUSIVE]
     [ EVERY ([&lt;datatype&gt;] [&lt;number | &gt;INTERVAL] '&lt;interval_value&gt;') ]
[ WITH ( &lt;partition_storage_parameter&gt;=&lt;value&gt; [, ... ] ) ]
[ &lt;column_reference_storage_directive&gt; [, ...] ]
[ TABLESPACE &lt;tablespace&gt; ]</code></pre>
      <p class="p">where <var class="keyword varname">storage_parameter</var> for a partition is:</p>

      <pre class="pre codeblock"><code>   appendoptimized={TRUE|FALSE}
   blocksize={8192-2097152}
   orientation={COLUMN|ROW}
   checksum={TRUE|FALSE}
   compresstype={ZLIB|ZSTD|QUICKLZ|RLE_TYPE|NONE}
   compresslevel={1-19}
   fillfactor={10-100}
   [oids=FALSE]</code></pre>
    </div>

    <div class="section" id="topic1__section3"><h2 class="title sectiontitle">Description</h2>
      
      <p class="p"><code class="ph codeph">CREATE TABLE</code> creates an initially empty table in the current database. The
        user who issues the command owns the table.</p>

      <p class="p">To be able to create a table, you must have <code class="ph codeph">USAGE</code> privilege on all column
        types or the type in the <code class="ph codeph">OF</code> clause, respectively. </p>

      <p class="p">If you specify a schema name, Greenplum creates the table in the specified schema.
        Otherwise Greenplum creates the table in the current schema. Temporary tables exist in a
        special schema, so you cannot specify a schema name when creating a temporary table. Table
        names must be distinct from the name of any other table, external table, sequence, index,
        view, or foreign table in the same schema.</p>

      <p class="p"><code class="ph codeph">CREATE TABLE</code> also automatically creates a data type that represents the
        composite type corresponding to one row of the table. Therefore, tables cannot have the same
        name as any existing data type in the same schema.</p>

      <p class="p">The optional constraint clauses specify conditions that new or updated rows must satisfy
        for an insert or update operation to succeed. A constraint is an SQL object that helps
        define the set of valid values in the table in various ways. Constraints apply to tables,
        not to partitions. You cannot add a constraint to a partition or subpartition.</p>

      <p class="p">Referential integrity constraints (foreign keys) are accepted but not enforced. The
        information is kept in the system catalogs but is otherwise ignored.</p>

      <p class="p">There are two ways to define constraints: table constraints and column constraints. A
        column constraint is defined as part of a column definition. A table constraint definition
        is not tied to a particular column, and it can encompass more than one column. Every column
        constraint can also be written as a table constraint; a column constraint is only a
        notational convenience for use when the constraint only affects one column. </p>

      <p class="p">When creating a table, there is an additional clause to declare the Greenplum Database
        distribution policy. If a <code class="ph codeph">DISTRIBUTED BY</code>, <code class="ph codeph">DISTRIBUTED
          RANDOMLY</code>, or <code class="ph codeph">DISTRIBUTED REPLICATED</code> clause is not supplied, then
        Greenplum Database assigns a hash distribution policy to the table using either the
          <code class="ph codeph">PRIMARY KEY</code> (if the table has one) or the first column of the table as
        the distribution key. Columns of geometric or user-defined data types are not eligible as
        Greenplum distribution key columns. If a table does not have a column of an eligible data
        type, the rows are distributed based on a round-robin or random distribution. To ensure an
        even distribution of data in your Greenplum Database system, you want to choose a
        distribution key that is unique for each record, or if that is not possible, then choose
          <code class="ph codeph">DISTRIBUTED RANDOMLY</code>. </p>

      <p class="p">If the <code class="ph codeph">DISTRIBUTED REPLICATED</code> clause is supplied, Greenplum Database
        distributes all rows of the table to all segments in the Greenplum Database system. This
        option can be used in cases where user-defined functions must run on the segments, and
        the functions require access to all rows of the table. Replicated functions can also be used
        to improve query performance by preventing broadcast motions for the table. The
          <code class="ph codeph">DISTRIBUTED REPLICATED</code> clause cannot be used with the <code class="ph codeph">PARTITION
          BY</code> clause or the <code class="ph codeph">INHERITS</code> clause. A replicated table also cannot
        be inherited by another table. The hidden system columns (<code class="ph codeph">ctid</code>,
          <code class="ph codeph">cmin</code>, <code class="ph codeph">cmax</code>, <code class="ph codeph">xmin</code>,
        <code class="ph codeph">xmax</code>, and <code class="ph codeph">gp_segment_id</code>) cannot be referenced in user
        queries on replicated tables because they have no single, unambiguous value. Greenplum
        Database returns a <code class="ph codeph">column does not exist</code> error for the query.</p>

      <p class="p">The <code class="ph codeph">PARTITION BY</code> clause allows you to divide the table into multiple
        sub-tables (or parts) that, taken together, make up the parent table and share its schema.
        Though the sub-tables exist as independent tables, the Greenplum Database restricts their
        use in important ways. Internally, partitioning is implemented as a special form of
        inheritance. Each child table partition is created with a distinct <code class="ph codeph">CHECK</code>
        constraint which limits the data the table can contain, based on some defining criteria. The
          <code class="ph codeph">CHECK</code> constraints are also used by the query optimizer to determine which
        table partitions to scan in order to satisfy a given query predicate. These partition
        constraints are managed automatically by the Greenplum Database.</p>

    </div>

    <div class="section" id="topic1__section4"><h2 class="title sectiontitle">Parameters</h2>
      
      <dl class="dl parml">
        
          <dt class="dt pt dlterm">GLOBAL | LOCAL</dt>

          <dd class="dd pd">These keywords are present for SQL standard compatibility, but have no effect in
            Greenplum Database and are deprecated.</dd>

        
        
          <dt class="dt pt dlterm">TEMPORARY | TEMP</dt>

          <dd class="dd pd">If specified, the table is created as a temporary table. Temporary tables are
            automatically dropped at the end of a session, or optionally at the end of the current
            transaction (see <code class="ph codeph">ON COMMIT</code>). Existing permanent tables with the same
            name are not visible to the current session while the temporary table exists, unless
            they are referenced with schema-qualified names. Any indexes created on a temporary
            table are automatically temporary as well.</dd>

        
        
          <dt class="dt pt dlterm">UNLOGGED</dt>

          <dd class="dd pd">If specified, the table is created as an unlogged table. Data written to unlogged
            tables is not written to the write-ahead (WAL) log, which makes them considerably faster
            than ordinary tables. However, the contents of an unlogged table are not replicated to
            mirror segment instances. Also an unlogged table is not crash-safe. After a segment
            instance crash or unclean shutdown, the data for the unlogged table on that segment is
            truncated. Any indexes created on an unlogged table are automatically unlogged as
            well.</dd>

        
        
          <dt class="dt pt dlterm">
            <var class="keyword varname">table_name</var>
          </dt>

          <dd class="dd pd">The name (optionally schema-qualified) of the table to be created. </dd>

        
        
          <dt class="dt pt dlterm">OF <var class="keyword varname">type_name</var></dt>

          <dd class="dd pd">Creates a typed table, which takes its structure from the specified composite type
            (name optionally schema-qualified). A typed table is tied to its type; for example the
            table will be dropped if the type is dropped (with <code class="ph codeph">DROP TYPE ...
              CASCADE</code>).</dd>

          <dd class="dd pd ddexpand"> When a typed table is created, the data types of the columns are determined by the
            underlying composite type and are not specified by the <code class="ph codeph">CREATE TABLE</code>
            command. But the <code class="ph codeph">CREATE TABLE</code> command can add defaults and constraints
            to the table and can specify storage parameters. </dd>

        
        
          <dt class="dt pt dlterm">
            <var class="keyword varname">column_name</var>
          </dt>

          <dd class="dd pd">The name of a column to be created in the new table. </dd>

        
        
          <dt class="dt pt dlterm">
            <var class="keyword varname">data_type</var>
          </dt>

          <dd class="dd pd">The data type of the column. This may include array specifiers.</dd>

          <dd class="dd pd ddexpand">For table columns that contain textual data, Specify the data type
              <code class="ph codeph">VARCHAR</code> or <code class="ph codeph">TEXT</code>. Specifying the data type
              <code class="ph codeph">CHAR</code> is not recommended. In Greenplum Database, the data types
              <code class="ph codeph">VARCHAR</code> or <code class="ph codeph">TEXT</code> handles padding added to the data
            (space characters added after the last non-space character) as significant characters,
            the data type <code class="ph codeph">CHAR</code> does not. See <a class="xref" href="#topic1__section5">Notes</a>.</dd>

        
        
          <dt class="dt pt dlterm">COLLATE <var class="keyword varname">collation</var></dt>

          <dd class="dd pd">The <code class="ph codeph">COLLATE</code> clause assigns a collation to the column (which must be
            of a collatable data type). If not specified, the column data type's default collation
            is used.<div class="note"><span class="notetitle">Note:</span> GPORCA supports collation only when all columns in the query use the same
              collation. If columns in the query use different collations, then Greenplum uses the
              Postgres Planner.</div>
</dd>

        
        
          <dt class="dt pt dlterm">DEFAULT <var class="keyword varname">default_expr</var></dt>

          <dd class="dd pd">The <code class="ph codeph">DEFAULT</code> clause assigns a default data value for the column whose
            column definition it appears within. The value is any variable-free expression
            (subqueries and cross-references to other columns in the current table are not allowed).
            The data type of the default expression must match the data type of the column. The
            default expression will be used in any insert operation that does not specify a value
            for the column. If there is no default for a column, then the default is null. </dd>

        
        
          <dt class="dt pt dlterm"> ENCODING ( <var class="keyword varname">storage_directive</var> [, ...] ) </dt>

          <dd class="dd pd">For a column, the optional <code class="ph codeph">ENCODING</code> clause specifies the type of
            compression and block size for the column data. See <a class="xref" href="#topic1__with_storage">storage_options</a> for <code class="ph codeph">compresstype</code>,
              <code class="ph codeph">compresslevel</code>, and <code class="ph codeph">blocksize</code> values.</dd>

          <dd class="dd pd ddexpand">The clause is valid only for append-optimized, column-oriented tables.</dd>

          <dd class="dd pd ddexpand">Column compression settings are inherited from the table level to the partition level
            to the subpartition level. The lowest-level settings have priority.</dd>

        
        
          <dt class="dt pt dlterm">INHERITS ( parent_table [, …])</dt>

          <dd class="dd pd">The optional <code class="ph codeph">INHERITS</code> clause specifies a list of tables from which
            the new table automatically inherits all columns. Use of <code class="ph codeph">INHERITS</code>
            creates a persistent relationship between the new child table and its parent table(s).
            Schema modifications to the parent(s) normally propagate to children as well, and by
            default the data of the child table is included in scans of the parent(s). </dd>

          <dd class="dd pd ddexpand">In Greenplum Database, the <code class="ph codeph">INHERITS</code> clause is not used when creating
            partitioned tables. Although the concept of inheritance is used in partition
            hierarchies, the inheritance structure of a partitioned table is created using the
                <a class="xref" href="#topic1__part_by">PARTITION BY</a>
            clause. </dd>

          <dd class="dd pd ddexpand">If the same column name exists in more than one parent table, an error is reported
            unless the data types of the columns match in each of the parent tables. If there is no
            conflict, then the duplicate columns are merged to form a single column in the new
            table. If the column name list of the new table contains a column name that is also
            inherited, the data type must likewise match the inherited column(s), and the column
            definitions are merged into one. If the new table explicitly specifies a default value
            for the column, this default overrides any defaults from inherited declarations of the
            column. Otherwise, any parents that specify default values for the column must all
            specify the same default, or an error will be reported. </dd>

          <dd class="dd pd ddexpand"><code class="ph codeph">CHECK</code> constraints are merged in essentially the same way as columns:
            if multiple parent tables or the new table definition contain identically-named
              <code class="ph codeph">constraints</code>, these constraints must all have the same check
            expression, or an error will be reported. Constraints having the same name and
            expression will be merged into one copy. A constraint marked <code class="ph codeph">NO INHERIT</code>
            in a parent will not be considered. Notice that an unnamed <code class="ph codeph">CHECK</code>
            constraint in the new table will never be merged, since a unique name will always be
            chosen for it.</dd>

          <dd class="dd pd ddexpand">Column <code class="ph codeph">STORAGE</code> settings are also copied from parent tables.</dd>

        
        
          <dt class="dt pt dlterm">LIKE <var class="keyword varname">source_table</var>
            <var class="keyword varname">like_option</var>
            <code class="ph codeph">...</code>]</dt>

          <dd class="dd pd">The <code class="ph codeph">LIKE</code> clause specifies a table from which the new table
            automatically copies all column names, their data types, not-null constraints, and
            distribution policy. Unlike <code class="ph codeph">INHERITS</code>, the new table and original table
            are completely decoupled after creation is complete.</dd>

          <dd class="dd pd ddexpand">
            <div class="note"><span class="notetitle">Note:</span> Storage properties like append-optimized or partition structure are not
              copied.</div>

          </dd>

          <dd class="dd pd ddexpand">Default expressions for the copied column definitions will only be copied if
              <code class="ph codeph">INCLUDING DEFAULTS</code> is specified. The default behavior is to exclude
            default expressions, resulting in the copied columns in the new table having null
            defaults. </dd>

          <dd class="dd pd ddexpand">Not-null constraints are always copied to the new table. <code class="ph codeph">CHECK</code>
            constraints will be copied only if <code class="ph codeph">INCLUDING CONSTRAINTS</code> is specified.
            No distinction is made between column constraints and table constraints. </dd>

          <dd class="dd pd ddexpand">Indexes, <code class="ph codeph">PRIMARY KEY</code>, and <code class="ph codeph">UNIQUE</code> constraints on the
            original table will be created on the new table only if the <code class="ph codeph">INCLUDING
              INDEXES</code> clause is specified. Names for the new indexes and constraints are
            chosen according to the default rules, regardless of how the originals were named. (This
            behavior avoids possible duplicate-name failures for the new indexes.)</dd>

          <dd class="dd pd ddexpand">Any indexes on the original table will not be created on the new table, unless the
              <code class="ph codeph">INCLUDING INDEXES</code> clause is specified.</dd>

          <dd class="dd pd ddexpand"><code class="ph codeph">STORAGE</code> settings for the copied column definitions will be copied
            only if <code class="ph codeph">INCLUDING STORAGE</code> is specified. The default behavior is to
            exclude <code class="ph codeph">STORAGE</code> settings, resulting in the copied columns in the new
            table having type-specific default settings. </dd>

          <dd class="dd pd ddexpand"> Comments for the copied columns, constraints, and indexes will be copied only if
              <code class="ph codeph">INCLUDING COMMENTS</code> is specified. The default behavior is to exclude
            comments, resulting in the copied columns and constraints in the new table having no
            comments. </dd>

          <dd class="dd pd ddexpand">
            <code class="ph codeph">INCLUDING ALL</code> is an abbreviated form of <code class="ph codeph">INCLUDING DEFAULTS
              INCLUDING CONSTRAINTS INCLUDING INDEXES INCLUDING STORAGE INCLUDING COMMENTS</code>. </dd>

          <dd class="dd pd ddexpand"> Note that unlike <code class="ph codeph">INHERITS</code>, columns and constraints copied by
              <code class="ph codeph">LIKE</code> are not merged with similarly named columns and constraints. If
            the same name is specified explicitly or in another <code class="ph codeph">LIKE</code> clause, an
            error is signaled. </dd>

          <dd class="dd pd ddexpand">The <code class="ph codeph">LIKE</code> clause can also be used to copy columns from views, foreign
            tables, or composite types. Inapplicable options (e.g., <code class="ph codeph">INCLUDING
              INDEXES</code> from a view) are ignored. </dd>

        
        
          <dt class="dt pt dlterm">CONSTRAINT <var class="keyword varname">constraint_name</var></dt>

          <dd class="dd pd">An optional name for a column or table constraint. If the constraint is violated, the
            constraint name is present in error messages, so constraint names like <var class="keyword varname">column
              must be positive</var> can be used to communicate helpful constraint information
            to client applications. (Double-quotes are needed to specify constraint names that
            contain spaces.) If a constraint name is not specified, the system generates a
              name.<div class="note"><span class="notetitle">Note:</span> The specified <var class="keyword varname">constraint_name</var> is used for
              the constraint, but a system-generated unique name is used for the index name. In some
              prior releases, the provided name was used for both the constraint name and the index
              name. </div>
</dd>

        
        
          <dt class="dt pt dlterm">NULL | NOT NULL </dt>

          <dd class="dd pd">Specifies if the column is or is not allowed to contain null values.
              <code class="ph codeph">NULL</code> is the default.</dd>

        
        
          <dt class="dt pt dlterm">CHECK (<var class="keyword varname">expression</var>) [ NO INHERIT ]</dt>

          <dd class="dd pd">The <code class="ph codeph">CHECK</code> clause specifies an expression producing a Boolean result
            which new or updated rows must satisfy for an insert or update operation to succeed.
            Expressions evaluating to <code class="ph codeph">TRUE</code> or <code class="ph codeph">UNKNOWN</code> succeed.
            Should any row of an insert or update operation produce a <code class="ph codeph">FALSE</code> result
            an error exception is raised and the insert or update does not alter the database. A
            check constraint specified as a column constraint should reference that column's value
            only, while an expression appearing in a table constraint can reference multiple
            columns. </dd>

          <dd class="dd pd ddexpand">A constraint marked with <code class="ph codeph">NO INHERIT</code> will not propagate to child
            tables. </dd>

          <dd class="dd pd ddexpand"> Currently, <code class="ph codeph">CHECK</code> expressions cannot contain subqueries nor refer to
            variables other than columns of the current row. </dd>

        
        
          <dt class="dt pt dlterm">UNIQUE ( <var class="keyword varname">column_constraint</var> )</dt>

          <dt class="dt pt dlterm">UNIQUE ( <var class="keyword varname">column_name</var> [, ... ] ) (
              <var class="keyword varname">table_constraint</var> )</dt>

          <dd class="dd pd">The <code class="ph codeph">UNIQUE</code> constraint specifies that a group of one or more columns
            of a table may contain only unique values. The behavior of the unique table constraint
            is the same as that for column constraints, with the additional capability to span
            multiple columns. For the purpose of a unique constraint, null values are not considered
            equal. The column(s) that are unique must contain all the columns of the Greenplum
            distribution key. In addition, the <code class="ph codeph">&lt;key&gt;</code> must contain all the
            columns in the partition key if the table is partitioned. Note that a
              <code class="ph codeph">&lt;key&gt;</code> constraint in a partitioned table is not the same as a
            simple <code class="ph codeph">UNIQUE INDEX</code>.</dd>

          <dd class="dd pd ddexpand">For information about unique constraint management and limitations, see <a class="xref" href="#topic1__section5">Notes</a>.</dd>

        
        
          <dt class="dt pt dlterm">PRIMARY KEY ( <var class="keyword varname">column constraint</var> )</dt>

          <dt class="dt pt dlterm">PRIMARY KEY ( <var class="keyword varname">column_name</var> [, ... ] ) ( <var class="keyword varname">table
              constraint</var> )</dt>

          <dd class="dd pd">The <code class="ph codeph">PRIMARY KEY</code> constraint specifies that a column or columns of a
            table may contain only unique (non-duplicate), non-null values. Only one primary key can
            be specified for a table, whether as a column constraint or a table constraint. </dd>

          <dd class="dd pd ddexpand">For a table to have a primary key, it must be hash distributed (not randomly
            distributed), and the primary key, the column(s) that are unique, must contain all the
            columns of the Greenplum distribution key. In addition, the <code class="ph codeph">&lt;key&gt;</code>
            must contain all the columns in the partition key if the table is partitioned. Note that
            a <code class="ph codeph">&lt;key&gt;</code> constraint in a partitioned table is not the same as a
            simple <code class="ph codeph">UNIQUE INDEX</code>. </dd>

          <dd class="dd pd ddexpand"><code class="ph codeph">PRIMARY KEY</code> enforces the same data constraints as a combination of
              <code class="ph codeph">UNIQUE</code> and <code class="ph codeph">NOT NULL</code>, but identifying a set of
            columns as the primary key also provides metadata about the design of the schema, since
            a primary key implies that other tables can rely on this set of columns as a unique
            identifier for rows. </dd>

          <dd class="dd pd ddexpand">For information about primary key management and limitations, see <a class="xref" href="#topic1__section5">Notes</a>. </dd>

        
        
          <dt class="dt pt dlterm">REFERENCES <var class="keyword varname">reftable</var> [ ( <var class="keyword varname">refcolumn</var> ) ] </dt>

          <dt class="dt pt dlterm">     [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]</dt>

          <dt class="dt pt dlterm">     [ON DELETE | ON UPDATE]  [<var class="keyword varname">key_action</var>]</dt>

          <dt class="dt pt dlterm">FOREIGN KEY (<var class="keyword varname">column_name</var> [, ...])</dt>

          <dd class="dd pd">The <code class="ph codeph">REFERENCES</code> and <code class="ph codeph">FOREIGN KEY</code> clauses specify
            referential integrity constraints (foreign key constraints). Greenplum accepts
            referential integrity constraints as specified in PostgreSQL syntax but does not enforce
            them. See the PostgreSQL documentation for information about referential integrity
            constraints.</dd>

        
        
          <dt class="dt pt dlterm">DEFERRABLE</dt>

          <dt class="dt pt dlterm">NOT DEFERRABLE</dt>

          <dd class="dd pd">The <code class="ph codeph">[NOT] DEFERRABLE</code> clause controls whether the constraint can be
            deferred. A constraint that is not deferrable will be checked immediately after every
            command. Checking of constraints that are deferrable can be postponed until the end of
            the transaction (using the <a class="xref" href="SET_CONSTRAINTS.html#topic1"><code class="ph codeph">SET
                CONSTRAINTS</code></a> command). <code class="ph codeph">NOT DEFERRABLE</code> is the
            default. Currently, only <code class="ph codeph">UNIQUE</code> and <code class="ph codeph">PRIMARY KEY</code>
            constraints are deferrable.  <code class="ph codeph">NOT NULL</code> and <code class="ph codeph">CHECK</code>
            constraints are not deferrable. <code class="ph codeph">REFERENCES</code> (foreign key) constraints
            accept this clause but are not enforced. </dd>

        
        <dt class="dt pt dlterm">INITIALLY IMMEDIATE</dt>

        <dt class="dt pt dlterm">INITIALLY DEFERRED</dt>

          <dd class="dd pd">If a constraint is deferrable, this clause specifies the default time to check the
            constraint. If the constraint is <code class="ph codeph">INITIALLY IMMEDIATE</code>, it is checked
            after each statement. This is the default. If the constraint is <code class="ph codeph">INITIALLY
              DEFERRED</code>, it is checked only at the end of the transaction. The constraint
            check time can be altered with the <code class="ph codeph">SET CONSTRAINTS</code> command. </dd>

        
          <dt class="dt pt dlterm" id="topic1__with_storage">WITH ( <var class="keyword varname">storage_parameter=value</var> ) </dt>

          <dd class="dd pd">The <code class="ph codeph">WITH</code> clause can specify storage parameters for tables, and for
            indexes associated with a <code class="ph codeph">UNIQUE</code> or <code class="ph codeph">PRIMARY</code>
            constraint. Note that you can also set storage parameters on a particular partition or
            subpartition by declaring the <code class="ph codeph">WITH</code> clause in the partition
            specification. The lowest-level settings have priority.</dd>

          <dd class="dd pd ddexpand">The defaults for some of the table storage options can be specified with the server
            configuration parameter <code class="ph codeph">gp_default_storage_options</code>. For information
            about setting default storage options, see <a class="xref" href="#topic1__section5">Notes</a>. </dd>

          <dd class="dd pd ddexpand">The following storage options are available:</dd>

          <dd class="dd pd ddexpand"><strong class="ph b">appendoptimized</strong> — Set to <code class="ph codeph">TRUE</code> to create the table as an
            append-optimized table. If <code class="ph codeph">FALSE</code> or not declared, the table will be
            created as a regular heap-storage table.</dd>

          <dd class="dd pd ddexpand"><strong class="ph b">blocksize</strong> — Set to the size, in bytes, for each block in a table. The
              <code class="ph codeph">blocksize</code> must be between 8192 and 2097152 bytes, and be a multiple
            of 8192. The default is 32768. The <code class="ph codeph">blocksize</code>
            option is valid only if <code class="ph codeph">appendoptimized=TRUE</code>.</dd>

          <dd class="dd pd ddexpand"><strong class="ph b">orientation</strong> — Set to <code class="ph codeph">column</code> for column-oriented storage, or
              <code class="ph codeph">row</code> (the default) for row-oriented storage. This option is only valid
            if <code class="ph codeph">appendoptimized=TRUE</code>. Heap-storage tables can only be row-oriented.</dd>

          <dd class="dd pd ddexpand"><strong class="ph b">checksum</strong> — This option is valid only for append-optimized tables
              (<code class="ph codeph">appendoptimized=TRUE</code>). The value <code class="ph codeph">TRUE</code> is the
            default and enables CRC checksum validation for append-optimized tables. The checksum is
            calculated during block creation and is stored on disk. Checksum validation is performed
            during block reads. If the checksum calculated during the read does not match the stored
            checksum, the transaction is cancelled. If you set the value to
              <code class="ph codeph">FALSE</code> to disable checksum validation, checking the table data for
            on-disk corruption will not be performed.</dd>

          <dd class="dd pd ddexpand"><strong class="ph b">compresstype</strong> — Set to <code class="ph codeph">ZLIB</code> (the default),
              <code class="ph codeph">ZSTD</code>, <code class="ph codeph">RLE_TYPE</code>, or
              <code class="ph codeph">QUICKLZ</code><sup class="ph sup">1</sup> to specify the type of compression used. The
            value <code class="ph codeph">NONE</code> disables compression. Zstd provides for both speed or a good
            compression ratio, tunable with the <code class="ph codeph">compresslevel</code> option. QuickLZ and
            zlib are provided for backwards-compatibility. Zstd outperforms these compression types
            on usual workloads. The <code class="ph codeph">compresstype</code> option is only valid if
              <code class="ph codeph">appendoptimized=TRUE</code>.<div class="p">
              <div class="note"><span class="notetitle">Note:</span> <sup class="ph sup">1</sup>QuickLZ compression is available only in the commercial
                release of Tanzu Greenplum.</div>

            </div>
<p class="p">The value <code class="ph codeph">RLE_TYPE</code>, which is supported only if
                <code class="ph codeph">orientation</code>=<code class="ph codeph">column</code> is specified, enables the
              run-length encoding (RLE) compression algorithm. RLE compresses data better than the
              Zstd, zlib, or QuickLZ compression algorithms when the same data value occurs in many
              consecutive rows.</p>
<p class="p">For columns of type <code class="ph codeph">BIGINT</code>,
                <code class="ph codeph">INTEGER</code>, <code class="ph codeph">DATE</code>, <code class="ph codeph">TIME</code>, or
                <code class="ph codeph">TIMESTAMP</code>, delta compression is also applied if the
                <code class="ph codeph">compresstype</code> option is set to <code class="ph codeph">RLE_TYPE</code>
              compression. The delta compression algorithm is based on the delta between column
              values in consecutive rows and is designed to improve compression when data is loaded
              in sorted order or the compression is applied to column data that is in sorted
              order.</p>
<p class="p">For information about using table compression, see
              <a class="xref" href="../../admin_guide/ddl/ddl-storage.html#topic1" target="_blank">Choosing the Table Storage Model</a>
              in the <cite class="cite">Greenplum Database Administrator Guide</cite>.</p>
</dd>

              <dd class="dd pd ddexpand"><strong class="ph b">compresslevel</strong> — For Zstd compression of append-optimized tables, set to an
            integer value from 1 (fastest compression) to 19 (highest compression ratio). For zlib
            compression, the valid range is from 1 to 9. QuickLZ compression level can only be set
            to 1. If not declared, the default is 1. For <code class="ph codeph">RLE_TYPE</code>, the compression
            level can be an integer value from 1 (fastest compression) to 4 (highest compression
            ratio). </dd>

          <dd class="dd pd ddexpand">The <code class="ph codeph">compresslevel</code> option is valid only if <code class="ph codeph">appendoptimized=TRUE</code>.</dd>

          <dd class="dd pd ddexpand"><strong class="ph b">fillfactor</strong> — The fillfactor for a table is a percentage between 10 and 100.
            100 (complete packing) is the default. When a smaller fillfactor is specified,
            <code class="ph codeph">INSERT</code> operations pack table pages only to the indicated percentage;
            the remaining space on each page is reserved for updating rows on that page. This
             gives <code class="ph codeph">UPDATE</code> a chance to place the updated copy of a row on the
             same page as the original, which is more efficient than placing it on a different
             page. For a table whose entries are never updated, complete packing is the best
             choice, but in heavily updated tables smaller fillfactors are appropriate. This
             parameter cannot be set for TOAST tables.</dd>

          <dd class="dd pd ddexpand"><strong class="ph b">oids=FALSE</strong> — This setting is the default, and it ensures that rows do not have
            object identifiers assigned to them. <span class="ph">VMware does not support
              using <code class="ph codeph">WITH OIDS</code> or <code class="ph codeph">oids=TRUE</code> to assign an OID system
              column. </span>On large tables, such as those in a typical Greenplum Database system,
            using OIDs for table rows can cause wrap-around of the 32-bit OID counter. Once the
            counter wraps around, OIDs can no longer be assumed to be unique, which not only makes
            them useless to user applications, but can also cause problems in the Greenplum Database
            system catalog tables. In addition, excluding OIDs from a table reduces the space
            required to store the table on disk by 4 bytes per row, slightly improving performance.
            You cannot create OIDS on a partitioned or column-oriented table (an error is
            displayed). This syntax is deprecated and will be removed in a future Greenplum
            release.</dd>

        
        
          <dt class="dt pt dlterm">ON COMMIT</dt>

          <dd class="dd pd">The behavior of temporary tables at the end of a transaction block can be controlled
            using <code class="ph codeph">ON COMMIT</code>. The three options are: </dd>

          <dd class="dd pd ddexpand"><strong class="ph b">PRESERVE ROWS</strong> - No special action is taken at the ends of transactions for
            temporary tables. This is the default behavior. </dd>

          <dd class="dd pd ddexpand"><strong class="ph b">DELETE ROWS</strong> - All rows in the temporary table will be deleted at the end of
            each transaction block. Essentially, an automatic <code class="ph codeph">TRUNCATE</code> is done at
            each commit. </dd>

          <dd class="dd pd ddexpand"><strong class="ph b">DROP</strong> - The temporary table will be dropped at the end of the current
            transaction block. </dd>

        
        
          <dt class="dt pt dlterm">TABLESPACE <var class="keyword varname">tablespace</var></dt>

          <dd class="dd pd">The name of the tablespace in which the new table is to be created. If not specified,
            the database's default tablespace is used, or <a class="xref" href="../config_params/guc-list.html#topic_k52_fqm_f3b">temp_tablespaces</a> if the table is
            temporary.</dd>

        
        
          <dt class="dt pt dlterm">USING INDEX TABLESPACE <var class="keyword varname">tablespace</var></dt>

          <dd class="dd pd">This clause allows selection of the tablespace in which the index associated with a
              <code class="ph codeph">UNIQUE</code> or <code class="ph codeph">PRIMARY KEY</code> constraint will be created. If
            not specified, the database's default tablespace is used, or <a class="xref" href="../config_params/guc-list.html#topic_k52_fqm_f3b">temp_tablespaces</a> if the table is temporary. </dd>

        
        
          <dt class="dt pt dlterm">DISTRIBUTED BY (<var class="keyword varname">column</var> [<var class="keyword varname">opclass</var>], [ ... ] )</dt>

          <dt class="dt pt dlterm">DISTRIBUTED RANDOMLY</dt>

          <dt class="dt pt dlterm">DISTRIBUTED REPLICATED</dt>

          <dd class="dd pd">Used to declare the Greenplum Database distribution policy for the table.
              <code class="ph codeph">DISTRIBUTED BY</code> uses hash distribution with one or more columns
            declared as the distribution key. For the most even data distribution, the distribution
            key should be the primary key of the table or a unique column (or set of columns). If
            that is not possible, then you may choose <code class="ph codeph">DISTRIBUTED RANDOMLY</code>, which
            will send the data round-robin to the segment instances. Additionally, an operator
            class, <code class="ph codeph">opclass</code>, can be specified, to use a non-default hash function. </dd>

          <dd class="dd pd ddexpand">The Greenplum Database server configuration parameter
              <code class="ph codeph">gp_create_table_random_default_distribution</code> controls the default
            table distribution policy if the <span class="keyword cmdname">DISTRIBUTED BY</span> clause is not
            specified when you create a table. Greenplum Database follows these rules to create a
            table if a distribution policy is not specified. <div class="p">If the value of the parameter is
                <code class="ph codeph">off</code> (the default), Greenplum Database chooses the table
              distribution key based on the command:<ul class="ul" id="topic1__ul_rjb_gty_qfb">
                <li class="li">If a <code class="ph codeph">LIKE</code> or <code class="ph codeph">INHERITS</code> clause is specified,
                  then Greenplum copies the distribution key from the source or parent table.</li>

                <li class="li">If a <code class="ph codeph">PRIMARY KEY</code> or <code class="ph codeph">UNIQUE</code> constraints are
                  specified, then Greenplum chooses the largest subset of all the key columns as the
                  distribution key.</li>

                <li class="li">If neither constraints nor a <code class="ph codeph">LIKE</code> or <code class="ph codeph">INHERITS</code>
                  clause is specified, then Greenplum chooses the first suitable column as the
                  distribution key. (Columns with geometric or user-defined data types are not
                  eligible as Greenplum distribution key columns.)</li>

              </ul>
</div>
<div class="p">If the value of the parameter is set to <code class="ph codeph">on</code>, Greenplum
              Database follows these rules:<ul class="ul" id="topic1__ul_tbr_5kq_kq">
                <li class="li">If <span class="keyword cmdname">PRIMARY KEY</span> or <span class="keyword cmdname">UNIQUE</span> columns are not
                  specified, the distribution of the table is random (<span class="keyword cmdname">DISTRIBUTED
                    RANDOMLY</span>). Table distribution is random even if the table creation
                  command contains the <span class="keyword cmdname">LIKE</span> or <span class="keyword cmdname">INHERITS</span>
                  clause. </li>

                <li class="li">If <span class="keyword cmdname">PRIMARY KEY</span> or <span class="keyword cmdname">UNIQUE</span> columns are
                  specified, a <span class="keyword cmdname">DISTRIBUTED BY</span> clause must also be specified. If a
                    <span class="keyword cmdname">DISTRIBUTED BY</span> clause is not specified as part of the table
                  creation command, the command fails.</li>

              </ul>
</div>
</dd>

          <dd class="dd pd ddexpand">For more information about setting the default table distribution policy, see <a class="xref" href="../config_params/guc-list.html#gp_create_table_random_default_distribution"><code class="ph codeph">gp_create_table_random_default_distribution</code></a>. </dd>

          <dd class="dd pd ddexpand">The <code class="ph codeph">DISTRIBUTED REPLICATED</code> clause replicates the entire table to all
            Greenplum Database segment instances. It can be used when it is necessary to run 
            user-defined functions on segments when the functions require access to all rows in the
            table, or to improve query performance by preventing broadcast motions. </dd>

        
        
          <dt class="dt pt dlterm" id="topic1__part_by">PARTITION BY</dt>

          <dd class="dd pd">Declares one or more columns by which to partition the table.</dd>

          <dd class="dd pd ddexpand">When creating a partitioned table, Greenplum Database creates the root partitioned
            table (the root partition) with the specified table name. Greenplum Database also
            creates a hierarchy of tables, child tables, that are the subpartitions based on the
            partitioning options that you specify. The Greenplum Database <em class="ph i">pg_partition</em>*
            system views contain information about the subpartition tables.</dd>

          <dd class="dd pd ddexpand">For each partition level (each hierarchy level of tables), a partitioned table can
            have a maximum of 32,767 partitions. </dd>

          <dd class="dd pd ddexpand">
            <div class="note"><span class="notetitle">Note:</span>  Greenplum Database stores partitioned table data in the leaf child tables, the
              lowest-level tables in the hierarchy of child tables for use by the partitioned
              table.</div>

          </dd>

          <dd class="dd pd ddexpand">
            <dl class="dl parml">
              
                <dt class="dt pt dlterm">
                  <var class="keyword varname">partition_type</var>
                </dt>

                <dd class="dd pd">Declares partition type: <code class="ph codeph">LIST</code> (list of values) or
                    <code class="ph codeph">RANGE</code> (a numeric or date range). </dd>

              
              
                <dt class="dt pt dlterm">
                  <var class="keyword varname">partition_specification</var>
                </dt>

                <dd class="dd pd">Declares the individual partitions to create. Each partition can be defined
                  individually or, for range partitions, you can use the <code class="ph codeph">EVERY</code>
                  clause (with a <code class="ph codeph">START</code> and optional <code class="ph codeph">END</code> clause) to
                  define an increment pattern to use to create the individual partitions.</dd>

                <dd class="dd pd ddexpand"><strong class="ph b"><code class="ph codeph">DEFAULT PARTITION <var class="keyword varname">name</var></code></strong> — Declares a
                  default partition. When data does not match to an existing partition, it is
                  inserted into the default partition. Partition designs that do not have a default
                  partition will reject incoming rows that do not match to an existing
                  partition.</dd>

                <dd class="dd pd ddexpand"><strong class="ph b"><code class="ph codeph">PARTITION <var class="keyword varname">name</var></code></strong> — Declares a name to
                  use for the partition. Partitions are created using the following naming
                  convention:
                      <code class="ph codeph"><var class="keyword varname">parentname</var>_<var class="keyword varname">level#</var>_prt_<var class="keyword varname">givenname</var></code>.</dd>

                <dd class="dd pd ddexpand"><strong class="ph b"><code class="ph codeph">VALUES</code></strong> — For list partitions, defines the value(s) that
                  the partition will contain.</dd>

                <dd class="dd pd ddexpand"><strong class="ph b"><code class="ph codeph">START</code></strong> — For range partitions, defines the starting range
                  value for the partition. By default, start values are <code class="ph codeph">INCLUSIVE</code>.
                  For example, if you declared a start date of '<code class="ph codeph">2016-01-01</code>', then
                  the partition would contain all dates greater than or equal to
                    '<code class="ph codeph">2016-01-01</code>'. Typically the data type of the
                    <code class="ph codeph">START</code> expression is the same type as the partition key column.
                  If that is not the case, then you must explicitly cast to the intended data type. </dd>

                <dd class="dd pd ddexpand"><strong class="ph b"><code class="ph codeph">END</code></strong> — For range partitions, defines the ending range
                  value for the partition. By default, end values are <code class="ph codeph">EXCLUSIVE</code>.
                  For example, if you declared an end date of '<code class="ph codeph">2016-02-01</code>', then
                  the partition would contain all dates less than but not equal to
                    '<code class="ph codeph">2016-02-01</code>'. Typically the data type of the
                    <code class="ph codeph">END</code> expression is the same type as the partition key column. If
                  that is not the case, then you must explicitly cast to the intended data
                  type.</dd>

                <dd class="dd pd ddexpand"><strong class="ph b"><code class="ph codeph">EVERY</code></strong> — For range partitions, defines how to increment
                  the values from <code class="ph codeph">START</code> to <code class="ph codeph">END</code> to create
                  individual partitions. Typically the data type of the <code class="ph codeph">EVERY</code>
                  expression is the same type as the partition key column. If that is not the case,
                  then you must explicitly cast to the intended data type.</dd>

                <dd class="dd pd ddexpand"><strong class="ph b"><code class="ph codeph">WITH</code>
                  </strong>— Sets the table storage options for a partition. For example, you may want
                  older partitions to be append-optimized tables and newer partitions to be regular
                  heap tables. </dd>

                <dd class="dd pd ddexpand"><strong class="ph b"><code class="ph codeph">TABLESPACE</code></strong> — The name of the tablespace in which the
                  partition is to be created. </dd>

              
            </dl>

          </dd>

        
        
          <dt class="dt pt dlterm">SUBPARTITION BY</dt>

          <dd class="dd pd">Declares one or more columns by which to subpartition the first-level partitions of
            the table. The format of the subpartition specification is similar to that of a
            partition specification described above. </dd>

        
        
          <dt class="dt pt dlterm">SUBPARTITION TEMPLATE</dt>

          <dd class="dd pd">Instead of declaring each subpartition definition individually for each partition, you
            can optionally declare a subpartition template to be used to create the subpartitions
            (lower level child tables). This subpartition specification would then apply to all
            parent partitions.</dd>

        
      </dl>

    </div>

    <div class="section" id="topic1__section5"><h2 class="title sectiontitle">Notes</h2>
      
      <ul class="ul" id="topic1__ul_stf_sl1_tt">
        <li class="li">In Greenplum Database (a Postgres-based system) the data types <code class="ph codeph">VARCHAR</code>
          or <code class="ph codeph">TEXT</code> handle padding added to the textual data (space characters added
          after the last non-space character) as significant characters; the data type
            <code class="ph codeph">CHAR</code> does not.<p class="p">In Greenplum Database, values of type
                <code class="ph codeph">CHAR(<var class="keyword varname">n</var>)</code> are padded with trailing spaces to the
            specified width <var class="keyword varname">n</var>. The values are stored and displayed with the
            spaces. However, the padding spaces are treated as semantically insignificant. When the
            values are distributed, the trailing spaces are disregarded. The trailing spaces are
            also treated as semantically insignificant when comparing two values of data type
              <code class="ph codeph">CHAR</code>, and the trailing spaces are removed when converting a character
            value to one of the other string types. </p>
</li>

        <li class="li"><span class="ph">VMware does not support using <code class="ph codeph">WITH OIDS</code> or
              <code class="ph codeph">oids=TRUE</code> to assign an OID system column. </span><span class="ph">Using OIDs in new applications is not recommended. </span> This
          syntax is deprecated and will be removed in a future Greenplum release. As an alternative,
          use a <code class="ph codeph">SERIAL</code> or other sequence generator as the table's primary key.
          However, if your application does make use of OIDs to identify specific rows of a table,
          it is recommended to create a unique constraint on the OID column of that table, to ensure
          that OIDs in the table will indeed uniquely identify rows even after counter wrap-around.
          Avoid assuming that OIDs are unique across tables; if you need a database-wide unique
          identifier, use the combination of table OID and row OID for that purpose.</li>

        <li class="li">Greenplum Database has some special conditions for primary key and unique constraints
          with regards to columns that are the <em class="ph i">distribution key</em> in a Greenplum table. For a
          unique constraint to be enforced in Greenplum Database, the table must be hash-distributed
          (not <code class="ph codeph">DISTRIBUTED RANDOMLY</code>), and the constraint columns must be the same
          as (or a superset of) the table's distribution key columns. <p class="p">Replicated tables
              (<code class="ph codeph">DISTRIBUTED REPLICATED</code>) can have both <code class="ph codeph">PRIMARY KEY</code>
            and <code class="ph codeph">UNIQUE</code>column constraints.</p>
<p class="p">A primary key constraint is simply
            a combination of a unique constraint and a not-null constraint.</p>
<p class="p">Greenplum Database
            automatically creates a <code class="ph codeph">UNIQUE</code> index for each <code class="ph codeph">UNIQUE</code>
            or <code class="ph codeph">PRIMARY KEY</code> constraint to enforce uniqueness. Thus, it is not
            necessary to create an index explicitly for primary key columns. <code class="ph codeph">UNIQUE</code>
            and <code class="ph codeph">PRIMARY KEY</code> constraints are not allowed on append-optimized tables
            because the <code class="ph codeph">UNIQUE</code> indexes that are created by the constraints are not
            allowed on append-optimized tables.</p>
<p class="p">Foreign key constraints are not supported in
            Greenplum Database. </p>
<p class="p">For inherited tables, unique constraints, primary key
            constraints, indexes and table privileges are <em class="ph i">not</em> inherited in the current
            implementation.</p>
</li>

        <li class="li">For append-optimized tables, <code class="ph codeph">UPDATE</code> and <code class="ph codeph">DELETE</code> are not
          allowed in a repeatable read or serializable transaction and will cause the transaction to
          end prematurely. <code class="ph codeph">DECLARE...FOR UPDATE</code>, and triggers are not supported
          with append-optimized tables. <code class="ph codeph">CLUSTER</code> on append-optimized tables is only
          supported over B-tree indexes.</li>

        <li class="li">To insert data into a partitioned table, you specify the root partitioned table, the
          table created with the <code class="ph codeph">CREATE TABLE</code> command. You also can specify a leaf
          child table of the partitioned table in an <code class="ph codeph">INSERT</code> command. An error is
          returned if the data is not valid for the specified leaf child table. Specifying a child
          table that is not a leaf child table in the <code class="ph codeph">INSERT</code> command is not
          supported. Execution of other DML commands such as <code class="ph codeph">UPDATE</code> and
            <code class="ph codeph">DELETE</code> on any child table of a partitioned table is not supported.
          These commands must be run on the root partitioned table, the table created with the
            <code class="ph codeph">CREATE TABLE</code> command.</li>

        <li class="li">The default values for these table storage options can be specified with the server
          configuration parameter <code class="ph codeph">gp_default_storage_option</code>.<ul class="ul" id="topic1__ul_hr1_3m1_tt">
            <li class="li">
              <span class="keyword cmdname">appendoptimized</span>
            </li>

            <li class="li">
              <span class="keyword cmdname">blocksize</span>
            </li>

            <li class="li">
              <span class="keyword cmdname">checksum</span>
            </li>

            <li class="li">
              <span class="keyword cmdname">compresstype</span>
            </li>

            <li class="li">
              <span class="keyword cmdname">compresslevel</span>
            </li>

            <li class="li">
              <span class="keyword cmdname">orientation</span>
            </li>

          </ul>
<p class="p">The defaults can be set for the system, a database, or a user. For information
            about setting storage options, see the server configuration parameter <a class="xref" href="../config_params/guc-list.html#gp_default_storage_options">gp_default_storage_options</a>.</p>
</li>

      </ul>

      <div class="note important"><span class="importanttitle">Important:</span> The current Postgres Planner allows list partitions
        with multi-column (composite) partition keys. GPORCA does not support composite keys, so
        using composite partition keys is not recommended.</div>

    </div>

    <div class="section" id="topic1__section6"><h2 class="title sectiontitle">Examples</h2>
      
      <p class="p">Create a table named <code class="ph codeph">rank</code> in the schema named <code class="ph codeph">baby</code> and
        distribute the data using the columns <code class="ph codeph">rank</code>, <code class="ph codeph">gender</code>, and
          <code class="ph codeph">year</code>:</p>

      <pre class="pre codeblock"><code>CREATE TABLE baby.rank (id int, rank int, year smallint, 
gender char(1), count int ) DISTRIBUTED BY (rank, gender, 
year);</code></pre>
      <p class="p">Create table films and table distributors (the primary key will be used as the Greenplum
        distribution key by default): </p>

      <pre class="pre codeblock"><code>CREATE TABLE films (
code        char(5) CONSTRAINT firstkey PRIMARY KEY,
title       varchar(40) NOT NULL,
did         integer NOT NULL,
date_prod   date,
kind        varchar(10),
len         interval hour to minute
);

CREATE TABLE distributors (
did    integer PRIMARY KEY DEFAULT nextval('serial'),
name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')
);</code></pre>
      <p class="p">Create a gzip-compressed, append-optimized table:</p>

      <pre class="pre codeblock"><code>CREATE TABLE sales (txn_id int, qty int, date date) 
WITH (appendoptimized=true, compresslevel=5) 
DISTRIBUTED BY (txn_id);</code></pre>
      <div class="p">Create a simple, single level partitioned
        table:<pre class="pre codeblock"><code>CREATE TABLE sales (id int, year int, qtr int, c_rank int, code char(1), region text)
DISTRIBUTED BY (id)
PARTITION BY LIST (code)
( PARTITION sales VALUES ('S'),
  PARTITION returns VALUES ('R')
);</code></pre></div>

      <div class="p">Create a three level partitioned table that defines subpartitions without the
          <code class="ph codeph">SUBPARTITION TEMPLATE</code> clause:
        <pre class="pre codeblock"><code>CREATE TABLE sales (id int, year int, qtr int, c_rank int, code char(1), region text)
DISTRIBUTED BY (id)
PARTITION BY LIST (code)
  SUBPARTITION BY RANGE (c_rank)
    SUBPARTITION by LIST (region)

( PARTITION sales VALUES ('S')
   ( SUBPARTITION cr1 START (1) END (2)
      ( SUBPARTITION ca VALUES ('CA') ), 
      SUBPARTITION cr2 START (3) END (4)
        ( SUBPARTITION ca VALUES ('CA') ) ),

 PARTITION returns VALUES ('R')
   ( SUBPARTITION cr1 START (1) END (2)
      ( SUBPARTITION ca VALUES ('CA') ), 
     SUBPARTITION cr2 START (3) END (4)
        ( SUBPARTITION ca VALUES ('CA') ) )
);</code></pre></div>

      <div class="p">Create the same partitioned table as the previous table using the <code class="ph codeph">SUBPARTITION
          TEMPLATE</code>
        clause:<pre class="pre codeblock"><code>CREATE TABLE sales1 (id int, year int, qtr int, c_rank int, code char(1), region text)
DISTRIBUTED BY (id)
PARTITION BY LIST (code)

   SUBPARTITION BY RANGE (c_rank)
     SUBPARTITION TEMPLATE (
     SUBPARTITION cr1 START (1) END (2),
     SUBPARTITION cr2 START (3) END (4) )

     SUBPARTITION BY LIST (region)
       SUBPARTITION TEMPLATE (
       SUBPARTITION ca VALUES ('CA') )

( PARTITION sales VALUES ('S'),
  PARTITION  returns VALUES ('R')
) ;</code></pre></div>

      <div class="p">Create a three level partitioned table using subpartition templates and default partitions
        at each
        level:<pre class="pre codeblock"><code>CREATE TABLE sales (id int, year int, qtr int, c_rank int, code char(1), region text)
DISTRIBUTED BY (id)
PARTITION BY RANGE (year)

  SUBPARTITION BY RANGE (qtr)
    SUBPARTITION TEMPLATE (
    START (1) END (5) EVERY (1), 
    DEFAULT SUBPARTITION bad_qtr )

    SUBPARTITION BY LIST (region)
      SUBPARTITION TEMPLATE (
      SUBPARTITION usa VALUES ('usa'),
      SUBPARTITION europe VALUES ('europe'),
      SUBPARTITION asia VALUES ('asia'),
      DEFAULT SUBPARTITION other_regions)

( START (2009) END (2011) EVERY (1),
  DEFAULT PARTITION outlying_years);</code></pre></div>

    </div>

    <div class="section" id="topic1__section7"><h2 class="title sectiontitle">Compatibility</h2>
      
      <p class="p"><code class="ph codeph">CREATE TABLE</code> command conforms to the SQL standard, with the following
        exceptions:</p>

      <ul class="ul">
        <li class="li" id="topic1__cd150267"><strong class="ph b">Temporary Tables</strong> — In the SQL standard, temporary tables are
          defined just once and automatically exist (starting with empty contents) in every session
          that needs them. Greenplum Database instead requires each session to issue its own
            <code class="ph codeph">CREATE TEMPORARY TABLE</code> command for each temporary table to be used.
          This allows different sessions to use the same temporary table name for different
          purposes, whereas the standard's approach constrains all instances of a given temporary
          table name to have the same table structure. <p class="p">The standard's distinction between global
            and local temporary tables is not in Greenplum Database. Greenplum Database will accept
            the <code class="ph codeph">GLOBAL</code> and <code class="ph codeph">LOCAL</code> keywords in a temporary table
            declaration, but they have no effect and are deprecated.</p>
<p class="p">If the <code class="ph codeph">ON
              COMMIT</code> clause is omitted, the SQL standard specifies that the default
            behavior as <code class="ph codeph">ON COMMIT DELETE ROWS</code>. However, the default behavior in
            Greenplum Database is <code class="ph codeph">ON COMMIT PRESERVE ROWS</code>. The <code class="ph codeph">ON COMMIT
              DROP</code> option does not exist in the SQL standard. </p>
</li>

        <li class="li" id="topic1__cd150376"><strong class="ph b">Column Check Constraints</strong> — The SQL standard says that
            <code class="ph codeph">CHECK</code> column constraints may only refer to the column they apply to;
          only <code class="ph codeph">CHECK</code> table constraints may refer to multiple columns. Greenplum
          Database does not enforce this restriction; it treats column and table check constraints
          alike. </li>

        <li class="li" id="topic1__cd150386"><strong class="ph b">NULL Constraint</strong> — The <code class="ph codeph">NULL</code> constraint is a
          Greenplum Database extension to the SQL standard that is included for compatibility with
          some other database systems (and for symmetry with the <code class="ph codeph">NOT NULL</code>
          constraint). Since it is the default for any column, its presence is not required.</li>

        <li class="li" id="topic1__cd150401"><strong class="ph b">Inheritance</strong> — Multiple inheritance via the
            <code class="ph codeph">INHERITS</code> clause is a Greenplum Database language extension. SQL:1999
          and later define single inheritance using a different syntax and different semantics.
          SQL:1999-style inheritance is not yet supported by Greenplum Database. </li>

        <li class="li" id="topic1__cd153512"><strong class="ph b">Partitioning</strong> — Table partitioning via the <code class="ph codeph">PARTITION
            BY</code> clause is a Greenplum Database language extension. </li>

        <li class="li" id="topic1__cd150414"><strong class="ph b">Zero-column tables</strong> — Greenplum Database allows a table of no
          columns to be created (for example, <code class="ph codeph">CREATE TABLE foo();</code>). This is an
          extension from the SQL standard, which does not allow zero-column tables. Zero-column
          tables are not in themselves very useful, but disallowing them creates odd special cases
          for <code class="ph codeph">ALTER TABLE DROP COLUMN</code>, so Greenplum decided to ignore this spec
          restriction. </li>

        <li class="li"><strong class="ph b">LIKE</strong> — While a <code class="ph codeph">LIKE</code> clause exists in the SQL standard, many of the
          options that Greenplum Database accepts for it are not
          in the standard, and some of the standard's options are not implemented
          by Greenplum Database.</li>

        <li class="li" id="topic1__cd150435"><strong class="ph b">WITH clause</strong> — The <code class="ph codeph">WITH</code> clause is a Greenplum
          Database extension; neither storage parameters nor OIDs are in the standard. </li>

        <li class="li" id="topic1__cd150445"><strong class="ph b">Tablespaces</strong> — The Greenplum Database concept of tablespaces is not
          part of the SQL standard. The clauses <code class="ph codeph">TABLESPACE</code> and <code class="ph codeph">USING INDEX
            TABLESPACE</code> are extensions. </li>

        <li class="li" id="topic1__cd150459"><strong class="ph b">Data Distribution</strong> — The Greenplum Database concept of a parallel or
          distributed database is not part of the SQL standard. The <code class="ph codeph">DISTRIBUTED</code>
          clauses are extensions.</li>

      </ul>

    </div>

    <div class="section" id="topic1__section8"><h2 class="title sectiontitle">See Also</h2>
      
      <p class="p"><a class="xref" href="ALTER_TABLE.html#topic1">ALTER
          TABLE</a>, <a class="xref" href="DROP_TABLE.html#topic1">DROP TABLE</a>, <a class="xref" href="CREATE_EXTERNAL_TABLE.html#topic1">CREATE EXTERNAL
            TABLE</a>, <a class="xref" href="CREATE_TABLE_AS.html#topic1">CREATE TABLE AS</a></p>

    </div>

  </div>

</body>
</html>