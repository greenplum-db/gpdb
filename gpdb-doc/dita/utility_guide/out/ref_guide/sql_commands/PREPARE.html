<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta name="copyright" content="(C) Copyright 2022" />
<meta name="DC.rights.owner" content="(C) Copyright 2022" />
<meta name="generator" content="DITA-OT" /><meta name="DC.type" content="topic" />
<meta name="DC.title" content="PREPARE" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="topic1" />
<link rel="stylesheet" type="text/css" href="../../out/commonltr.css" />
<title>PREPARE</title>
</head>
<body id="topic1">

  <h1 class="title topictitle1" id="topic1__dx20941">PREPARE</h1>

  <div class="body">
    <p class="p" id="topic1__sql_command_desc">Prepare a statement for execution.</p>

    <div class="section" id="topic1__section2"><h2 class="title sectiontitle">Synopsis</h2>
      
      <pre class="pre codeblock" id="topic1__sql_command_synopsis"><code>PREPARE &lt;name&gt; [ (&lt;datatype&gt; [, ...] ) ] AS &lt;statement&gt;</code></pre>
    </div>

    <div class="section" id="topic1__section3"><h2 class="title sectiontitle">Description</h2>
      
      <p class="p"><code class="ph codeph">PREPARE</code> creates a prepared statement. A prepared statement is a
        server-side object that can be used to optimize performance. When the
          <code class="ph codeph">PREPARE</code> statement is run, the specified statement is parsed,
        analyzed, and rewritten. When an <code class="ph codeph">EXECUTE</code> command is subsequently issued,
        the prepared statement is planned and run. This division of labor avoids repetitive
        parse analysis work, while allowing the execution plan to depend on the specific parameter
        values supplied.</p>

      <p class="p">Prepared statements can take parameters, values that are substituted into the statement
        when it is run. When creating the prepared statement, refer to parameters by position,
        using <code class="ph codeph">$1</code>, <code class="ph codeph">$2</code>, etc. A corresponding list of parameter data
        types can optionally be specified. When a parameter's data type is not specified or is
        declared as unknown, the type is inferred from the context in which the parameter is first
        used (if possible). When running the statement, specify the actual values for these
        parameters in the <code class="ph codeph">EXECUTE</code> statement.</p>

      <p class="p">Prepared statements only last for the duration of the current database session. When the
        session ends, the prepared statement is forgotten, so it must be recreated before being used
        again. This also means that a single prepared statement cannot be used by multiple
        simultaneous database clients; however, each client can create their own prepared statement
        to use. Prepared statements can be manually cleaned up using the <a class="xref" href="DEALLOCATE.html#topic1">DEALLOCATE</a> command. </p>

      <p class="p">Prepared statements have the largest performance advantage when a single session is being
        used to run a large number of similar statements. The performance difference will be
        particularly significant if the statements are complex to plan or rewrite, for example, if
        the query involves a join of many tables or requires the application of several rules. If
        the statement is relatively simple to plan and rewrite but relatively expensive to run,
        the performance advantage of prepared statements will be less noticeable.</p>

    </div>

    <div class="section" id="topic1__section4"><h2 class="title sectiontitle">Parameters</h2>
      
      <dl class="dl parml">
        
          <dt class="dt pt dlterm"><var class="keyword varname">name</var></dt>

          <dd class="dd pd">An arbitrary name given to this particular prepared statement. It must be unique
            within a single session and is subsequently used to run or deallocate a previously
            prepared statement.</dd>

        
        
          <dt class="dt pt dlterm"><var class="keyword varname">datatype</var></dt>

          <dd class="dd pd">The data type of a parameter to the prepared statement. If the data type of a
            particular parameter is unspecified or is specified as unknown, it will be inferred from
            the context in which the parameter is first used. To refer to the parameters in the
            prepared statement itself, use <code class="ph codeph">$1</code>, <code class="ph codeph">$2</code>, etc. </dd>

        
        
          <dt class="dt pt dlterm"><var class="keyword varname">statement</var></dt>

          <dd class="dd pd">Any <code class="ph codeph">SELECT</code>, <code class="ph codeph">INSERT</code>, <code class="ph codeph">UPDATE</code>,
              <code class="ph codeph">DELETE</code>, or <code class="ph codeph">VALUES</code> statement.</dd>

        
      </dl>

    </div>

    <div class="section" id="topic1__section5"><h2 class="title sectiontitle">Notes</h2>
      
      <p class="p">A prepared statement can be run with either a <em class="ph i">generic plan</em> or a <em class="ph i">custom
          plan</em>. A generic plan is the same across all executions, while a custom plan is
        generated for a specific execution using the parameter values given in that call. Use of a
        generic plan avoids planning overhead, but in some situations a custom plan will be much
        more efficient to run because the planner can make use of knowledge of the parameter
        values. If the prepared statement has no parameters, a generic plan is always used.</p>

      <p class="p">By default (with the default value, <code class="ph codeph">auto</code>, for the server configuration
        parameter <a class="xref" href="../config_params/guc-list.html#plan_cache_mode">plan_cache_mode</a>), the server automatically chooses whether to use a
        generic or custom plan for a prepared statement that has parameters. The current rule for
        this is that the first five executions are done with custom plans and the average estimated
        cost of those plans is calculated. Then a generic plan is created and its estimated cost is
        compared to the average custom-plan cost. Subsequent executions use the generic plan if its
        cost is not so much higher than the average custom-plan cost as to make repeated replanning
        seem preferable.</p>

      <p class="p">This heuristic can be overridden, forcing the server to use either generic or custom plans,
        by setting <code class="ph codeph">plan_cache_mode</code> to <code class="ph codeph">force_generic_plan</code> or
          <code class="ph codeph">force_custom_plan</code> respectively. This setting is primarily useful if the
        generic plan's cost estimate is badly off for some reason, allowing it to be chosen even
        though its actual cost is much more than that of a custom plan.</p>

      <p class="p">To examine the query plan Greenplum Database is using for a prepared statement, use
            <a class="xref" href="EXPLAIN.html">EXPLAIN</a>, for
        example</p>

      <pre class="pre codeblock"><code>EXPLAIN EXECUTE &lt;name&gt;(&lt;parameter_values&gt;);</code></pre>
      <p class="p">If a generic plan is in use, it will contain parameter symbols <code class="ph codeph">$n</code>, while a
        custom plan will have the supplied parameter values substituted into it.</p>

      <p class="p">For more information on query planning and the statistics collected by Greenplum Database
        for that purpose, see the <code class="ph codeph">ANALYZE</code> documentation.</p>

      <p class="p">Although the main point of a prepared statement is to avoid repeated parse analysis and
        planning of the statement, Greenplum will force re-analysis and re-planning of the statement
        before using it whenever database objects used in the statement have undergone definitional
        (DDL) changes since the previous use of the prepared statement. Also, if the value of
          <code class="ph codeph">search_path</code> changes from one use to the next, the statement will be
        re-parsed using the new search_path. (This latter behavior is new as of Greenplum 6.) These
        rules make use of a prepared statement semantically almost equivalent to re-submitting the
        same query text over and over, but with a performance benefit if no object definitions are
        changed, especially if the best plan remains the same across uses. An example of a case
        where the semantic equivalence is not perfect is that if the statement refers to a table by
        an unqualified name, and then a new table of the same name is created in a schema appearing
        earlier in the <code class="ph codeph">search_path</code>, no automatic re-parse will occur since no
        object used in the statement changed. However, if some other change forces a re-parse, the
        new table will be referenced in subsequent uses. </p>

      <p class="p">You can see all prepared statements available in the session by querying the
          <code class="ph codeph">pg_prepared_statements</code> system view.</p>

    </div>

    <div class="section" id="topic1__section6"><h2 class="title sectiontitle">Examples</h2>
      
      <p class="p">Create a prepared statement for an <code class="ph codeph">INSERT</code> statement, and then run
        it:</p>

      <pre class="pre codeblock"><code>PREPARE fooplan (int, text, bool, numeric) AS INSERT INTO 
foo VALUES($1, $2, $3, $4);
EXECUTE fooplan(1, 'Hunter Valley', 't', 200.00);</code></pre>
      <p class="p">Create a prepared statement for a <code class="ph codeph">SELECT</code> statement, and then run it.
        Note that the data type of the second parameter is not specified, so it is inferred from the
        context in which <code class="ph codeph">$2</code> is used:</p>

      <pre class="pre codeblock"><code>PREPARE usrrptplan (int) AS SELECT * FROM users u, logs l 
WHERE u.usrid=$1 AND u.usrid=l.usrid AND l.date = $2;
EXECUTE usrrptplan(1, current_date);</code></pre>
    </div>

    <div class="section" id="topic1__section7"><h2 class="title sectiontitle">Compatibility</h2>
      
      <p class="p">The SQL standard includes a <code class="ph codeph">PREPARE</code> statement, but it can only be used in
        embedded SQL, and it uses a different syntax.</p>

    </div>

    <div class="section" id="topic1__section8"><h2 class="title sectiontitle">See Also</h2>
      
      <p class="p"><a class="xref" href="EXECUTE.html#topic1">EXECUTE</a>,
            <a class="xref" href="DEALLOCATE.html#topic1">DEALLOCATE</a></p>

    </div>

  </div>

</body>
</html>