<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
  PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<topic id="topic1" xml:lang="en">
  <title id="if135496">Greenplum Database Data Types</title>
  <body>
    <p>Greenplum Database has a rich set of native data types available to users. Users may also
      define new data types using the <codeph>CREATE TYPE</codeph> command. This reference shows all
      of the built-in data types. In addition to the types listed here, there are also some
      internally used data types, such as <i>oid</i> (object identifier), but those are not
      documented in this guide. </p>
    <p>Optional modules in the <filepath>contrib</filepath> directory may also install new data
      types.  The <codeph>hstore</codeph> module, for example, introduces a new data type and
      associated functions for working with key-value pairs. See <xref
        href="../utility_guide/hstore.xml#topic_vcn_jkq_1bb"/>. The <codeph>citext</codeph> module 
        adds a case-insensitive text data type. See <xref href="../utility_guide/citext.xml"/>.</p>
    <p>The following data types are specified by SQL: <i>bit</i>, <i>bit varying</i>,
      <i>boolean</i>, <i>character varying, varchar</i>, <i>character, char</i>, <i>date</i>,
        <i>double precision</i>, <i>integer</i>, <i>interval</i>, <i>numeric</i>, <i>decimal</i>,
        <i>real</i>, <i>smallint</i>, <i>time</i> (with or without time zone), and <i>timestamp</i>
      (with or without time zone). </p>
    <p>Each data type has an external representation determined by its input and output functions.
      Many of the built-in types have obvious external formats. However, several types are either
      unique to PostgreSQL (and Greenplum Database), such as geometric paths, or have several
      possibilities for formats, such as the date and time types. Some of the input and output
      functions are not invertible. That is, the result of an output function may lose accuracy when
      compared to the original input.</p>
    <table id="if139202">
      <title>Greenplum Database Built-in Data Types</title>
      <tgroup cols="5">
        <colspec colnum="1" colname="col1" colwidth="95pt"/>
        <colspec colnum="2" colname="col2" colwidth="74pt"/>
        <colspec colnum="3" colname="col3" colwidth="46pt"/>
        <colspec colnum="4" colname="col4" colwidth="101pt"/>
        <colspec colnum="5" colname="col5" colwidth="133pt"/>
        <thead>
          <row>
            <entry colname="col1">Name</entry>
            <entry colname="col2">Alias</entry>
            <entry colname="col3">Size</entry>
            <entry colname="col4">Range</entry>
            <entry colname="col5">Description</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry colname="col1">bigint</entry>
            <entry colname="col2">int8</entry>
            <entry colname="col3">8 bytes</entry>
            <entry colname="col4">-922337203&#x200b;6854775808 to
              922337203&#x200b;6854775807</entry>
            <entry colname="col5">large range integer</entry>
          </row>
          <row>
            <entry colname="col1">bigserial</entry>
            <entry colname="col2">serial8</entry>
            <entry colname="col3">8 bytes</entry>
            <entry colname="col4">1 to 922337203&#x200b;6854775807</entry>
            <entry colname="col5">large autoincrementing integer</entry>
          </row>
          <row>
            <entry colname="col1">bit [ (n) ]<fn id="if139219">For variable length data types, if
                the data is greater than or equal to 127 bytes, the storage overhead is 4 bytes
                instead of 1.</fn></entry>
            <entry colname="col2"/>
            <entry colname="col3"><i>n</i> bits</entry>
            <entry colname="col4"><xref
                href="https://www.postgresql.org/docs/8.3/static/sql-syntax.html#SQL-SYNTAX-BIT-STRINGS"
                scope="external" format="html">bit string constant</xref></entry>
            <entry colname="col5">fixed-length bit string</entry>
          </row>
          <row>
            <entry colname="col1">bit varying [ (n) ]<xref href="#topic1/if139219" scope="local"
                type="fn" format="dita"/></entry>
            <entry colname="col2">varbit</entry>
            <entry colname="col3">actual number of bits</entry>
            <entry colname="col4"><xref
                href="https://www.postgresql.org/docs/8.3/static/sql-syntax.html#SQL-SYNTAX-BIT-STRINGS"
                scope="external" format="html">bit string constant</xref></entry>
            <entry colname="col5">variable-length bit string</entry>
          </row>
          <row>
            <entry colname="col1">boolean</entry>
            <entry colname="col2">bool</entry>
            <entry colname="col3">1 byte</entry>
            <entry colname="col4">true/false, t/f, yes/no, y/n, 1/0</entry>
            <entry colname="col5">logical boolean (true/false)</entry>
          </row>
          <row>
            <entry colname="col1">box</entry>
            <entry colname="col2"/>
            <entry colname="col3">32 bytes</entry>
            <entry colname="col4">((x1,y1),(x2,y2))</entry>
            <entry colname="col5">rectangular box in the plane - not allowed in distribution key
              columns.</entry>
          </row>
          <row>
            <entry colname="col1">bytea<xref href="#topic1/if139219" scope="local" type="fn"
                format="dita"/></entry>
            <entry colname="col2"/>
            <entry colname="col3">1 byte + <i>binary string</i></entry>
            <entry colname="col4">sequence of <xref
                href="https://www.postgresql.org/docs/8.3/static/datatype-binary.html#DATATYPE-BINARY-SQLESC"
                scope="external" format="html"><ph>octets</ph></xref></entry>
            <entry colname="col5">variable-length binary string</entry>
          </row>
          <row>
            <entry colname="col1">character [ (n) ]<xref href="#topic1/if139219" scope="local"
                type="fn" format="dita"/></entry>
            <entry colname="col2">char [ (n) ]</entry>
            <entry colname="col3">1 byte + <i>n</i></entry>
            <entry colname="col4">strings up to <i>n</i> characters in length</entry>
            <entry colname="col5">fixed-length, blank padded</entry>
          </row>
          <row>
            <entry colname="col1">character varying [ (n) ]<xref href="#topic1/if139219"
                scope="local" type="fn" format="dita"/></entry>
            <entry colname="col2">varchar [ (n) ] </entry>
            <entry colname="col3">1 byte + <i>string size</i></entry>
            <entry colname="col4">strings up to <i>n</i> characters in length</entry>
            <entry colname="col5">variable-length with limit</entry>
          </row>
          <row>
            <entry colname="col1">cidr</entry>
            <entry colname="col2"/>
            <entry colname="col3">12 or 24 bytes</entry>
            <entry colname="col4"/>
            <entry colname="col5">IPv4 and IPv6 networks</entry>
          </row>
          <row>
            <entry colname="col1">circle</entry>
            <entry colname="col2"/>
            <entry colname="col3">24 bytes</entry>
            <entry colname="col4">&lt;(x,y),r&gt; (center and radius)</entry>
            <entry colname="col5">circle in the plane - not allowed in distribution key
              columns.</entry>
          </row>
          <row>
            <entry colname="col1">date</entry>
            <entry colname="col2"/>
            <entry colname="col3">4 bytes</entry>
            <entry colname="col4">4713 BC - 294,277 AD </entry>
            <entry colname="col5">calendar date (year, month, day)</entry>
          </row>
          <row>
            <entry colname="col1">decimal [ (p, s) ]<xref href="#topic1/if139219" scope="local"
                type="fn" format="dita"/></entry>
            <entry colname="col2">numeric [ (p, s) ]</entry>
            <entry colname="col3">variable</entry>
            <entry colname="col4">no limit</entry>
            <entry colname="col5">user-specified precision, exact</entry>
          </row>
          <row>
            <entry colname="col1">double precision</entry>
            <entry colname="col2">float8<p>float</p></entry>
            <entry colname="col3">8 bytes</entry>
            <entry colname="col4">15 decimal digits precision</entry>
            <entry colname="col5">variable-precision, inexact</entry>
          </row>
          <row>
            <entry colname="col1">inet</entry>
            <entry colname="col2"/>
            <entry colname="col3">12 or 24 bytes</entry>
            <entry colname="col4"/>
            <entry colname="col5">IPv4 and IPv6 hosts and networks</entry>
          </row>
          <row>
            <entry colname="col1">integer</entry>
            <entry colname="col2">int, int4</entry>
            <entry colname="col3">4 bytes</entry>
            <entry colname="col4">-2147483648 to +2147483647</entry>
            <entry colname="col5">usual choice for integer</entry>
          </row>
          <row>
            <entry colname="col1">interval [ (p) ]</entry>
            <entry colname="col2"/>
            <entry colname="col3">12 bytes</entry>
            <entry colname="col4">-178000000 years - 178000000 years</entry>
            <entry colname="col5">time span</entry>
          </row>
          <row>
            <entry colname="col1">json</entry>
            <entry colname="col2"/>
            <entry colname="col3">1 byte + json size</entry>
            <entry colname="col4">json of any length</entry>
            <entry colname="col5">variable unlimited length</entry>
          </row>
          <row>
            <entry colname="col1">lseg</entry>
            <entry colname="col2"/>
            <entry colname="col3">32 bytes</entry>
            <entry colname="col4">((x1,y1),(x2,y2))</entry>
            <entry colname="col5">line segment in the plane - not allowed in distribution key
              columns.</entry>
          </row>
          <row>
            <entry colname="col1">macaddr</entry>
            <entry colname="col2"/>
            <entry colname="col3">6 bytes</entry>
            <entry colname="col4"/>
            <entry colname="col5">MAC addresses</entry>
          </row>
          <row>
            <entry colname="col1">money</entry>
            <entry colname="col2"/>
            <entry colname="col3">8 bytes</entry>
            <entry colname="col4">-92233720368547758.08 to +92233720368547758.07</entry>
            <entry colname="col5">currency amount</entry>
          </row>
          <row>
            <entry colname="col1">path<xref href="#topic1/if139219" scope="local" type="fn"
                format="dita"/></entry>
            <entry colname="col2"/>
            <entry colname="col3">16+16n bytes</entry>
            <entry colname="col4">[(x1,y1),...]</entry>
            <entry colname="col5">geometric path in the plane - not allowed in distribution key
              columns.</entry>
          </row>
          <row>
            <entry colname="col1">point</entry>
            <entry colname="col2"/>
            <entry colname="col3">16 bytes</entry>
            <entry colname="col4">(x,y)</entry>
            <entry colname="col5">geometric point in the plane - not allowed in distribution key
              columns.</entry>
          </row>
          <row>
            <entry colname="col1">polygon</entry>
            <entry colname="col2"/>
            <entry colname="col3">40+16n bytes</entry>
            <entry colname="col4">((x1,y1),...)</entry>
            <entry colname="col5">closed geometric path in the plane - not allowed in distribution
              key columns.</entry>
          </row>
          <row>
            <entry colname="col1">real</entry>
            <entry colname="col2">float4</entry>
            <entry colname="col3">4 bytes</entry>
            <entry colname="col4">6 decimal digits precision</entry>
            <entry colname="col5">variable-precision, inexact</entry>
          </row>
          <row>
            <entry colname="col1">serial</entry>
            <entry colname="col2">serial4</entry>
            <entry colname="col3">4 bytes</entry>
            <entry colname="col4">1 to 2147483647</entry>
            <entry colname="col5">autoincrementing integer</entry>
          </row>
          <row>
            <entry colname="col1">smallint</entry>
            <entry colname="col2">int2</entry>
            <entry colname="col3">2 bytes</entry>
            <entry colname="col4">-32768 to +32767</entry>
            <entry colname="col5">small range integer</entry>
          </row>
          <row>
            <entry colname="col1">text<xref href="#topic1/if139219" scope="local" type="fn"
                format="dita"/></entry>
            <entry colname="col2"/>
            <entry colname="col3">1 byte + <i>string size</i></entry>
            <entry colname="col4">strings of any length</entry>
            <entry colname="col5">variable unlimited length</entry>
          </row>
          <row>
            <entry colname="col1">time [ (p) ] [ without time zone ]</entry>
            <entry colname="col2"/>
            <entry colname="col3">8 bytes</entry>
            <entry colname="col4">00:00:00[.000000] - 24:00:00[.000000]</entry>
            <entry colname="col5">time of day only</entry>
          </row>
          <row>
            <entry colname="col1">time [ (p) ] with time zone</entry>
            <entry colname="col2">timetz</entry>
            <entry colname="col3">12 bytes</entry>
            <entry colname="col4">00:00:00+1359 - 24:00:00-1359</entry>
            <entry colname="col5">time of day only, with time zone</entry>
          </row>
          <row>
            <entry colname="col1">timestamp [ (p) ] [ without time zone ] </entry>
            <entry colname="col2"/>
            <entry colname="col3">8 bytes</entry>
            <entry colname="col4">4713 BC - 294,277 AD </entry>
            <entry colname="col5">both date and time</entry>
          </row>
          <row>
            <entry colname="col1">timestamp [ (p) ] with time zone</entry>
            <entry colname="col2">timestamptz</entry>
            <entry colname="col3">8 bytes</entry>
            <entry colname="col4">4713 BC - 294,277 AD </entry>
            <entry colname="col5">both date and time, with time zone</entry>
          </row>
          <row>
            <entry colname="col1">uuid</entry>
            <entry colname="col2"/>
            <entry colname="col3">32 bytes</entry>
            <entry colname="col4"/>
            <entry colname="col5">Universally Unique Identifiers according to RFC 4122, ISO/IEC
              9834-8:2005</entry>
          </row>
          <row>
            <entry colname="col1">xml<xref href="#topic1/if139219" scope="local" type="fn"
                format="dita"/></entry>
            <entry colname="col2"/>
            <entry colname="col3">1 byte + <i>xml size</i></entry>
            <entry colname="col4">xml of any length</entry>
            <entry colname="col5">variable unlimited length</entry>
          </row>
          <row>
            <entry colname="col1">txid_snapshot</entry>
            <entry colname="col2"/>
            <entry colname="col3"/>
            <entry colname="col4"/>
            <entry colname="col5">user-level transaction ID snapshot</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <section>
      <title>Pseudo-Types</title>
      <p>Greenplum Database supports special-purpose data type entries that are collectively called
          <i>pseudo-types</i>. A pseudo-type cannot be used as a column data type, but it can be
        used to declare a function's argument or result type. Each of the available pseudo-types is
        useful in situations where a function's behavior does not correspond to simply taking or
        returning a value of a specific SQL data type.</p>
      <p>Functions coded in procedural languages can use pseudo-types only as allowed by their
        implementation languages. The procedural languages all forbid use of a pseudo-type as an
        argument type, and allow only <i>void</i> and <i>record</i> as a result type. </p>
      <p>A function with the pseudo-type <i>record</i> as a return data type returns an unspecified
        row type. The <i>record</i> represents an array of possibly-anonymous composite types. Since
        composite datums carry their own type identification, no extra knowledge is needed at the
        array level.</p>
      <p>The pseudo-type <i>void</i> indicates that a function returns no value.</p>
      <note>Greenplum Database does not support triggers and the pseudo-type <i>trigger</i>.</note>
      <p>The types <i>anyelement</i>, <i>anyarray</i>, <i>anynonarray</i>, and <i>anyenum</i> are
        pseudo-types called polymorphic types. Some procedural languages also support polymorphic
        functions using the types <i>anyarray</i>, <i>anyelement</i>, <i>anyenum</i>, and
          <i>anynonarray</i>.</p>
      <p>The pseudo-type <i>anytable</i> is a Greenplum Database type that specifies a table
        expression—an expression that computes a table. Greenplum Database allows this type only as
        an argument to a user-defined function. See <xref href="#topic1/topic22" format="dita"/> for
        more about the <i>anytable</i> pseudo-type.</p>
      <p>For more information about pseudo-types, see the Postgres documentation about <xref
          href="https://www.postgresql.org/docs/8.3/static/datatype-pseudo.html" format="html"
          scope="external">Pseudo-Types</xref>.</p>
    </section>
    <section>
      <title>Polymorphic Types</title>
      <p>Four pseudo-types of special interest are <i>anyelement</i>, <i>anyarray</i>,
          <i>anynonarray</i>, and <i>anyenum</i>, which are collectively called <i>polymorphic</i>
        types. Any function declared using these types is said to be a polymorphic function. A
        polymorphic function can operate on many different data types, with the specific data types
        being determined by the data types actually passed to it at runtime.</p>
      <p>Polymorphic arguments and results are tied to each other and are resolved to a specific
        data type when a query calling a polymorphic function is parsed. Each position (either
        argument or return value) declared as <i>anyelement</i> is allowed to have any specific
        actual data type, but in any given call they must all be the same actual type. Each position
        declared as <i>anyarray</i> can have any array data type, but similarly they must all be the
        same type. If there are positions declared <i>anyarray</i> and others declared
          <i>anyelement</i>, the actual array type in the <i>anyarray</i> positions must be an array
        whose elements are the same type appearing in the <i>anyelement</i> positions.
          <i>anynonarray</i> is treated exactly the same as <i>anyelement</i>, but adds the
        additional constraint that the actual type must not be an array type. <i>anyenum</i> is
        treated exactly the same as <i>anyelement</i>, but adds the additional constraint that the
        actual type must be an <codeph>enum</codeph> type. </p>
      <p>When more than one argument position is declared with a polymorphic type, the net effect is
        that only certain combinations of actual argument types are allowed. For example, a function
        declared as <codeph>equal(<i>anyelement</i>, <i>anyelement</i>)</codeph> takes any two input
        values, so long as they are of the same data type.</p>
      <p>When the return value of a function is declared as a polymorphic type, there must be at
        least one argument position that is also polymorphic, and the actual data type supplied as
        the argument determines the actual result type for that call. For example, if there were not
        already an array subscripting mechanism, one could define a function that implements
        subscripting as <codeph>subscript(<i>anyarray</i>, integer) returns
          <i>anyelement</i></codeph>. This declaration constrains the actual first argument to be an
        array type, and allows the parser to infer the correct result type from the actual first
        argument's type. Another example is that a function declared as
            <codeph>myfunc(<i>anyarray</i>) returns <i>anyenum</i></codeph> will only accept arrays
        of <codeph>enum</codeph> types.</p>
      <p>Note that <i>anynonarray</i> and <i>anyenum</i> do not represent separate type variables;
        they are the same type as <i>anyelement</i>, just with an additional constraint. For
        example, declaring a function as <codeph>myfunc(<i>anyelement</i>, <i>anyenum</i>)</codeph>
        is equivalent to declaring it as <codeph>myfunc(<i>anyenum</i>, <i>anyenum</i>)</codeph>:
        both actual arguments must be the same <codeph>enum</codeph> type.</p>
      <p>A variadic function (one taking a variable number of arguments) is polymorphic when its 
        last parameter is declared as <codeph>VARIADIC <i>anyarray</i></codeph>. For purposes of
        argument matching and determining the actual result type, such a function behaves the 
        same as if you had declared the appropriate number of <i>anynonarray</i> parameters.</p>
      <p>For more information about polymorphic types, see the Postgres documentation about <xref
          href="https://www.postgresql.org/docs/8.3/static/xfunc-c.html#AEN41553" format="html"
          scope="external">Polymorphic Arguments and Return Types</xref>.</p>
    </section>
    <section id="topic22" xml:lang="en">
      <title>Table Value Expressions</title>
      <p>The <i>anytable</i> pseudo-type declares a function argument that is a table value
        expression. The notation for a table value expression is a <codeph>SELECT</codeph> statement
        enclosed in a <codeph>TABLE()</codeph> function. You can specify a distribution policy for
        the table by adding <codeph>SCATTER RANDOMLY</codeph>, or a <codeph>SCATTER BY</codeph>
        clause with a column list to specify the distribution key. </p>
      <p>The <codeph>SELECT</codeph> statement is executed when the function is called and the
        result rows are distributed to segments so that each segment executes the function with a
        subset of the result table.</p>
      <p>For example, this table expression selects three columns from a table named
          <codeph>customer</codeph> and sets the distribution key to the first column:</p>
      <codeblock>TABLE(SELECT cust_key, name, address FROM customer SCATTER BY 1)</codeblock>
      <p>The <codeph>SELECT</codeph> statement may include joins on multiple base tables,
          <codeph>WHERE</codeph> clauses, aggregates, and any other valid query syntax.</p>
      <p>The <i>anytable</i> type is only permitted in functions implemented in the C or C++
        languages. The body of the function can access the table using the Greenplum Database Server
        Programming Interface (SPI) or the Greenplum Partner Connector (GPPC) API. </p>
      <p otherprops="pivotal">The <i>anytable</i> type is used in some user-defined functions in the
        Pivotal GPText API. The following GPText example uses the <codeph>TABLE</codeph> function
        with the <codeph>SCATTER BY</codeph> clause in the GPText function
          <codeph>gptext.index()</codeph> to populate the index
          <codeph>mydb.mytest.articles</codeph> with data from the messages
        table:<codeblock>SELECT * FROM gptext.index(TABLE(SELECT * FROM mytest.messages 
          SCATTER BY distrib_id), 'mydb.mytest.messages');
        </codeblock></p>
      <p otherprops="pivotal">For information about the function <codeph>gptext.index()</codeph>,
        see the Pivotal GPText documentation.</p>
    </section>
    <section id="text-search-types">
      <title>Text Search Data Types</title>
      <p>Greenplum Database provides two data types that are designed to support
        full text search, which is the activity of searching through a
        collection of natural-language <i>documents</i> to locate those that
        best match a <i>query</i>. The <codeph>tsvector</codeph> type represents
        a document in a form optimized for text search; the
          <codeph>tsquery</codeph> type similarly represents a text query. <xref
          href="../admin_guide/textsearch/full-text-search.xml"/> provides a
        detailed explanation of this facility, and <xref
          href="function-summary.xml#topic_vpj_ss1_lfb"/> summarizes the related
        functions and operators.</p>
      <p>The <codeph>tsvector</codeph> and <codeph>tsquery</codeph> types cannot be part of the
        distribution key of a Greenplum Database table.</p>
      <sectiondiv>
        <p><b>tsvector</b></p>
        <p>A <codeph>tsvector</codeph> value is a sorted list of distinct
            <i>lexemes</i>, which are words that have been <i>normalized</i> to
          merge different variants of the same word (see <xref
            href="../admin_guide/textsearch/full-text-search.xml"/> for
          details). Sorting and duplicate-elimination are done automatically
          during input, as shown in this example:</p>
        <codeblock>SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;
                      tsvector
----------------------------------------------------
 'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'</codeblock>
        <p>To represent lexemes containing whitespace or punctuation, surround them with quotes:</p>
        <codeblock>SELECT $$the lexeme '    ' contains spaces$$::tsvector;
                 tsvector                  
-------------------------------------------
 '    ' 'contains' 'lexeme' 'spaces' 'the'</codeblock>
        <p>(We use dollar-quoted string literals in this example and the next one to avoid the
          confusion of having to double quote marks within the literals.) Embedded quotes and
          backslashes must be doubled:</p>
        <codeblock>SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;
                    tsvector                    
------------------------------------------------
 'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'</codeblock>
        <p>Optionally, integer <i>positions</i> can be attached to lexemes:</p>
        <codeblock>SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11 rat:12'::tsvector;
                                  tsvector
-------------------------------------------------------------------------------
 'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12 'sat':4</codeblock>
        <p>A position normally indicates the source word's location in the document. Positional
          information can be used for <i>proximity ranking</i>. Position values can range from 1 to
          16383; larger numbers are silently set to 16383. Duplicate positions for the same lexeme
          are discarded.</p>
        <p>Lexemes that have positions can further be labeled with a <i>weight</i>, which can be
            <codeph>A</codeph>, <codeph>B</codeph>, <codeph>C</codeph>, or <codeph>D</codeph>.
            <codeph>D</codeph> is the default and hence is not shown on output:</p>
        <codeblock>SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;
          tsvector          
----------------------------
 'a':1A 'cat':5 'fat':2B,4C</codeblock>
        <p>Weights are typically used to reflect document structure, for example by marking title
          words differently from body words. Text search ranking functions can assign different
          priorities to the different weight markers.</p>
        <p>It is important to understand that the <codeph>tsvector</codeph> type itself does not
          perform any normalization; it assumes the words it is given are normalized appropriately
          for the application. For example,</p>
        <codeblock>select 'The Fat Rats'::tsvector;
      tsvector      
--------------------
 'Fat' 'Rats' 'The'</codeblock>
        <p>For most English-text-searching applications the above words would be considered
          non-normalized, but tsvector doesn't care. Raw document text should usually be passed
          through <codeph>to_tsvector</codeph> to normalize the words appropriately for
          searching:</p>
        <codeblock>SELECT to_tsvector('english', 'The Fat Rats');
   to_tsvector   
-----------------
 'fat':2 'rat':3</codeblock>
      </sectiondiv>
    </section>
    <section>
      <p><b>tsquery</b></p>
      <p>A <codeph>tsquery</codeph> value stores lexemes that are to be searched for, and combines
        them honoring the Boolean operators <codeph>&amp;</codeph> (AND), <codeph>|</codeph> (OR),
        and <codeph>!</codeph> (NOT). Parentheses can be used to enforce grouping of the
        operators:</p>
      <codeblock>SELECT 'fat &amp; rat'::tsquery;
    tsquery    
---------------
 'fat' &amp; 'rat'

SELECT 'fat &amp; (rat | cat)'::tsquery;
          tsquery          
---------------------------
 'fat' &amp; ( 'rat' | 'cat' )

SELECT 'fat &amp; rat &amp; ! cat'::tsquery;
        tsquery         
------------------------
 'fat' &amp; 'rat' &amp; !'cat'</codeblock>
      <p>In the absence of parentheses, <codeph>!</codeph> (NOT) binds most tightly, and
          <codeph>&amp;</codeph> (AND) binds more tightly than <codeph>|</codeph> (OR).</p>
      <p>Optionally, lexemes in a <codeph>tsquery</codeph> can be labeled with one or more weight
        letters, which restricts them to match only <codeph>tsvector</codeph> lexemes with matching
        weights:</p>
      <codeblock>SELECT 'fat:ab &amp; cat'::tsquery;
    tsquery
------------------
 'fat':AB &amp; 'cat'</codeblock>
      <p>Also, lexemes in a <codeph>tsquery</codeph> can be labeled with * to specify prefix
        matching:</p>
      <codeblock>SELECT 'super:*'::tsquery;
  tsquery  
-----------
 'super':*</codeblock>
      <p>This query will match any word in a <codeph>tsvector</codeph> that begins with "super".
        Note that prefixes are first processed by text search configurations, which means this
        comparison returns true:</p>
      <codeblock>SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );
 ?column? 
----------
 t
(1 row)</codeblock>
      <p>because <codeph>postgres</codeph> gets stemmed to <codeph>postgr</codeph>:</p>
      <codeblock>SELECT to_tsquery('postgres:*');
 to_tsquery 
------------
 'postgr':*
(1 row)</codeblock>
      <p>which then matches <codeph>postgraduate</codeph>.</p>
      <p>Quoting rules for lexemes are the same as described previously for lexemes in
          <codeph>tsvector</codeph>; and, as with <codeph>tsvector</codeph>, any required
        normalization of words must be done before converting to the <codeph>tsquery</codeph> type.
        The <codeph>to_tsquery</codeph> function is convenient for performing such
        normalization:</p>
      <codeblock>SELECT to_tsquery('Fat:ab &amp; Cats');
    to_tsquery    
------------------
 'fat':AB &amp; 'cat'</codeblock>
    </section>
  </body> 
</topic>
