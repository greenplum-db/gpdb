<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta name="copyright" content="(C) Copyright 2022" />
<meta name="DC.rights.owner" content="(C) Copyright 2022" />
<meta name="generator" content="DITA-OT" /><meta name="DC.type" content="topic" />
<meta name="DC.title" content="Pseudo-Types" />
<meta name="DC.relation" scheme="URI" content="data_types.html" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="topic_vmf_z4c_qfb" />
<link rel="stylesheet" type="text/css" href="commonltr.css" />
<title>Pseudo-Types</title>
</head>
<body>

  <div class="nested0" aria-labelledby="ariaid-title1" id="topic_vmf_z4c_qfb">
    <h1 class="title topictitle1" id="ariaid-title1">Pseudo-Types</h1>

    <div class="body">
      <p class="p">Greenplum Database supports special-purpose data type entries that are collectively called
          <em class="ph i">pseudo-types</em>. A pseudo-type cannot be used as a column data type, but it can be
        used to declare a function's argument or result type. Each of the available pseudo-types is
        useful in situations where a function's behavior does not correspond to simply taking or
        returning a value of a specific SQL data type.</p>

      <p class="p">Functions coded in procedural languages can use pseudo-types only as allowed by their
        implementation languages. The procedural languages all forbid use of a pseudo-type as an
        argument type, and allow only <em class="ph i">void</em> and <em class="ph i">record</em> as a result type. </p>

      <p class="p">A function with the pseudo-type <em class="ph i">record</em> as a return data type returns an unspecified
        row type. The <em class="ph i">record</em> represents an array of possibly-anonymous composite types. Since
        composite datums carry their own type identification, no extra knowledge is needed at the
        array level.</p>

      <p class="p">The pseudo-type <em class="ph i">void</em> indicates that a function returns no value.</p>

      <div class="note"><span class="notetitle">Note:</span> Greenplum Database does not support triggers and the pseudo-type <em class="ph i">trigger</em>.</div>

      <p class="p">The types <em class="ph i">anyelement</em>, <em class="ph i">anyarray</em>, <em class="ph i">anynonarray</em>, and <em class="ph i">anyenum</em> are
        pseudo-types called polymorphic types. Some procedural languages also support polymorphic
        functions using the types <em class="ph i">anyarray</em>, <em class="ph i">anyelement</em>, <em class="ph i">anyenum</em>, and
          <em class="ph i">anynonarray</em>.</p>

      <p class="p">The pseudo-type <em class="ph i">anytable</em> is a Greenplum Database type that specifies a table
        expressionâ€”an expression that computes a table. Greenplum Database allows this type only as
        an argument to a user-defined function. See <a class="xref" href="#topic_ig2_1pc_qfb">Table Value Expressions</a>
        for more about the <em class="ph i">anytable</em> pseudo-type.</p>

      <p class="p">For more information about pseudo-types, see the PostgreSQL documentation about <a class="xref" href="https://www.postgresql.org/docs/9.4/datatype-pseudo.html" target="_blank">Pseudo-Types</a>.</p>

    </div>

    <div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="data_types.html">Data Types</a></div>
</div>
</div><div class="topic nested1" aria-labelledby="ariaid-title2" id="topic_dbn_bpc_qfb">
      <h2 class="title topictitle2" id="ariaid-title2">Polymorphic Types</h2>

      <div class="body">
        <p class="p">Four pseudo-types of special interest are <em class="ph i">anyelement</em>, <em class="ph i">anyarray</em>,
            <em class="ph i">anynonarray</em>, and <em class="ph i">anyenum</em>, which are collectively called <em class="ph i">polymorphic</em>
          types. Any function declared using these types is said to be a polymorphic function. A
          polymorphic function can operate on many different data types, with the specific data
          types being determined by the data types actually passed to it at runtime.</p>

        <p class="p">Polymorphic arguments and results are tied to each other and are resolved to a specific
          data type when a query calling a polymorphic function is parsed. Each position (either
          argument or return value) declared as <em class="ph i">anyelement</em> is allowed to have any specific
          actual data type, but in any given call they must all be the same actual type. Each
          position declared as <em class="ph i">anyarray</em> can have any array data type, but similarly they must
          all be the same type. If there are positions declared <em class="ph i">anyarray</em> and others declared
            <em class="ph i">anyelement</em>, the actual array type in the <em class="ph i">anyarray</em> positions must be an
          array whose elements are the same type appearing in the <em class="ph i">anyelement</em> positions.
            <em class="ph i">anynonarray</em> is treated exactly the same as <em class="ph i">anyelement</em>, but adds the
          additional constraint that the actual type must not be an array type. <em class="ph i">anyenum</em> is
          treated exactly the same as <em class="ph i">anyelement</em>, but adds the additional constraint that the
          actual type must be an <code class="ph codeph">enum</code> type. </p>

        <p class="p">When more than one argument position is declared with a polymorphic type, the net effect
          is that only certain combinations of actual argument types are allowed. For example, a
          function declared as <code class="ph codeph">equal(<em class="ph i">anyelement</em>, <em class="ph i">anyelement</em>)</code> takes
          any two input values, so long as they are of the same data type.</p>

        <p class="p">When the return value of a function is declared as a polymorphic type, there must be at
          least one argument position that is also polymorphic, and the actual data type supplied as
          the argument determines the actual result type for that call. For example, if there were
          not already an array subscripting mechanism, one could define a function that implements
          subscripting as <code class="ph codeph">subscript(<em class="ph i">anyarray</em>, integer) returns
            <em class="ph i">anyelement</em></code>. This declaration constrains the actual first argument to be
          an array type, and allows the parser to infer the correct result type from the actual
          first argument's type. Another example is that a function declared as
              <code class="ph codeph">myfunc(<em class="ph i">anyarray</em>) returns <em class="ph i">anyenum</em></code> will only accept
          arrays of <code class="ph codeph">enum</code> types.</p>

        <p class="p">Note that <em class="ph i">anynonarray</em> and <em class="ph i">anyenum</em> do not represent separate type variables;
          they are the same type as <em class="ph i">anyelement</em>, just with an additional constraint. For
          example, declaring a function as <code class="ph codeph">myfunc(<em class="ph i">anyelement</em>,
            <em class="ph i">anyenum</em>)</code> is equivalent to declaring it as <code class="ph codeph">myfunc(<em class="ph i">anyenum</em>,
              <em class="ph i">anyenum</em>)</code>: both actual arguments must be the same <code class="ph codeph">enum</code>
          type.</p>

        <p class="p">A variadic function (one taking a variable number of arguments) is polymorphic when its
          last parameter is declared as <code class="ph codeph">VARIADIC <em class="ph i">anyarray</em></code>. For purposes of
          argument matching and determining the actual result type, such a function behaves the same
          as if you had declared the appropriate number of <em class="ph i">anynonarray</em> parameters.</p>

        <p class="p">For more information about polymorphic types, see the PostgreSQL documentation about <a class="xref" href="https://www.postgresql.org/docs/9.4/xfunc-c.html#AEN56822" target="_blank">Polymorphic Arguments and Return Types</a>.</p>

      </div>

    </div>

    <div class="topic nested1" aria-labelledby="ariaid-title3" id="topic_ig2_1pc_qfb">
      <h2 class="title topictitle2" id="ariaid-title3">Table Value Expressions</h2>

      <div class="body">
        <p class="p">The <em class="ph i">anytable</em> pseudo-type declares a function argument that is a table value
          expression. The notation for a table value expression is a <code class="ph codeph">SELECT</code>
          statement enclosed in a <code class="ph codeph">TABLE()</code> function. You can specify a distribution
          policy for the table by adding <code class="ph codeph">SCATTER RANDOMLY</code>, or a <code class="ph codeph">SCATTER
            BY</code> clause with a column list to specify the distribution key. </p>

        <p class="p">The <code class="ph codeph">SELECT</code> statement is run when the function is called and the
          result rows are distributed to segments so that each segment runs the function with a
          subset of the result table.</p>

        <p class="p">For example, this table expression selects three columns from a table named
            <code class="ph codeph">customer</code> and sets the distribution key to the first column:</p>

        <pre class="pre codeblock"><code>TABLE(SELECT cust_key, name, address FROM customer SCATTER BY 1)</code></pre>
        <p class="p">The <code class="ph codeph">SELECT</code> statement may include joins on multiple base tables,
            <code class="ph codeph">WHERE</code> clauses, aggregates, and any other valid query syntax.</p>

        <p class="p">The <em class="ph i">anytable</em> type is only permitted in functions implemented in the C or C++
          languages. The body of the function can access the table using the Greenplum Database
          Server Programming Interface (SPI) or the Greenplum Partner Connector (GPPC) API. </p>

        <div class="p">The <em class="ph i">anytable</em> type is used in some user-defined functions in
          the Tanzu Greenplum Text API. The following GPText example uses the <code class="ph codeph">TABLE</code>
          function with the <code class="ph codeph">SCATTER BY</code> clause in the GPText function
            <code class="ph codeph">gptext.index()</code> to populate the index
            <code class="ph codeph">mydb.mytest.articles</code> with data from the messages
          table:<pre class="pre codeblock"><code>SELECT * FROM gptext.index(TABLE(SELECT * FROM mytest.messages 
          SCATTER BY distrib_id), 'mydb.mytest.messages');
        </code></pre></div>

        <p class="p">For information about the function <code class="ph codeph">gptext.index()</code>,
          see the Tanzu Greenplum Text documentation.</p>

      </div>

    </div>

  </div>

</body>
</html>