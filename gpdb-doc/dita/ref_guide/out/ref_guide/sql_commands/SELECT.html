<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta name="copyright" content="(C) Copyright 2022" />
<meta name="DC.rights.owner" content="(C) Copyright 2022" />
<meta name="generator" content="DITA-OT" /><meta name="DC.type" content="topic" />
<meta name="DC.title" content="SELECT" />
<meta name="DC.relation" scheme="URI" content="../sql_commands/sql_ref.html" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="topic1" />
<link rel="stylesheet" type="text/css" href="../commonltr.css" />
<title>SELECT</title>
</head>
<body id="topic1">

  <h1 class="title topictitle1" id="topic1__eg20941">SELECT</h1>

  <div class="body">
    <p class="p" id="topic1__sql_command_desc">Retrieves rows from a table or view.</p>

    <div class="section" id="topic1__section2"><h2 class="title sectiontitle">Synopsis</h2>
      
      <pre class="pre codeblock" id="topic1__sql_command_synopsis"><code>[ WITH [ RECURSIVE ] &lt;with_query&gt; [, ...] ]
SELECT [ALL | DISTINCT [ON (&lt;expression&gt; [, ...])]]
  * | &lt;expression &gt;[[AS] &lt;output_name&gt;] [, ...]
  [FROM &lt;from_item&gt; [, ...]]
  [WHERE &lt;condition&gt;]
  [GROUP BY &lt;grouping_element&gt; [, ...]]
  [HAVING &lt;condition&gt; [, ...]]
  [WINDOW &lt;window_name&gt; AS (&lt;window_definition&gt;) [, ...] ]
  [{UNION | INTERSECT | EXCEPT} [ALL | DISTINCT] &lt;select&gt;]
  [ORDER BY &lt;expression&gt; [ASC | DESC | USING &lt;operator&gt;] [NULLS {FIRST | LAST}] [, ...]]
  [LIMIT {&lt;count&gt; | ALL}]
  [OFFSET &lt;start&gt; [ ROW | ROWS ] ]
  [FETCH { FIRST | NEXT } [ &lt;count&gt; ] { ROW | ROWS } ONLY]
  [FOR<sup class="ph sup">2</sup> {UPDATE | NO KEY UPDATE | SHARE | KEY SHARE} [OF &lt;table_name&gt; [, ...]] [NOWAIT] [...]]

TABLE { [ ONLY ] &lt;table_name&gt; [ * ] | &lt;with_query_name&gt; }
</code></pre>
      <p class="p">where <var class="keyword varname">with_query:</var> is:</p>

      <pre class="pre codeblock"><code>  &lt;with_query_name&gt; [( &lt;column_name&gt; [, ...] )] AS ( &lt;select&gt; | &lt;values&gt; | &lt;insert&gt; | &lt;update&gt; | <var class="keyword varname">delete</var> )</code></pre>
      <p class="p">where <var class="keyword varname">from_item</var> can be one of:</p>

      <pre class="pre codeblock"><code>[ONLY] &lt;table_name&gt; [ * ] [ [ AS ] &lt;alias&gt; [ ( &lt;column_alias&gt; [, ...] ) ] ]
( &lt;select&gt; ) [ AS ] &lt;alias&gt; [( &lt;column_alias&gt; [, ...] ) ]<var class="keyword varname">
with_query_name</var> [ [ AS ] &lt;alias&gt; [ ( &lt;column_alias&gt; [, ...] ) ] ]
&lt;function_name&gt; ( [ &lt;argument&gt; [, ...] ] )
            [ WITH ORDINALITY ] [ [ AS ] &lt;alias&gt; [ ( &lt;column_alias&gt; [, ...] ) ] ]
&lt;function_name&gt; ( [ &lt;argument&gt; [, ...] ] ) [ AS ] &lt;alias&gt; ( &lt;column_definition&gt; [, ...] )
&lt;function_name&gt; ( [ &lt;argument&gt; [, ...] ] ) AS ( &lt;column_definition&gt; [, ...] )
ROWS FROM( function_name ( [ argument [, ...] ] ) [ AS ( column_definition [, ...] ) ] [, ...] )
            [ WITH ORDINALITY ] [ [ AS ] &lt;alias&gt; [ ( &lt;column_alias&gt; [, ...] ) ] ]
&lt;from_item&gt; [ NATURAL ] &lt;join_type&gt; &lt;from_item&gt;
          [ ON &lt;join_condition&gt; | USING ( &lt;join_column&gt; [, ...] ) ]</code></pre>
      <p class="p">where <var class="keyword varname">grouping_element</var> can be one of:</p>

      <pre class="pre codeblock"><code>  ()
  &lt;expression&gt;
  ROLLUP (&lt;expression&gt; [,...])
  CUBE (&lt;expression&gt; [,...])
  GROUPING SETS ((&lt;grouping_element&gt; [, ...]))</code></pre>
      <p class="p">where <var class="keyword varname">window_definition</var> is:</p>

      <pre class="pre codeblock"><code>  [&lt;existing_window_name&gt;]
  [PARTITION BY &lt;expression&gt; [, ...]]
  [ORDER BY &lt;expression&gt; [ASC | DESC | USING &lt;operator&gt;] 
    [NULLS {FIRST | LAST}] [, ...]]
  [{ RANGE | ROWS} &lt;frame_start&gt; 
     | {RANGE | ROWS} BETWEEN &lt;frame_start&gt; AND &lt;frame_end&gt;
</code></pre>
      <div class="p">where <var class="keyword varname">frame_start</var> and <var class="keyword varname">frame_end</var> can be one of:
        <pre class="pre codeblock"><code>  UNBOUNDED PRECEDING
  &lt;value&gt; PRECEDING
  CURRENT ROW
  &lt;value&gt; FOLLOWING
  UNBOUNDED FOLLOWING
</code></pre></div>

      <p class="p">
        <sup class="ph sup">2</sup>When a locking clause is specified (the <code class="ph codeph">FOR</code> clause), the Global
        Deadlock Detector affects how table rows are locked. See item <a class="xref" href="#topic1__eg138885">12</a> in Description and see "The Locking Clause" later in this section.
      </p>

    </div>

    <div class="section" id="topic1__section3"><h2 class="title sectiontitle">Description</h2>
      
      <p class="p"><code class="ph codeph">SELECT</code> retrieves rows from zero or more tables. The general processing of
          <code class="ph codeph">SELECT</code> is as follows: </p>

      <ol class="ol">
        <li class="li">All queries in the <code class="ph codeph">WITH</code> clause are computed. These effectively serve as
          temporary tables that can be referenced in the <code class="ph codeph">FROM</code> list. </li>

        <li class="li" id="topic1__eg138796">All elements in the <code class="ph codeph">FROM</code> list are computed. (Each element
          in the <code class="ph codeph">FROM</code> list is a real or virtual table.) If more than one element is
          specified in the <code class="ph codeph">FROM</code> list, they are cross-joined together.</li>

        <li class="li" id="topic1__eg138832">If the <code class="ph codeph">WHERE</code> clause is specified, all rows that do not
          satisfy the condition are eliminated from the output.</li>

        <li class="li" id="topic1__eg138840">If the <code class="ph codeph">GROUP BY</code> clause is specified, or if there are
          aggregate function calls, the output is combined into groups of rows that match on one or
          more values, and the results of aggregate functions are computed. If the
            <code class="ph codeph">HAVING</code> clause is present, it eliminates groups that do not satisfy the
          given condition.</li>

        <li class="li">The actual output rows are computed using the <code class="ph codeph">SELECT</code> output expressions
          for each selected row or row group. </li>

        <li class="li"><code class="ph codeph">SELECT DISTINCT</code> eliminates duplicate rows from the result.
            <code class="ph codeph">SELECT DISTINCT ON</code> eliminates rows that match on all the specified
          expressions. <code class="ph codeph">SELECT ALL</code> (the default) will return all candidate rows,
          including duplicates. </li>

        <li class="li" id="topic1__eg141787">If a window expression is specified (and optional <code class="ph codeph">WINDOW</code>
          clause), the output is organized according to the positional (row) or value-based (range)
          window frame.</li>

        <li class="li" id="topic1__eg138848">The actual output rows are computed using the <code class="ph codeph">SELECT</code>
          output expressions for each selected row.</li>


        <li class="li" id="topic1__eg138856">Using the operators <code class="ph codeph">UNION</code>, <code class="ph codeph">INTERSECT</code>,
          and <code class="ph codeph">EXCEPT</code>, the output of more than one <code class="ph codeph">SELECT</code> statement
          can be combined to form a single result set. The <code class="ph codeph">UNION</code> operator returns
          all rows that are in one or both of the result sets. The <code class="ph codeph">INTERSECT</code>
          operator returns all rows that are strictly in both result sets. The
            <code class="ph codeph">EXCEPT</code> operator returns the rows that are in the first result set but
          not in the second. In all three cases, duplicate rows are eliminated unless
            <code class="ph codeph">ALL</code> is specified. The noise word <code class="ph codeph">DISTINCT</code> can be added
          to explicitly specify eliminating duplicate rows. Notice that <code class="ph codeph">DISTINCT</code> is
          the default behavior here, even though <code class="ph codeph">ALL</code> is the default for
            <code class="ph codeph">SELECT</code> itself. </li>

        <li class="li" id="topic1__eg138864">If the <code class="ph codeph">ORDER BY</code> clause is specified, the returned rows
          are sorted in the specified order. If <code class="ph codeph">ORDER BY</code> is not given, the rows are
          returned in whatever order the system finds fastest to produce.</li>

        <li class="li" id="topic1__eg138878">If the <code class="ph codeph">LIMIT</code> (or <code class="ph codeph">FETCH FIRST</code>) or
            <code class="ph codeph">OFFSET</code> clause is specified, the <code class="ph codeph">SELECT</code> command only
          returns a subset of the result rows.</li>

        <li class="li" id="topic1__eg138885">If you specify a locking clause <code class="ph codeph">FOR {UPDATE</code>|<code class="ph codeph">NO
            KEY UPDATE</code>|<code class="ph codeph">SHARE</code>|<code class="ph codeph">KEY SHARE}</code>, the
            <code class="ph codeph">SELECT</code> command locks the entire table against concurrent updates when
          the Global Deadlock Detector is disabled (the default). When the Global Deadlock Detector
          is enabled, it affects some simple <code class="ph codeph">SELECT</code> statements that contain a
          locking clause.<p class="p">For information about using a <code class="ph codeph">FOR</code> clause and the effect
            of the Global Deadlock Detector, see "The Locking Clause" later in this
          section.</p>
</li>

      </ol>

      <p class="p">You must have <code class="ph codeph">SELECT</code> privilege on each column used in a
          <code class="ph codeph">SELECT</code> command. The use of <code class="ph codeph">FOR NO KEY UPDATE</code>,
          <code class="ph codeph">FOR UPDATE</code>, <code class="ph codeph">FOR SHARE</code>, or <code class="ph codeph">FOR KEY SHARE</code>
        requires <code class="ph codeph">UPDATE</code> privilege as well (for at least one column of each table so
        selected).</p>

    </div>

    <div class="section" id="topic1__section4"><h2 class="title sectiontitle">Parameters</h2>
      
      <div class="sectiondiv">
        <strong class="ph b">The WITH Clause</strong>
        <p class="p">The optional <code class="ph codeph">WITH</code> clause allows you to specify one or more subqueries
          that can be referenced by name in the primary query. The subqueries effectively act as
          temporary tables or views for the duration of the primary query. Each subquery can be a
            <code class="ph codeph">SELECT</code>, <code class="ph codeph">INSERT</code>, <code class="ph codeph">UPDATE</code>, or
            <code class="ph codeph">DELETE</code> statement. When writing a data-modifying statement
            (<code class="ph codeph">INSERT</code>, <code class="ph codeph">UPDATE</code>, or <code class="ph codeph">DELETE</code>) in
            <code class="ph codeph">WITH</code>, it is usual to include a <code class="ph codeph">RETURNING</code> clause. It is
          the output of <code class="ph codeph">RETURNING</code>, <em class="ph i">not</em> the underlying table that the
          statement modifies, that forms the temporary table that is read by the primary query. If
            <code class="ph codeph">RETURNING</code> is omitted, the statement is still run, but it produces
          no output so it cannot be referenced as a table by the primary query. </p>
<p class="p">For a <code class="ph codeph">SELECT</code> command that includes a
            <code class="ph codeph">WITH</code> clause, the clause can contain at most a single clause that
          modifies table data (<code class="ph codeph">INSERT</code>, <code class="ph codeph">UPDATE</code> or
            <code class="ph codeph">DELETE</code> command).</p>
<p class="p">A
            <var class="keyword varname">with_query_name</var> without schema qualification must be specified for
          each query in the <code class="ph codeph">WITH</code> clause. Optionally, a list of column names can be
          specified; if the list of column names is omitted, the names are inferred from the
          subquery. The primary query and the <code class="ph codeph">WITH</code> queries are all (notionally)
          run at the same time. </p>
<p class="p">If <code class="ph codeph">RECURSIVE</code> is specified, it
          allows a <code class="ph codeph">SELECT</code> subquery to reference itself by name. Such a subquery has
          the general
          form</p>
<pre class="pre codeblock"><code>&lt;non_recursive_term&gt; UNION [ALL | DISTINCT] &lt;recursive_term&gt;</code></pre><p class="p">where
          the recursive self-reference appears on the right-hand side of the <code class="ph codeph">UNION</code>.
          Only one recursive self-reference is permitted per query. Recursive data-modifying
          statements are not supported, but you can use the results of a recursive
            <code class="ph codeph">SELECT</code> query in a data-modifying statement.</p>
<p class="p">If the
            <code class="ph codeph">RECURSIVE</code> keyword is specified, the <code class="ph codeph">WITH</code> queries need
          not be ordered: a query can reference another query that is later in the list. However,
          circular references, or mutual recursion, are not supported. </p>
<p class="p">Without the
            <code class="ph codeph">RECURSIVE</code> keyword, <code class="ph codeph">WITH</code> queries can only reference
          sibling <code class="ph codeph">WITH</code> queries that are earlier in the <code class="ph codeph">WITH</code>
          list.</p>
<p class="p"><code class="ph codeph">WITH RECURSIVE</code> limitations. These items are not
          supported:</p>
<ul class="ul" id="topic1__ul_b21_szt_n1b">
          <li class="li">A recursive <code class="ph codeph">WITH</code> clause that contains the following in the
              <var class="keyword varname">recursive_term</var>. <ul class="ul" id="topic1__ul_c1b_nhf_p1b">
              <li class="li">Subqueries with a self-reference</li>

              <li class="li"><code class="ph codeph">DISTINCT</code> clause</li>

              <li class="li"><code class="ph codeph">GROUP BY</code> clause</li>

              <li class="li">A window function</li>

            </ul>
</li>

          <li class="li">A recursive <code class="ph codeph">WITH</code> clause where the <var class="keyword varname">with_query_name</var>
            is a part of a set operation.</li>

        </ul>
<div class="p">Following is an example of the set operation limitation. This query returns an error
          because the set operation <code class="ph codeph">UNION</code> contains a reference to the table
            <code class="ph codeph">foo</code>.
          <pre class="pre codeblock"><code>WITH RECURSIVE foo(i) AS (
    SELECT 1
  UNION ALL
    SELECT i+1 FROM (SELECT * FROM foo UNION SELECT 0) bar
)
SELECT * FROM foo LIMIT 5;</code></pre></div>
<div class="p">This
          recursive CTE is allowed because the set operation <code class="ph codeph">UNION</code> does not have a
          reference to the CTE
          <code class="ph codeph">foo</code>.<pre class="pre codeblock"><code>WITH RECURSIVE foo(i) AS (
    SELECT 1
  UNION ALL
    SELECT i+1 FROM (SELECT * FROM bar UNION SELECT 0) bar, foo
    WHERE foo.i = bar.a
)
SELECT * FROM foo LIMIT 5;</code></pre></div>

        <p class="p">A key property of <code class="ph codeph">WITH</code> queries is that they are evaluated only once per
          execution of the primary query, even if the primary query refers to them more than once.
          In particular, data-modifying statements are guaranteed to be run once and only once,
          regardless of whether the primary query reads all or any of their output.</p>

        <p class="p">The primary query and the <code class="ph codeph">WITH</code> queries are all (notionally) run at
          the same time. This implies that the effects of a data-modifying statement in
            <code class="ph codeph">WITH</code> cannot be seen from other parts of the query, other than by
          reading its <code class="ph codeph">RETURNING</code> output. If two such data-modifying statements
          attempt to modify the same row, the results are unspecified. </p>

        <p class="p">See <a class="xref" href="../../admin_guide/query/topics/CTE-query.html" target="_blank">WITH Queries (Common Table Expressions)
</a><span class="ph"> in the <cite class="cite">Greenplum Database Administrator Guide</cite></span>
          for additional information.</p>

      </div>
      <div class="sectiondiv" id="topic1__section5">
        <strong class="ph b">The SELECT List</strong>
        <p class="p">The <code class="ph codeph">SELECT</code> list (between the key words <code class="ph codeph">SELECT</code> and
            <code class="ph codeph">FROM</code>) specifies expressions that form the output rows of the
            <code class="ph codeph">SELECT</code> statement. The expressions can (and usually do) refer to columns
          computed in the <code class="ph codeph">FROM</code> clause. </p>
<p class="p">An <var class="keyword varname">expression</var> in
          the <code class="ph codeph">SELECT</code> list can be a constant value, a column reference, an operator
          invocation, a function call, an aggregate expression, a window expression, a scalar
          subquery, and so on. A number of constructs can be classified as an expression but do not
          follow any general syntax rules. These generally have the semantics of a function or
          operator. For information about SQL value expressions and function calls, see "Querying
          Data" in the <em class="ph i">Greenplum Database Administrator Guide</em>.</p>
<p class="p">Just as in a table,
          every output column of a <code class="ph codeph">SELECT</code> has a name. In a simple
            <code class="ph codeph">SELECT</code> this name is just used to label the column for display, but when
          the <code class="ph codeph">SELECT</code> is a sub-query of a larger query, the name is seen by the
          larger query as the column name of the virtual table produced by the sub-query. To specify
          the name to use for an output column, write <code class="ph codeph">AS</code>
          <var class="keyword varname">output_name</var> after the column's expression. (You can omit
            <code class="ph codeph">AS</code>, but only if the desired output name does not match any SQL keyword.
          For protection against possible future keyword additions, you can always either write
            <code class="ph codeph">AS</code> or double-quote the output name.) If you do not specify a column
          name, Greenplum Database chooses a name is automatically. If the column's expression is a
          simple column reference then the chosen name is the same as that column's name. In more
          complex cases, a function or type name may be used, or the system may fall back on a
          generated name such as <code class="ph codeph">?column?</code> or
            <code class="ph codeph">column<var class="keyword varname">N</var></code>. </p>
<p class="p">An output column's name can be used to
          refer to the column's value in <code class="ph codeph">ORDER BY</code> and <code class="ph codeph">GROUP BY</code>
          clauses, but not in the <code class="ph codeph">WHERE</code> or <code class="ph codeph">HAVING</code> clauses; there
          you must write out the expression instead.</p>
<p class="p">Instead of an expression,
            <code class="ph codeph">*</code> can be written in the output list as a shorthand for all the columns
          of the selected rows. Also, you can write <code class="ph codeph"><var class="keyword varname">table_name</var>.*</code>
          as a shorthand for the columns coming from just that table. In these cases it is not
          possible to specify new names with <code class="ph codeph">AS</code>; the output column names will be
          the same as the table columns' names.</p>
</div>
      <div class="sectiondiv"><strong class="ph b">The DISTINCT Clause</strong>
        <p class="p">If <code class="ph codeph">SELECT DISTINCT</code> is specified, all duplicate rows are removed from the
          result set (one row is kept from each group of duplicates). <code class="ph codeph">SELECT ALL</code>
          specifies the opposite: all rows are kept; that is the default. </p>

        <div class="p">
          <code class="ph codeph">SELECT DISTINCT ON ( <var class="keyword varname">expression</var> [, ...] )</code> keeps only
          the first row of each set of rows where the given expressions evaluate to equal. The
            <code class="ph codeph">DISTINCT ON</code> expressions are interpreted using the same rules as for
            <code class="ph codeph">ORDER BY</code> (see above). Note that the "first row" of each set is
          unpredictable unless <code class="ph codeph">ORDER BY</code> is used to ensure that the desired row
          appears first. For example:
          <pre class="pre codeblock"><code>
SELECT DISTINCT ON (location) location, time, report
    FROM weather_reports
    ORDER BY location, time DESC;
</code></pre>
          retrieves the most recent weather report for each location. But if we had not used
            <code class="ph codeph">ORDER BY</code> to force descending order of time values for each location,
          we'd have gotten a report from an unpredictable time for each location. </div>

          
        <p class="p"> The <code class="ph codeph">DISTINCT ON</code> expression(s) must match the leftmost <code class="ph codeph">ORDER
            BY</code> expression(s). The <code class="ph codeph">ORDER BY</code> clause will normally contain
          additional expression(s) that determine the desired precedence of rows within each
            <code class="ph codeph">DISTINCT ON</code> group. </p>

      </div>
      <div class="sectiondiv" id="topic1__section6"><strong class="ph b">The FROM Clause</strong><p class="p">The <code class="ph codeph">FROM</code> clause specifies
          one or more source tables for the <code class="ph codeph">SELECT</code>. If multiple sources are
          specified, the result is the Cartesian product (cross join) of all the sources. But
          usually qualification conditions are added (via <code class="ph codeph">WHERE</code>) to restrict the
          returned rows to a small subset of the Cartesian product. The <code class="ph codeph">FROM</code> clause
          can contain the following elements: </p>
<dl class="dl parml">
          
            <dt class="dt pt dlterm"><var class="keyword varname">table_name</var></dt>

            <dd class="dd pd">The name (optionally schema-qualified) of an existing table or view. If
                <code class="ph codeph">ONLY</code> is specified, only that table is scanned. If
                <code class="ph codeph">ONLY</code> is not specified, the table and all its descendant tables (if
              any) are scanned.</dd>

          
          
            <dt class="dt pt dlterm"><var class="keyword varname">alias</var></dt>

            <dd class="dd pd">A substitute name for the <code class="ph codeph">FROM</code> item containing the alias. An alias
              is used for brevity or to eliminate ambiguity for self-joins (where the same table is
              scanned multiple times). When an alias is provided, it completely hides the actual
              name of the table or function; for example given <code class="ph codeph">FROM foo AS f</code>, the
              remainder of the <code class="ph codeph">SELECT</code> must refer to this <code class="ph codeph">FROM</code> item
              as <code class="ph codeph">f</code> not <code class="ph codeph">foo</code>. If an alias is written, a column alias
              list can also be written to provide substitute names for one or more columns of the
              table.</dd>

          
          
            <dt class="dt pt dlterm"><var class="keyword varname">select</var></dt>

            <dd class="dd pd">A sub-<code class="ph codeph">SELECT</code> can appear in the <code class="ph codeph">FROM</code> clause. This
              acts as though its output were created as a temporary table for the duration of this
              single <code class="ph codeph">SELECT</code> command. Note that the sub-<code class="ph codeph">SELECT</code> must
              be surrounded by parentheses, and an alias must be provided for it. A <a class="xref" href="VALUES.html#topic1">VALUES</a> command can also be used here. See
              "Non-standard Clauses" in the <a class="xref" href="#topic1__section19">Compatibility</a> section
              for limitations of using correlated sub-selects in Greenplum Database.</dd>

          
          
            <dt class="dt pt dlterm">
              <var class="keyword varname">with_query_name</var>
            </dt>

            <dd class="dd pd">A <var class="keyword varname">with_query</var> is referenced in the <code class="ph codeph">FROM</code> clause by
              specifying its <var class="keyword varname">with_query_name</var>, just as though the name were a
              table name. The <var class="keyword varname">with_query_name</var> cannot contain a schema qualifier.
              An alias can be provided in the same way as for a table. </dd>

            <dd class="dd pd ddexpand">The <var class="keyword varname">with_query</var> hides a table of the same name for the purposes of
              the primary query. If necessary, you can refer to a table of the same name by
              qualifying the table name with the schema.</dd>

          
          
            <dt class="dt pt dlterm">
              <var class="keyword varname">function_name</var>
            </dt>

            <dd class="dd pd">Function calls can appear in the <code class="ph codeph">FROM</code> clause. (This is especially
              useful for functions that return result sets, but any function can be used.) This acts
              as though its output were created as a temporary table for the duration of this single
                <code class="ph codeph">SELECT</code> command. An alias may also be used. If an alias is written,
              a column alias list can also be written to provide substitute names for one or more
              attributes of the function's composite return type. If the function has been defined
              as returning the record data type, then an alias or the key word <code class="ph codeph">AS</code>
              must be present, followed by a column definition list in the form <code class="ph codeph">(
                column_name data_type [, ... ] )</code>. The column definition list must match the
              actual number and types of columns returned by the function.</dd>

          
          
            <dt class="dt pt dlterm"><var class="keyword varname">join_type</var></dt>

            <dd class="dd pd">One of:<ul class="ul" id="topic1__ul_bwd_ft2_m4">
                <li class="li" id="topic1__eg139018"><strong class="ph b">[INNER] JOIN</strong></li>

                <li class="li" id="topic1__eg139020"><strong class="ph b">LEFT [OUTER] JOIN</strong></li>

                <li class="li" id="topic1__eg139022"><strong class="ph b">RIGHT [OUTER] JOIN</strong></li>

                <li class="li" id="topic1__eg139024"><strong class="ph b">FULL [OUTER] JOIN</strong></li>

                <li class="li" id="topic1__eg139026"><strong class="ph b">CROSS JOIN</strong></li>

              </ul>
</dd>

            <dd class="dd pd ddexpand">For the <code class="ph codeph">INNER</code> and <code class="ph codeph">OUTER</code> join types, a join
              condition must be specified, namely exactly one of <code class="ph codeph">NATURAL</code>,
                <code class="ph codeph">ON <var class="keyword varname">join_condition</var></code>, or <code class="ph codeph">USING (
                  <var class="keyword varname">join_column</var> [, ...])</code>. See below for the meaning. For
                <code class="ph codeph">CROSS JOIN</code>, none of these clauses may appear.</dd>

            <dd class="dd pd ddexpand">A JOIN clause combines two <code class="ph codeph">FROM</code> items, which for convenience we
              will refer to as "tables", though in reality they can be any type of
                <code class="ph codeph">FROM</code> item. Use parentheses if necessary to determine the order of
              nesting. In the absence of parentheses, <code class="ph codeph">JOIN</code>s nest left-to-right. In
              any case <code class="ph codeph">JOIN</code> binds more tightly than the commas separating
                <code class="ph codeph">FROM</code>-list items. </dd>

            <dd class="dd pd ddexpand"><code class="ph codeph">CROSS JOIN</code> and <code class="ph codeph">INNER JOIN</code> produce a simple
              Cartesian product, the same result as you get from listing the two tables at the top
              level of <code class="ph codeph">FROM</code>, but restricted by the join condition (if any).
                <code class="ph codeph">CROSS JOIN</code> is equivalent to <code class="ph codeph">INNER JOIN
                ON</code><code class="ph codeph">(TRUE)</code>, that is, no rows are removed by qualification.
              These join types are just a notational convenience, since they do nothing you could
              not do with plain <code class="ph codeph">FROM</code> and <code class="ph codeph">WHERE</code>. </dd>

            <dd class="dd pd ddexpand"><code class="ph codeph">LEFT OUTER JOIN</code> returns all rows in the qualified Cartesian product
              (i.e., all combined rows that pass its join condition), plus one copy of each row in
              the left-hand table for which there was no right-hand row that passed the join
              condition. This left-hand row is extended to the full width of the joined table by
              inserting null values for the right-hand columns. Note that only the
                <code class="ph codeph">JOIN</code> clause's own condition is considered while deciding which rows
              have matches. Outer conditions are applied afterwards.</dd>

            <dd class="dd pd ddexpand">Conversely, <code class="ph codeph">RIGHT OUTER JOIN</code> returns all the joined rows, plus one
              row for each unmatched right-hand row (extended with nulls on the left). This is just
              a notational convenience, since you could convert it to a <code class="ph codeph">LEFT OUTER
                JOIN</code> by switching the left and right tables.</dd>

            <dd class="dd pd ddexpand"><code class="ph codeph">FULL OUTER JOIN</code> returns all the joined rows, plus one row for each
              unmatched left-hand row (extended with nulls on the right), plus one row for each
              unmatched right-hand row (extended with nulls on the left).</dd>

          
        </dl>
<dl class="dl parml">
          
            <dt class="dt pt dlterm">ON <var class="keyword varname">join_condition</var></dt>

            <dd class="dd pd"><var class="keyword varname">join_condition</var> is an expression resulting in a value of type
                <code class="ph codeph">boolean</code> (similar to a <code class="ph codeph">WHERE</code> clause) that specifies
              which rows in a join are considered to match.</dd>

          
          
            <dt class="dt pt dlterm">USING (<var class="keyword varname">join_column</var> [, ...])</dt>

            <dd class="dd pd">A clause of the form <code class="ph codeph">USING ( a, b, ... )</code> is shorthand for
                <code class="ph codeph">ON left_table.a = right_table.a AND left_table.b = right_table.b ...
              </code>. Also, <code class="ph codeph">USING</code> implies that only one of each pair of
              equivalent columns will be included in the join output, not both.</dd>

          
          
            <dt class="dt pt dlterm">NATURAL</dt>

            <dd class="dd pd"><code class="ph codeph">NATURAL</code> is shorthand for a <code class="ph codeph">USING</code> list that
              mentions all columns in the two tables that have the same names. If there are no
              common column names, <code class="ph codeph">NATURAL</code> is equivalent to <code class="ph codeph">ON
                TRUE</code>. </dd>

          
        </dl>
</div>
      <div class="sectiondiv" id="topic1__section7"><strong class="ph b">The WHERE Clause</strong><p class="p">The optional <code class="ph codeph">WHERE</code> clause
          has the general form:</p>
<pre class="pre codeblock"><code>WHERE &lt;condition&gt;</code></pre><p class="p">where
            <var class="keyword varname">condition</var> is any expression that evaluates to a result of type
            <code class="ph codeph">boolean</code>. Any row that does not satisfy this condition will be
          eliminated from the output. A row satisfies the condition if it returns true when the
          actual row values are substituted for any variable references. </p>
</div>
      <div class="sectiondiv" id="topic1__section8"><strong class="ph b">The GROUP BY Clause</strong><p class="p">The optional <code class="ph codeph">GROUP BY</code>
          clause has the general
          form:</p>
<pre class="pre codeblock"><code>GROUP BY &lt;grouping_element &gt;[, ...]</code></pre><p class="p">where
            <var class="keyword varname">grouping_element</var> can be one
            of:</p>
<pre class="pre codeblock"><code>()
&lt;expression&gt;
ROLLUP (&lt;expression&gt; [,...])
CUBE (&lt;expression&gt; [,...])
GROUPING SETS ((&lt;grouping_element&gt; [, ...]))</code></pre><p class="p"><code class="ph codeph">GROUP
            BY</code> will condense into a single row all selected rows that share the same values
          for the grouped expressions. <var class="keyword varname">expression</var> can be an input column name, or
          the name or ordinal number of an output column (<code class="ph codeph">SELECT</code> list item), or an
          arbitrary expression formed from input-column values. In case of ambiguity, a
            <code class="ph codeph">GROUP BY</code> name will be interpreted as an input-column name rather than
          an output column name.</p>
<p class="p">Aggregate functions, if any are used, are computed across all
          rows making up each group, producing a separate value for each group. (If there are
          aggregate functions but no <code class="ph codeph">GROUP BY</code> clause, the query is treated as
          having a single group comprising all the selected rows.) The set of rows fed to each
          aggregate function can be further filtered by attaching a <code class="ph codeph">FILTER</code> clause
          to the aggregate function call. When a <code class="ph codeph">FILTER</code> clause is present, only
          those rows matching it are included in the input to that aggregate function. See <a class="xref" href="../../admin_guide/query/topics/defining-queries.html#topic11" target="_blank">Aggregate Expressions</a>.</p>
<p class="p">When
            <code class="ph codeph">GROUP BY</code> is present, or any aggregate functions are present, it is not
          valid for the <code class="ph codeph">SELECT</code> list expressions to refer to ungrouped columns
          except within aggregate functions or when the ungrouped column is functionally dependent
          on the grouped columns, since there would otherwise be more than one possible value to
          return for an ungrouped column. A functional dependency exists if the grouped columns (or
          a subset thereof) are the primary key of the table containing the ungrouped column.</p>
<p class="p">
          Keep in mind that all aggregate functions are evaluated before evaluating any "scalar"
          expressions in the <code class="ph codeph">HAVING</code> clause or <code class="ph codeph">SELECT</code> list. This
          means that, for example, a <code class="ph codeph">CASE</code> expression cannot be used to skip
          evaluation of an aggregate function; see <a class="xref" href="../../admin_guide/query/topics/defining-queries.html#topic25" target="_blank">Expression Evaluation Rules</a>. </p>
<p class="p">Greenplum
          Database has the following additional OLAP grouping extensions (often referred to as
            <em class="ph i">supergroups</em>):</p>
<dl class="dl parml">
          
            <dt class="dt pt dlterm">ROLLUP</dt>

            <dd class="dd pd">A <code class="ph codeph">ROLLUP</code> grouping is an extension to the <code class="ph codeph">GROUP BY</code>
              clause that creates aggregate subtotals that roll up from the most detailed level to a
              grand total, following a list of grouping columns (or expressions).
                <code class="ph codeph">ROLLUP</code> takes an ordered list of grouping columns, calculates the
              standard aggregate values specified in the <code class="ph codeph">GROUP BY</code> clause, then
              creates progressively higher-level subtotals, moving from right to left through the
              list. Finally, it creates a grand total. A <code class="ph codeph">ROLLUP</code> grouping can be
              thought of as a series of grouping sets. For example:</dd>

            <dd class="dd pd ddexpand">
              <pre class="pre codeblock"><code>GROUP BY ROLLUP (a,b,c) </code></pre>
            </dd>

            <dd class="dd pd ddexpand">is equivalent to:</dd>

            <dd class="dd pd ddexpand">
              <pre class="pre codeblock"><code>GROUP BY GROUPING SETS( (a,b,c), (a,b), (a), () ) </code></pre>
            </dd>

            <dd class="dd pd ddexpand">Notice that the <var class="keyword varname">n</var> elements of a <code class="ph codeph">ROLLUP</code> translate
              to <var class="keyword varname">n</var>+1 grouping sets. Also, the order in which the grouping
              expressions are specified is significant in a <code class="ph codeph">ROLLUP</code>.</dd>

          
          
            <dt class="dt pt dlterm">CUBE</dt>

            <dd class="dd pd">A <code class="ph codeph">CUBE</code> grouping is an extension to the <code class="ph codeph">GROUP BY</code>
              clause that creates subtotals for all of the possible combinations of the given list
              of grouping columns (or expressions). In terms of multidimensional analysis,
                <code class="ph codeph">CUBE</code> generates all the subtotals that could be calculated for a
              data cube with the specified dimensions. For example:</dd>

            <dd class="dd pd ddexpand">
              <pre class="pre codeblock"><code>GROUP BY CUBE (a,b,c) </code></pre>
            </dd>

            <dd class="dd pd ddexpand">is equivalent to:</dd>

            <dd class="dd pd ddexpand">
              <pre class="pre codeblock"><code>GROUP BY GROUPING SETS( (a,b,c), (a,b), (a,c), (b,c), (a), 
(b), (c), () ) </code></pre>
            </dd>

            <dd class="dd pd ddexpand">Notice that <var class="keyword varname">n</var> elements of a <code class="ph codeph">CUBE</code> translate to 2n
              grouping sets. Consider using <code class="ph codeph">CUBE</code> in any situation requiring
              cross-tabular reports. <code class="ph codeph">CUBE</code> is typically most suitable in queries
              that use columns from multiple dimensions rather than columns representing different
              levels of a single dimension. For instance, a commonly requested cross-tabulation
              might need subtotals for all the combinations of month, state, and product.</dd>

          
          
            <dt class="dt pt dlterm">GROUPING SETS</dt>

            <dd class="dd pd">You can selectively specify the set of groups that you want to create using a
                <code class="ph codeph">GROUPING SETS</code> expression within a <code class="ph codeph">GROUP BY</code> clause.
              This allows precise specification across multiple dimensions without computing a whole
                <code class="ph codeph">ROLLUP</code> or <code class="ph codeph">CUBE</code>. For example:</dd>

            <dd class="dd pd ddexpand">
              <pre class="pre codeblock"><code>GROUP BY GROUPING SETS( (a,c), (a,b) )</code></pre>
            </dd>

            <dd class="dd pd ddexpand">If using the grouping extension clauses <code class="ph codeph">ROLLUP</code>,
                <code class="ph codeph">CUBE</code>, or <code class="ph codeph">GROUPING SETS</code>, two challenges arise.
              First, how do you determine which result rows are subtotals, and then the exact level
              of aggregation for a given subtotal. Or, how do you differentiate between result rows
              that contain both stored <code class="ph codeph">NULL</code> values and "NULL" values created by the
                <code class="ph codeph">ROLLUP</code> or <code class="ph codeph">CUBE</code>. Secondly, when duplicate grouping
              sets are specified in the <code class="ph codeph">GROUP BY</code> clause, how do you determine which
              result rows are duplicates? There are two additional grouping functions you can use in
              the <code class="ph codeph">SELECT</code> list to help with this:<ul class="ul" id="topic1__ul_vx1_3ml_m4">
                <li class="li" id="topic1__eg143759"><strong class="ph b">grouping(column [, ...])</strong> — The <code class="ph codeph">grouping</code>
                  function can be applied to one or more grouping attributes to distinguish
                  super-aggregated rows from regular grouped rows. This can be helpful in
                  distinguishing a "NULL" representing the set of all values in a super-aggregated
                  row from a <code class="ph codeph">NULL</code> value in a regular row. Each argument in this
                  function produces a bit — either <code class="ph codeph">1</code> or <code class="ph codeph">0</code>, where
                    <code class="ph codeph">1</code> means the result row is super-aggregated, and
                    <code class="ph codeph">0</code> means the result row is from a regular grouping. The
                    <code class="ph codeph">grouping</code> function returns an integer by treating these bits as
                  a binary number and then converting it to a base-10 integer.</li>

                <li class="li" id="topic1__eg143806"><strong class="ph b">group_id()</strong> — For grouping extension queries that contain
                  duplicate grouping sets, the <code class="ph codeph">group_id</code> function is used to
                  identify duplicate rows in the output. All <em class="ph i">unique</em> grouping set output rows
                  will have a group_id value of 0. For each duplicate grouping set detected, the
                    <code class="ph codeph">group_id</code> function assigns a group_id number greater than 0. All
                  output rows in a particular duplicate grouping set are identified by the same
                  group_id number. </li>

              </ul>
</dd>

          
        </dl>
</div>
      <div class="sectiondiv" id="topic1__section9"><strong class="ph b">The WINDOW Clause</strong><p class="p">The optional <code class="ph codeph">WINDOW</code>
          clause specifies the behavior of window functions appearing in the query's
            <code class="ph codeph">SELECT</code> list or <code class="ph codeph">ORDER BY</code> clause. These functions can
          reference the <code class="ph codeph">WINDOW</code> clause entries by name in their
            <code class="ph codeph">OVER</code> clauses. A <code class="ph codeph">WINDOW</code> clause entry does not have to
          be referenced anywhere, however; if it is not used in the query it is simply ignored. It
          is possible to use window functions without any <code class="ph codeph">WINDOW</code> clause at all,
          since a window function call can specify its window definition directly in its
            <code class="ph codeph">OVER</code> clause. However, the <code class="ph codeph">WINDOW</code> clause saves typing
          when the same window definition is needed for more than one window function.</p>
<p class="p">For
          example:</p>
<pre class="pre codeblock"><code>SELECT vendor, rank() OVER (mywindow) FROM sale
GROUP BY vendor
WINDOW mywindow AS (ORDER BY sum(prc*qty));</code></pre><p class="p">A
            <code class="ph codeph">WINDOW</code> clause has this general
  form:</p>
<pre class="pre codeblock"><code>WINDOW &lt;window_name&gt; AS (&lt;window_definition&gt;)</code></pre><p class="p">where <var class="keyword varname">window_name</var> is a name that can be referenced from <code class="ph codeph">OVER</code> clauses or subsequent window definitions, and <var class="keyword varname">window_definition</var> is:</p>
<pre class="pre codeblock"><code>[&lt;existing_window_name&gt;]
[PARTITION BY &lt;expression&gt; [, ...]]
[ORDER BY &lt;expression&gt; [ASC | DESC | USING &lt;operator&gt;] [NULLS {FIRST | LAST}] [, ...] ]
[&lt;frame_clause&gt;] </code></pre><dl class="dl parml">
          
            <dt class="dt pt dlterm"><var class="keyword varname">existing_window_name</var></dt>

            <dd class="dd pd">If an <code class="ph codeph"><var class="keyword varname">existing_window_name</var></code> is specified it must
              refer to an earlier entry in the <code class="ph codeph">WINDOW</code> list; the new window copies
              its partitioning clause from that entry, as well as its ordering clause if any. The
              new window cannot specify its own <code class="ph codeph">PARTITION BY</code> clause, and it can
              specify <code class="ph codeph">ORDER BY</code> only if the copied window does not have one. The new
              window always uses its own frame clause; the copied window must not specify a frame
              clause.</dd>

          
          
            <dt class="dt pt dlterm">PARTITION BY</dt>

            <dd class="dd pd">The <code class="ph codeph">PARTITION BY</code> clause organizes the result set into logical
              groups based on the unique values of the specified expression. The elements of the
                <code class="ph codeph">PARTITION BY</code> clause are interpreted in much the same fashion as
              elements of a <code class="ph codeph">GROUP BY</code> clause, except that they are always simple
              expressions and never the name or number of an output column. Another difference is
              that these expressions can contain aggregate function calls, which are not allowed in
              a regular <code class="ph codeph">GROUP BY</code> clause. They are allowed here because windowing
              occurs after grouping and aggregation. When used with window functions, the functions
              are applied to each partition independently. For example, if you follow
                <code class="ph codeph">PARTITION BY</code> with a column name, the result set is partitioned by
              the distinct values of that column. If omitted, the entire result set is considered
              one partition.</dd>

            <dd class="dd pd ddexpand">Similarly, the elements of the <code class="ph codeph">ORDER BY</code> list are interpreted in
              much the same fashion as elements of an <code class="ph codeph">ORDER BY</code> clause, except that
              the expressions are always taken as simple expressions and never the name or number of
              an output column. </dd>

          
          
            <dt class="dt pt dlterm">ORDER BY</dt>

            <dd class="dd pd">The elements of the <code class="ph codeph">ORDER BY</code> clause define how to sort the rows in
              each partition of the result set. If omitted, rows are returned in whatever order is
              most efficient and may vary. <strong class="ph b">Note:</strong> Columns of data types that lack a coherent
              ordering, such as <code class="ph codeph">time</code>, are not good candidates for use in the
                <code class="ph codeph">ORDER BY</code> clause of a window specification. Time, with or without
              time zone, lacks a coherent ordering because addition and subtraction do not have the
              expected effects. For example, the following is not generally true: <code class="ph codeph">x::time
                &lt; x::time + '2 hour'::interval</code></dd>

          
          
            <dt class="dt pt dlterm"><var class="keyword varname">frame_clause</var>
            </dt>

            <dd class="dd pd">The optional <code class="ph codeph"><var class="keyword varname">frame_clause</var></code> defines the <em class="ph i">window
                frame</em> for window functions that depend on the frame (not all do). The window
              frame is a set of related rows for each row of the query (called the <em class="ph i">current
                row</em>). The <code class="ph codeph"><var class="keyword varname">frame_clause</var></code> can be one of
              <pre class="pre codeblock"><code>{ RANGE | ROWS } &lt;frame_start&gt;
{ RANGE | ROWS } BETWEEN &lt;frame_start&gt; AND &lt;frame_end&gt;</code></pre>where
                  <code class="ph codeph"><var class="keyword varname">frame_start</var></code> and
                  <code class="ph codeph"><var class="keyword varname">frame_end</var></code> can be one of<ul class="ul" id="topic1__ul_ehq_kws_1gb">
                <li class="li"><code class="ph codeph">UNBOUNDED PRECEDING</code></li>

                <li class="li"><code class="ph codeph"><var class="keyword varname">value</var> PRECEDING</code></li>

                <li class="li"><code class="ph codeph">CURRENT ROW</code></li>

                <li class="li"><code class="ph codeph"><var class="keyword varname">value</var> FOLLOWING</code></li>

                <li class="li"><code class="ph codeph">UNBOUNDED FOLLOWING</code></li>

              </ul>
</dd>

            <dd class="dd pd ddexpand">If <code class="ph codeph"><var class="keyword varname">frame_end</var></code> is omitted it defaults to
                <code class="ph codeph">CURRENT ROW</code>. Restrictions are that
                  <code class="ph codeph"><var class="keyword varname">frame_start</var></code> cannot be <code class="ph codeph">UNBOUNDED
                FOLLOWING</code>, <code class="ph codeph"><var class="keyword varname">frame_end</var></code> cannot be
                <code class="ph codeph">UNBOUNDED PRECEDING</code>, and the
                <code class="ph codeph"><var class="keyword varname">frame_end</var></code> choice cannot appear earlier in the
              above list than the <code class="ph codeph"><var class="keyword varname">frame_start</var></code> choice — for
              example <code class="ph codeph">RANGE BETWEEN CURRENT ROW AND <var class="keyword varname">value</var>
                PRECEDING</code> is not allowed. </dd>

            <dd class="dd pd ddexpand">The default framing option is <code class="ph codeph">RANGE UNBOUNDED PRECEDING</code>, which is
              the same as <code class="ph codeph">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>; it
              sets the frame to be all rows from the partition start up through the current row's 
              last peer (a row that <code class="ph codeph">ORDER
                BY</code> considers equivalent to the current row, or all rows if there
                is no <code class="ph codeph">ORDER BY</code>). In general, <code class="ph codeph">UNBOUNDED PRECEDING</code> means
              that the frame starts with the first row of the partition, and similarly
                <code class="ph codeph">UNBOUNDED FOLLOWING</code> means that the frame ends with the last row of
              the partition (regardless of <code class="ph codeph">RANGE</code> or <code class="ph codeph">ROWS</code> mode). In
                <code class="ph codeph">ROWS</code> mode, <code class="ph codeph">CURRENT ROW</code> means that the frame starts
              or ends with the current row; but in <code class="ph codeph">RANGE</code> mode it means that the
              frame starts or ends with the current row's first or last peer in the <code class="ph codeph">ORDER
                BY</code> ordering. The <var class="keyword varname">value</var>
              <code class="ph codeph">PRECEDING</code> and <var class="keyword varname">value</var>
              <code class="ph codeph">FOLLOWING</code> cases are currently only allowed in <code class="ph codeph">ROWS</code>
              mode. They indicate that the frame starts or ends with the row that many rows before
              or after the current row. <var class="keyword varname">value</var> must be an integer expression not
              containing any variables, aggregate functions, or window functions. The value must not
              be null or negative; but it can be zero, which selects the current row itself. </dd>

            <dd class="dd pd ddexpand">Beware that the <code class="ph codeph">ROWS</code> options can produce unpredictable results if
              the <code class="ph codeph">ORDER BY</code> ordering does not order the rows uniquely. The
                <code class="ph codeph">RANGE</code> options are designed to ensure that rows that are peers in
              the <code class="ph codeph">ORDER BY</code> ordering are treated alike; all peer rows will be in the
              same frame. </dd>

            <dd class="dd pd ddexpand">Use either a <code class="ph codeph">ROWS</code> or <code class="ph codeph">RANGE</code> clause to express the
              bounds of the window. The window bound can be one, many, or all rows of a partition.
              You can express the bound of the window either in terms of a range of data values
              offset from the value in the current row (<code class="ph codeph">RANGE</code>), or in terms of the
              number of rows offset from the current row (<code class="ph codeph">ROWS</code>). When using the
                <code class="ph codeph">RANGE</code> clause, you must also use an <code class="ph codeph">ORDER BY</code>
              clause. This is because the calculation performed to produce the window requires that
              the values be sorted. Additionally, the <code class="ph codeph">ORDER BY</code> clause cannot
              contain more than one expression, and the expression must result in either a date or a
              numeric value. When using the <code class="ph codeph">ROWS</code> or <code class="ph codeph">RANGE</code> clauses,
              if you specify only a starting row, the current row is used as the last row in the
              window.</dd>

            <dd class="dd pd ddexpand"><strong class="ph b">PRECEDING</strong> — The <code class="ph codeph">PRECEDING</code> clause defines the first row of
              the window using the current row as a reference point. The starting row is expressed
              in terms of the number of rows preceding the current row. For example, in the case of
                <code class="ph codeph">ROWS</code> framing, <code class="ph codeph">5 PRECEDING</code> sets the window to start
              with the fifth row preceding the current row. In the case of <code class="ph codeph">RANGE</code>
              framing, it sets the window to start with the first row whose ordering column value
              precedes that of the current row by 5 in the given order. If the specified order is
              ascending by date, this will be the first row within 5 days before the current row.
                <code class="ph codeph">UNBOUNDED PRECEDING</code> sets the first row in the window to be the
              first row in the partition.</dd>

            <dd class="dd pd ddexpand"><strong class="ph b">BETWEEN</strong> — The <code class="ph codeph">BETWEEN</code> clause defines the first and last row
              of the window, using the current row as a reference point. First and last rows are
              expressed in terms of the number of rows preceding and following the current row,
              respectively. For example, <code class="ph codeph">BETWEEN 3 PRECEDING AND 5 FOLLOWING</code> sets
              the window to start with the third row preceding the current row, and end with the
              fifth row following the current row. Use <code class="ph codeph">BETWEEN UNBOUNDED PRECEDING AND
                UNBOUNDED FOLLOWING</code> to set the first and last rows in the window to be the
              first and last row in the partition, respectively. This is equivalent to the default
              behavior if no <code class="ph codeph">ROW</code> or <code class="ph codeph">RANGE</code> clause is
              specified.</dd>

            <dd class="dd pd ddexpand"><strong class="ph b">FOLLOWING</strong> — The <code class="ph codeph">FOLLOWING</code> clause defines the last row of the
              window using the current row as a reference point. The last row is expressed in terms
              of the number of rows following the current row. For example, in the case of
                <code class="ph codeph">ROWS</code> framing, <code class="ph codeph">5 FOLLOWING</code> sets the window to end
              with the fifth row following the current row. In the case of <code class="ph codeph">RANGE</code>
              framing, it sets the window to end with the last row whose ordering column value
              follows that of the current row by 5 in the given order. If the specified order is
              ascending by date, this will be the last row within 5 days after the current row. Use
                <code class="ph codeph">UNBOUNDED FOLLOWING</code> to set the last row in the window to be the
              last row in the partition.</dd>

            <dd class="dd pd ddexpand">If you do not specify a <code class="ph codeph">ROW</code> or a <code class="ph codeph">RANGE</code> clause, the
              window bound starts with the first row in the partition (<code class="ph codeph">UNBOUNDED
                PRECEDING</code>) and ends with the current row (<code class="ph codeph">CURRENT ROW</code>) if
                <code class="ph codeph">ORDER BY</code> is used. If an <code class="ph codeph">ORDER BY</code> is not specified,
              the window starts with the first row in the partition (<code class="ph codeph">UNBOUNDED
                PRECEDING</code>) and ends with last row in the partition (<code class="ph codeph">UNBOUNDED
                FOLLOWING</code>).</dd>

          
        </dl>
</div>
      <div class="sectiondiv" id="topic1__section10"><strong class="ph b">The HAVING Clause</strong><p class="p">The optional <code class="ph codeph">HAVING</code>
          clause has the general
          form:</p>
<pre class="pre codeblock"><code>HAVING &lt;condition&gt;</code></pre><p class="p">where
            <var class="keyword varname">condition</var> is the same as specified for the <code class="ph codeph">WHERE</code>
          clause. <code class="ph codeph">HAVING</code> eliminates group rows that do not satisfy the condition.
            <code class="ph codeph">HAVING</code> is different from <code class="ph codeph">WHERE</code>: <code class="ph codeph">WHERE</code>
          filters individual rows before the application of <code class="ph codeph">GROUP BY</code>, while
            <code class="ph codeph">HAVING</code> filters group rows created by <code class="ph codeph">GROUP BY</code>. Each
          column referenced in <var class="keyword varname">condition</var> must unambiguously reference a grouping
            column, unless the reference appears within an aggregate function or the ungrouped column is
            functionally dependent on the grouping columns.</p>
<p class="p">The presence of
            <code class="ph codeph">HAVING</code> turns a query into a grouped query even if there is no
            <code class="ph codeph">GROUP BY</code> clause. This is the same as what happens when the query
          contains aggregate functions but no <code class="ph codeph">GROUP BY</code> clause. All the selected
          rows are considered to form a single group, and the <code class="ph codeph">SELECT</code> list and
            <code class="ph codeph">HAVING</code> clause can only reference table columns from within aggregate
          functions. Such a query will emit a single row if the <code class="ph codeph">HAVING</code> condition is
          true, zero rows if it is not true. </p>
</div>
      <div class="sectiondiv" id="topic1__section11"><strong class="ph b">The UNION Clause</strong><p class="p">The <code class="ph codeph">UNION</code> clause has
          this general
          form:</p>
<pre class="pre codeblock"><code>&lt;select_statement&gt; UNION [ALL | DISTINCT] &lt;select_statement&gt;</code></pre><p class="p">where
            <var class="keyword varname">select_statement</var> is any <code class="ph codeph">SELECT</code> statement without an
            <code class="ph codeph">ORDER BY</code>, <code class="ph codeph">LIMIT</code>, <code class="ph codeph">FOR NO KEY UPDATE</code>,
            <code class="ph codeph">FOR UPDATE</code>, <code class="ph codeph">FOR SHARE</code>, or <code class="ph codeph">FOR KEY
            SHARE</code> clause. (<code class="ph codeph">ORDER BY</code> and <code class="ph codeph">LIMIT</code> can be
          attached to a subquery expression if it is enclosed in parentheses. Without parentheses,
          these clauses will be taken to apply to the result of the <code class="ph codeph">UNION</code>, not to
          its right-hand input expression.) </p>
<p class="p">The <code class="ph codeph">UNION</code> operator computes the
          set union of the rows returned by the involved <code class="ph codeph">SELECT</code> statements. A row
          is in the set union of two result sets if it appears in at least one of the result sets.
          The two <code class="ph codeph">SELECT</code> statements that represent the direct operands of the
            <code class="ph codeph">UNION</code> must produce the same number of columns, and corresponding
          columns must be of compatible data types.</p>
<p class="p">The result of <code class="ph codeph">UNION</code> does
          not contain any duplicate rows unless the <code class="ph codeph">ALL</code> option is specified.
            <code class="ph codeph">ALL</code> prevents elimination of duplicates. (Therefore, <code class="ph codeph">UNION
            ALL</code> is usually significantly quicker than <code class="ph codeph">UNION</code>; use
            <code class="ph codeph">ALL</code> when you can.) <code class="ph codeph">DISTINCT</code> can be written to
          explicitly specify the default behavior of eliminating duplicate rows. </p>
<p class="p">Multiple
            <code class="ph codeph">UNION</code> operators in the same <code class="ph codeph">SELECT</code> statement are
          evaluated left to right, unless otherwise indicated by parentheses. </p>
<p class="p">Currently,
            <code class="ph codeph">FOR NO KEY UPDATE</code>, <code class="ph codeph">FOR UPDATE</code>, <code class="ph codeph">FOR
            SHARE</code>, and <code class="ph codeph">FOR KEY SHARE</code> cannot be specified either for a
            <code class="ph codeph">UNION</code> result or for any input of a <code class="ph codeph">UNION</code>.
        </p>
</div>
      <div class="sectiondiv" id="topic1__section12"><strong class="ph b">The INTERSECT Clause</strong><p class="p">The <code class="ph codeph">INTERSECT</code> clause
          has this general
          form:</p>
<pre class="pre codeblock"><code>&lt;select_statement&gt; INTERSECT [ALL | DISTINCT] &lt;select_statement&gt;</code></pre><p class="p">where
            <var class="keyword varname">select_statement</var> is any SELECT statement without an <code class="ph codeph">ORDER
            BY</code>, <code class="ph codeph">LIMIT</code>, <code class="ph codeph">FOR NO KEY UPDATE</code>, <code class="ph codeph">FOR
            UPDATE</code>, <code class="ph codeph">FOR SHARE</code>, or <code class="ph codeph">FOR KEY SHARE</code> clause.
          </p>
<p class="p">The <code class="ph codeph">INTERSECT</code> operator computes the set intersection of the rows
          returned by the involved <code class="ph codeph">SELECT</code> statements. A row is in the intersection
          of two result sets if it appears in both result sets.</p>
<p class="p">The result of
            <code class="ph codeph">INTERSECT</code> does not contain any duplicate rows unless the
            <code class="ph codeph">ALL</code> option is specified. With <code class="ph codeph">ALL</code>, a row that has
            <var class="keyword varname">m</var> duplicates in the left table and <var class="keyword varname">n</var> duplicates in
          the right table will appear min(<var class="keyword varname">m</var>, <var class="keyword varname">n</var>) times in the
          result set. <code class="ph codeph">DISTINCT</code> can be written to explicitly specify the default
          behavior of eliminating duplicate rows.</p>
<p class="p">Multiple <code class="ph codeph">INTERSECT</code>
          operators in the same <code class="ph codeph">SELECT</code> statement are evaluated left to right,
          unless parentheses dictate otherwise. <code class="ph codeph">INTERSECT</code> binds more tightly than
            <code class="ph codeph">UNION</code>. That is, <code class="ph codeph">A UNION B INTERSECT C</code> will be read as
            <code class="ph codeph">A UNION (B INTERSECT C)</code>. </p>
<p class="p">Currently, <code class="ph codeph">FOR NO KEY
            UPDATE</code>, <code class="ph codeph">FOR UPDATE</code>, <code class="ph codeph">FOR SHARE</code>, and
            <code class="ph codeph">FOR KEY SHARE</code> cannot be specified either for an
            <code class="ph codeph">INTERSECT</code> result or for any input of an <code class="ph codeph">INTERSECT</code>.
        </p>
</div>
      <div class="sectiondiv" id="topic1__section13"><strong class="ph b">The EXCEPT Clause</strong><p class="p">The <code class="ph codeph">EXCEPT</code> clause has
          this general
          form:</p>
<pre class="pre codeblock"><code>&lt;select_statement&gt; EXCEPT [ALL | DISTINCT] &lt;select_statement&gt;</code></pre><p class="p">where
            <var class="keyword varname">select_statement</var> is any <code class="ph codeph">SELECT</code> statement without an
            <code class="ph codeph">ORDER BY</code>, <code class="ph codeph">LIMIT</code>, <code class="ph codeph">FOR NO KEY UPDATE</code>,
            <code class="ph codeph">FOR UPDATE</code>, <code class="ph codeph">FOR SHARE</code>, or <code class="ph codeph">FOR KEY
            SHARE</code> clause. </p>
<p class="p">The <code class="ph codeph">EXCEPT</code> operator computes the set of
          rows that are in the result of the left <code class="ph codeph">SELECT</code> statement but not in the
          result of the right one. </p>
<p class="p">The result of <code class="ph codeph">EXCEPT</code> does not contain any
          duplicate rows unless the <code class="ph codeph">ALL</code> option is specified. With
            <code class="ph codeph">ALL</code>, a row that has <var class="keyword varname">m</var> duplicates in the left table
          and <var class="keyword varname">n</var> duplicates in the right table will appear
            max(<var class="keyword varname">m-n</var>,0) times in the result set. <code class="ph codeph">DISTINCT</code> can be
          written to explicitly specify the default behavior of eliminating duplicate
          rows.</p>
<p class="p">Multiple <code class="ph codeph">EXCEPT</code> operators in the same <code class="ph codeph">SELECT</code>
          statement are evaluated left to right, unless parentheses dictate otherwise.
            <code class="ph codeph">EXCEPT</code> binds at the same level as <code class="ph codeph">UNION</code>.
          </p>
<p class="p">Currently, <code class="ph codeph">FOR NO KEY UPDATE</code>, <code class="ph codeph">FOR UPDATE</code>,
            <code class="ph codeph">FOR SHARE</code>, and <code class="ph codeph">FOR KEY SHARE</code> cannot be specified
          either for an <code class="ph codeph">EXCEPT</code> result or for any input of an
            <code class="ph codeph">EXCEPT</code>. </p>
</div>
      <div class="sectiondiv" id="topic1__section14"><strong class="ph b">The ORDER BY Clause</strong><p class="p">The optional <code class="ph codeph">ORDER BY</code>
          clause has this general
          form:</p>
<pre class="pre codeblock"><code>ORDER BY &lt;expression&gt; [ASC | DESC | USING &lt;operator&gt;] [NULLS {FIRST | LAST}] [,...]</code></pre><p class="p">where
            <var class="keyword varname">expression</var> can be the name or ordinal number of an output column
            (<code class="ph codeph">SELECT</code> list item), or it can be an arbitrary expression formed from
          input-column values. </p>
<p class="p">The <code class="ph codeph">ORDER BY</code> clause causes the result rows to
          be sorted according to the specified expressions. If two rows are equal according to the
          left-most expression, they are compared according to the next expression and so on. If
          they are equal according to all specified expressions, they are returned in an
          implementation-dependent order.</p>
<p class="p">The ordinal number refers to the ordinal
          (left-to-right) position of the output column. This feature makes it possible to define an
          ordering on the basis of a column that does not have a unique name. This is never
          absolutely necessary because it is always possible to assign a name to an output column
          using the <code class="ph codeph">AS</code> clause. </p>
<p class="p">It is also possible to use arbitrary
          expressions in the <code class="ph codeph">ORDER BY</code> clause, including columns that do not appear
          in the <code class="ph codeph">SELECT</code> output list. Thus the following statement is
          valid:</p>
<pre class="pre codeblock"><code>SELECT name FROM distributors ORDER BY code;</code></pre><p class="p">A
          limitation of this feature is that an <code class="ph codeph">ORDER BY</code> clause applying to the
          result of a <code class="ph codeph">UNION</code>, <code class="ph codeph">INTERSECT</code>, or <code class="ph codeph">EXCEPT</code>
          clause may only specify an output column name or number, not an expression.</p>
<p class="p">If an
            <code class="ph codeph">ORDER BY</code> expression is a simple name that matches both an output column
          name and an input column name, <code class="ph codeph">ORDER BY</code> will interpret it as the output
          column name. This is the opposite of the choice that <code class="ph codeph">GROUP BY</code> will make
          in the same situation. This inconsistency is made to be compatible with the SQL standard.
          </p>
<p class="p">Optionally one may add the key word <code class="ph codeph">ASC</code> (ascending) or
            <code class="ph codeph">DESC</code> (descending) after any expression in the <code class="ph codeph">ORDER BY</code>
          clause. If not specified, <code class="ph codeph">ASC</code> is assumed by default. Alternatively, a
          specific ordering operator name may be specified in the <code class="ph codeph">USING</code> clause.
            <code class="ph codeph">ASC</code> is usually equivalent to <code class="ph codeph">USING &lt;</code> and
            <code class="ph codeph">DESC</code> is usually equivalent to <code class="ph codeph">USING &gt;</code>. (But the
          creator of a user-defined data type can define exactly what the default sort ordering is,
          and it might correspond to operators with other names.) </p>
<p class="p">If <code class="ph codeph">NULLS
            LAST</code> is specified, null values sort after all non-null values; if <code class="ph codeph">NULLS
            FIRST</code> is specified, null values sort before all non-null values. If neither is
          specified, the default behavior is <code class="ph codeph">NULLS LAST</code> when <code class="ph codeph">ASC</code>
          is specified or implied, and <code class="ph codeph">NULLS FIRST</code> when <code class="ph codeph">DESC</code> is
          specified (thus, the default is to act as though nulls are larger than non-nulls). When
            <code class="ph codeph">USING</code> is specified, the default nulls ordering depends upon whether the
          operator is a less-than or greater-than operator.</p>
<p class="p">Note that ordering options apply
          only to the expression they follow; for example <code class="ph codeph">ORDER BY x, y DESC</code> does
          not mean the same thing as <code class="ph codeph">ORDER BY x DESC, y
          DESC</code>.</p>
<p class="p">Character-string data is sorted according to the locale-specific
          collation order that was established when the database was created.</p>
<p class="p">Character-string data is sorted
          according to the collation that applies to the column being sorted. That can be overridden
          as needed by including a <code class="ph codeph">COLLATE</code> clause in the
            <var class="keyword varname">expression</var>, for example <code class="ph codeph">ORDER BY mycolumn COLLATE
            "en_US"</code>. For information about defining collations, see <a class="xref" href="CREATE_COLLATION.html">CREATE
            COLLATION</a>.</p>
</div>
      <div class="sectiondiv"><strong class="ph b">The LIMIT Clause</strong><p class="p">The <code class="ph codeph">LIMIT</code> clause consists of two
          independent
          sub-clauses:</p>
<pre class="pre codeblock"><code>LIMIT {&lt;count&gt; | ALL}
OFFSET &lt;start&gt;</code></pre><p class="p">where
            <var class="keyword varname">count</var> specifies the maximum number of rows to return, while
            <var class="keyword varname">start</var> specifies the number of rows to skip before starting to return
          rows. When both are specified, start rows are skipped before starting to count the
            <code class="ph codeph">count</code> rows to be returned. </p>
<p class="p">If the <code class="ph codeph">count</code>
          expression evaluates to NULL, it is treated as <code class="ph codeph">LIMIT ALL</code>, that is, no
          limit. If <code class="ph codeph">start</code> evaluates to NULL, it is treated the same as
            <code class="ph codeph">OFFSET 0</code>.</p>
<div class="p">SQL:2008 introduced a different syntax to achieve the
          same result, which Greenplum Database also supports. It is:
          <pre class="pre codeblock"><code>OFFSET &lt;start&gt; [ ROW | ROWS ]
            FETCH { FIRST | NEXT } [ &lt;count&gt; ] { ROW | ROWS } ONLY</code></pre></div>
<p class="p">In this syntax, the <var class="keyword varname">start</var>
              or <var class="keyword varname">count</var> value is required by
              the standard to be a literal constant, a parameter, or a variable name;
              as a Greenplum Database extension, other expressions
              are allowed, but will generally need to be enclosed in parentheses to avoid
              ambiguity.
              If <var class="keyword varname">count</var> is
              omitted in a <code class="ph codeph">FETCH</code> clause, it defaults to 1.            
            <code class="ph codeph">ROW</code> and <code class="ph codeph">ROWS</code> as well as <code class="ph codeph">FIRST</code> and
            <code class="ph codeph">NEXT</code> are noise words that don't influence the effects of these clauses.
          According to the standard, the <code class="ph codeph">OFFSET</code> clause must come before the
            <code class="ph codeph">FETCH</code> clause if both are present; but Greenplum Database allows either
          order.</p>
<p class="p">When using <code class="ph codeph">LIMIT</code>, it is a good idea to use an <code class="ph codeph">ORDER
            BY</code> clause that constrains the result rows into a unique order. Otherwise you
          will get an unpredictable subset of the query's rows — you may be asking for the tenth
          through twentieth rows, but tenth through twentieth in what ordering? You don't know what
          ordering unless you specify <code class="ph codeph">ORDER BY</code>. </p>
<p class="p">The query optimizer takes
            <code class="ph codeph">LIMIT</code> into account when generating a query plan, so you are very likely
          to get different plans (yielding different row orders) depending on what you use for
            <code class="ph codeph">LIMIT</code> and <code class="ph codeph">OFFSET</code>. Thus, using different
            <code class="ph codeph">LIMIT/OFFSET</code> values to select different subsets of a query result will
          give inconsistent results unless you enforce a predictable result ordering with
            <code class="ph codeph">ORDER BY</code>. This is not a defect; it is an inherent consequence of the
          fact that SQL does not promise to deliver the results of a query in any particular order
          unless <code class="ph codeph">ORDER BY</code> is used to constrain the order.</p>
</div>
      <div class="sectiondiv" id="topic1__section17"><strong class="ph b">The Locking Clause</strong><p class="p"><code class="ph codeph">FOR UPDATE</code>,
            <code class="ph codeph">FOR NO KEY UPDATE</code>, <code class="ph codeph">FOR SHARE</code> and <code class="ph codeph">FOR KEY
            SHARE</code> are <em class="ph i">locking clauses</em>; they affect how <code class="ph codeph">SELECT</code> locks
          rows as they are obtained from the table. The Global Deadlock Detector affects the locking
          used by <code class="ph codeph">SELECT</code> queries that contain a locking clause (<code class="ph codeph">FOR
              <var class="keyword varname">lock_strength</var></code>). The Global Deadlock Detector is enabled by
          setting the <a class="xref" href="../config_params/guc-list.html#gp_enable_global_deadlock_detector">gp_enable_global_deadlock_detector</a> configuration parameter to
            <code class="ph codeph">on</code>. See <a class="xref" href="../../admin_guide/dml.html#topic_gdd" target="_blank"> Global
            Deadlock Detector</a> in the <cite class="cite">Greenplum Database Administrator Guide</cite> for
          information about the Global Deadlock Detector.</p>
<p class="p">The locking clause has the general
          form</p>
<pre class="pre codeblock"><code>FOR &lt;lock_strength&gt; [OF &lt;table_name&gt; [ , ... ] ] [ NOWAIT ]</code></pre><div class="p">The
            <var class="keyword varname">lock_strength</var> can be one of these values. <ul class="ul" id="topic1__ol_m3x_p54_n3b">
            <li class="li"><code class="ph codeph">UPDATE</code> - Locks the table with an <code class="ph codeph">EXCLUSIVE</code>
              lock.</li>

            <li class="li"><code class="ph codeph">NO KEY UPDATE</code> - Locks the table with an <code class="ph codeph">EXCLUSIVE</code>
              lock.</li>

            <li class="li"><code class="ph codeph">SHARE</code> - Locks the table with a <code class="ph codeph">ROW SHARE</code>
              lock.</li>

            <li class="li"><code class="ph codeph">KEY SHARE</code> - Locks the table with a <code class="ph codeph">ROW SHARE</code>
              lock.</li>

          </ul>
</div>
<p class="p">When the Global Deadlock Detector is disabled (the default), Greenplum
          Database uses the specified lock.</p>
<p class="p">When the Global Deadlock Detector is enabled, a
            <code class="ph codeph">ROW SHARE</code> lock is used to lock the table for simple
            <code class="ph codeph">SELECT</code> queries that contain a locking clause, and the query plans
          contain a <code class="ph codeph">lockrows</code> node. Simple <code class="ph codeph">SELECT</code> queries that
          contain a locking clause fulfill all the following conditions: </p>
<ul class="ul" id="topic1__ul_pf5_prm_43b">
          <li class="li">The locking clause is in the top level <code class="ph codeph">SELECT</code> context.</li>

          <li class="li">The <code class="ph codeph">FROM</code> clause contains a single table that is not a view or an
            append optimized table.</li>

          <li class="li">The <code class="ph codeph">SELECT</code> command does not contain a set operation such as
              <code class="ph codeph">UNION</code> or <code class="ph codeph">INTERSECT</code>.</li>

          <li class="li">The <code class="ph codeph">SELECT</code> command does not contain a sub-query.</li>

        </ul>
<p class="p">Otherwise, table locking for a <code class="ph codeph">SELECT</code> query that contains a locking
          clause behaves as if the Global Deadlock Detector is disabled.</p>

        <div class="note"><span class="notetitle">Note:</span> The Global Deadlock Detector also affects the locking used by <code class="ph codeph">DELETE</code>
          and <code class="ph codeph">UPDATE</code> operations. By default, Greenplum Database acquires an
            <code class="ph codeph">EXCLUSIVE</code> lock on tables for <code class="ph codeph">DELETE</code> and
            <code class="ph codeph">UPDATE</code> operations on heap tables. When the Global Deadlock Detector is
          enabled, the lock mode for <code class="ph codeph">DELETE</code> and <code class="ph codeph">UPDATE</code> operations
          on heap tables is <code class="ph codeph">ROW EXCLUSIVE</code>. </div>
<p class="p">For more information on each
          row-level lock mode, refer to <a class="xref" href="https://www.postgresql.org/docs/9.4/explicit-locking.html" target="_blank">Explicit Locking</a> in the PostgreSQL documentation.</p>
<p class="p">To
          prevent the operation from waiting for other transactions to commit, use the
            <code class="ph codeph">NOWAIT</code> option. With <code class="ph codeph">NOWAIT</code>, the statement reports an
          error, rather than waiting, if a selected row cannot be locked immediately. Note that
            <code class="ph codeph">NOWAIT</code> applies only to the row-level lock(s) — the required <code class="ph codeph">ROW
            SHARE</code> table-level lock is still taken in the ordinary way. You can use LOCK
          with the <code class="ph codeph">NOWAIT</code> option first, if you need to acquire the table-level lock
          without waiting.</p>
<p class="p">If specific tables are named in a locking clause, then only rows
          coming from those tables are locked; any other tables used in the <code class="ph codeph">SELECT</code>
          are simply read as usual. A locking clause without a table list affects all tables used in
          the statement. If a locking clause is applied to a view or sub-query, it affects all
          tables used in the view or sub-query. However, these clauses do not apply to
            <code class="ph codeph">WITH</code> queries referenced by the primary query. If you want row locking
          to occur within a <code class="ph codeph">WITH</code> query, specify a locking clause within the
            <code class="ph codeph">WITH</code> query.</p>
<p class="p">Multiple locking clauses can be written if it is
          necessary to specify different locking behavior for different tables. If the same table is
          mentioned (or implicitly affected) by both more than one locking clause, then it is
          processed as if it was only specified by the strongest one. Similarly, a table is
          processed as <code class="ph codeph">NOWAIT</code> if that is specified in any of the clauses affecting
          it.</p>
<p class="p">The locking clauses cannot be used in contexts where returned rows cannot be
          clearly identified with individual table rows; for example they cannot be used with
          aggregation.</p>
<p class="p">When a locking clause appears at the top level of a
            <code class="ph codeph">SELECT</code> query, the rows that are locked are exactly those that are
          returned by the query; in the case of a join query, the rows locked are those that
          contribute to returned join rows. In addition, rows that satisfied the query conditions as
          of the query snapshot will be locked, although they will not be returned if they were
          updated after the snapshot and no longer satisfy the query conditions. If a
            <code class="ph codeph">LIMIT</code> is used, locking stops once enough rows have been returned to
          satisfy the limit (but note that rows skipped over by <code class="ph codeph">OFFSET</code> will get
          locked). Similarly, if a locking clause is used in a cursor's query, only rows actually
          fetched or stepped past by the cursor will be locked.</p>
<div class="p">When locking clause appears in
          a sub-<code class="ph codeph">SELECT</code>, the rows locked are those returned to the outer query by
          the sub-query. This might involve fewer rows than inspection of the sub-query alone would
          suggest, since conditions from the outer query might be used to optimize execution of the
          sub-query. For example,
          <pre class="pre codeblock"><code>SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;</code></pre>
          will lock only rows having <code class="ph codeph">col1 = 5</code>, even though that condition is not
          textually within the sub-query. </div>
<div class="p">It is possible for a <code class="ph codeph">SELECT</code>
          command running at the <code class="ph codeph">READ COMMITTED</code> transaction isolation level and
          using <code class="ph codeph">ORDER BY</code> and a locking clause to return rows out of order. This is
          because <code class="ph codeph">ORDER BY</code> is applied first. The command sorts the result, but
          might then block trying to obtain a lock on one or more of the rows. Once the
            <code class="ph codeph">SELECT</code> unblocks, some of the ordering column values might have been
          modified, leading to those rows appearing to be out of order (though they are in order in
          terms of the original column values). This can be worked around at need by placing the
            <code class="ph codeph">FOR UPDATE/SHARE</code> clause in a sub-query, for example
          <pre class="pre codeblock"><code>SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;</code></pre>Note
          that this will result in locking all rows of <code class="ph codeph">mytable</code>, whereas <code class="ph codeph">FOR
            UPDATE</code> at the top level would lock only the actually returned rows. This can
          make for a significant performance difference, particularly if the <code class="ph codeph">ORDER
            BY</code> is combined with <code class="ph codeph">LIMIT</code> or other restrictions. So this
          technique is recommended only if concurrent updates of the ordering columns are expected
          and a strictly sorted result is required. </div>
<p class="p">At the <code class="ph codeph">REPEATABLE READ</code>
          or <code class="ph codeph">SERIALIZABLE</code> transaction isolation level this would cause a
          serialization failure (with a <code class="ph codeph">SQLSTATE</code> of <code class="ph codeph">40001</code>), so
          there is no possibility of receiving rows out of order under these isolation
        levels.</p>
</div>
    </div>

    <div class="section" id="topic1__table-command"><h2 class="title sectiontitle">The TABLE Command</h2>
      
      <p class="p">The command</p>

      <pre class="pre codeblock"><code>TABLE &lt;name&gt;</code></pre>
      <p class="p">is completely equivalent to</p>

      <pre class="pre codeblock"><code>SELECT * FROM &lt;name&gt;</code></pre>
      <p class="p">It can be used as a top-level command or as a space-saving syntax variant in parts of
        complex queries.</p>

    </div>

    <div class="section" id="topic1__section18"><h2 class="title sectiontitle">Examples</h2>
      
      <p class="p">To join the table <code class="ph codeph">films</code> with the table <code class="ph codeph">distributors</code>: </p>

      <pre class="pre codeblock"><code>SELECT f.title, f.did, d.name, f.date_prod, f.kind FROM 
distributors d, films f WHERE f.did = d.did</code></pre>
      <p class="p">To sum the column <code class="ph codeph">length</code> of all films and group the results by
          <code class="ph codeph">kind</code>: </p>

      <pre class="pre codeblock"><code>SELECT kind, sum(length) AS total FROM films GROUP BY kind;</code></pre>
      <p class="p">To sum the column <code class="ph codeph">length</code> of all films, group the results by
          <code class="ph codeph">kind</code> and show those group totals that are less than 5 hours: </p>

      <pre class="pre codeblock"><code>SELECT kind, sum(length) AS total FROM films GROUP BY kind 
HAVING sum(length) &lt; interval '5 hours';</code></pre>
      <p class="p">Calculate the subtotals and grand totals of all sales for movie <code class="ph codeph">kind</code> and
          <code class="ph codeph">distributor</code>.</p>

      <pre class="pre codeblock"><code>SELECT kind, distributor, sum(prc*qty) FROM sales
GROUP BY ROLLUP(kind, distributor)
ORDER BY 1,2,3;</code></pre>
      <p class="p">Calculate the rank of movie distributors based on total sales:</p>

      <pre class="pre codeblock"><code>SELECT distributor, sum(prc*qty), 
       rank() OVER (ORDER BY sum(prc*qty) DESC) 
FROM sale
GROUP BY distributor ORDER BY 2 DESC;</code></pre>
      <p class="p">The following two examples are identical ways of sorting the individual results according
        to the contents of the second column (<code class="ph codeph">name</code>):</p>

      <pre class="pre codeblock"><code>SELECT * FROM distributors ORDER BY name;
SELECT * FROM distributors ORDER BY 2;</code></pre>
      <p class="p">The next example shows how to obtain the union of the tables <code class="ph codeph">distributors</code>
        and <code class="ph codeph">actors</code>, restricting the results to those that begin with the letter
          <code class="ph codeph">W</code> in each table. Only distinct rows are wanted, so the key word
          <code class="ph codeph">ALL</code> is omitted: </p>

      <pre class="pre codeblock"><code>SELECT distributors.name FROM distributors WHERE 
distributors.name LIKE 'W%' UNION SELECT actors.name FROM 
actors WHERE actors.name LIKE 'W%';</code></pre>
      <p class="p">This example shows how to use a function in the <code class="ph codeph">FROM</code> clause, both with and
        without a column definition list: </p>

      <pre class="pre codeblock"><code>CREATE FUNCTION distributors(int) RETURNS SETOF distributors 
AS $$ SELECT * FROM distributors WHERE did = $1; $$ LANGUAGE 
SQL;
SELECT * FROM distributors(111);

CREATE FUNCTION distributors_2(int) RETURNS SETOF record AS 
$$ SELECT * FROM distributors WHERE did = $1; $$ LANGUAGE 
SQL;
SELECT * FROM distributors_2(111) AS (dist_id int, dist_name 
text);</code></pre>
      <p class="p">This example uses a simple <code class="ph codeph">WITH</code> clause:</p>

      <pre class="pre codeblock"><code>WITH test AS (
  SELECT random() as x FROM generate_series(1, 3)
  )
SELECT * FROM test
UNION ALL
SELECT * FROM test; </code></pre>
      <p class="p">This example uses the <code class="ph codeph">WITH</code> clause to display per-product sales totals in
        only the top sales regions. </p>

      <pre class="pre codeblock"><code>WITH regional_sales AS 
    SELECT region, SUM(amount) AS total_sales
    FROM orders
    GROUP BY region
  ), top_regions AS (
    SELECT region
    FROM regional_sales
    WHERE total_sales &gt; (SELECT SUM(total_sales) FROM
       regional_sales)
  )
SELECT region, product, SUM(quantity) AS product_units,
   SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions) 
GROUP BY region, product;</code></pre>
      <p class="p">The example could have been written without the <code class="ph codeph">WITH</code> clause but would have
        required two levels of nested sub-<code class="ph codeph">SELECT</code> statements.</p>

      <p class="p">This example uses the <code class="ph codeph">WITH RECURSIVE</code> clause to find all subordinates
        (direct or indirect) of the employee Mary, and their level of indirectness, from a table
        that shows only direct subordinates:</p>

      <pre class="pre codeblock"><code>WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (
    SELECT 1, employee_name, manager_name
    FROM employee
    WHERE manager_name = 'Mary'
  UNION ALL
    SELECT er.distance + 1, e.employee_name, e.manager_name
    FROM employee_recursive er, employee e
    WHERE er.employee_name = e.manager_name
  )
SELECT distance, employee_name FROM employee_recursive;</code></pre>
      <p class="p">The typical form of recursive queries: an initial condition, followed by <code class="ph codeph">UNION
          [ALL]</code>, followed by the recursive part of the query. Be sure that the recursive
        part of the query will eventually return no tuples, or else the query will loop
        indefinitely. See <a class="xref" href="../../admin_guide/query/topics/CTE-query.html#topic_zhs_r1s_w1b" target="_blank">WITH Queries (Common Table Expressions)
</a><span class="ph"> in the <cite class="cite">Greenplum Database Administrator Guide</cite></span> for
        more examples.</p>

    </div>

    <div class="section" id="topic1__section19"><h2 class="title sectiontitle">Compatibility</h2><p class="p">The <code class="ph codeph">SELECT</code> statement is
        compatible with the SQL standard, but there are some extensions and some missing features.
        </p>
<div class="sectiondiv" id="topic1__section20"><strong class="ph b">Omitted FROM Clauses</strong><p class="p">Greenplum Database allows one to omit the
            <code class="ph codeph">FROM</code> clause. It has a straightforward use to compute the results of
          simple expressions. For example:</p>
<pre class="pre codeblock"><code>SELECT 2+2;</code></pre><p class="p">Some other SQL
          databases cannot do this except by introducing a dummy one-row table from which to do the
            <code class="ph codeph">SELECT</code>. </p>
<div class="p">Note that if a <code class="ph codeph">FROM</code> clause is not
          specified, the query cannot reference any database tables. For example, the following
          query is
          invalid:<pre class="pre codeblock"><code>SELECT distributors.* WHERE distributors.name = 'Westward';</code></pre>In
          earlier releases, setting a server configuration parameter,
            <var class="keyword varname">add_missing_from</var>, to true allowed Greenplum Database to add an
          implicit entry to the query's <code class="ph codeph">FROM</code> clause for each table referenced by
          the query. This is no longer allowed. </div>
</div><div class="sectiondiv" id="topic1__section21"><strong class="ph b">Omitting the AS Key Word</strong><p class="p">In the SQL standard, the optional key
          word <code class="ph codeph">AS</code> can be omitted before an output column name whenever the new
          column name is a valid column name (that is, not the same as any reserved keyword).
          Greenplum Database is slightly more restrictive: <code class="ph codeph">AS</code> is required if the
          new column name matches any keyword at all, reserved or not. Recommended practice is to
          use <code class="ph codeph">AS</code> or double-quote output column names, to prevent any possible
          conflict against future keyword additions. </p>
<p class="p">In <code class="ph codeph">FROM</code> items, both the
          standard and Greenplum Database allow <code class="ph codeph">AS</code> to be omitted before an alias
          that is an unreserved keyword. But this is impractical for output column names, because of
          syntactic ambiguities.</p>
</div>
      <div class="sectiondiv" id="topic1__sectiondiv_ndj_ngd_cgb"><strong class="ph b">ONLY and Inheritance</strong><div class="p">The SQL standard
          requires parentheses around the table name when writing <code class="ph codeph">ONLY</code>, for
          example: <pre class="pre codeblock"><code>SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ...</code></pre>Greenplum
          Database considers these parentheses to be optional.</div>
<p class="p">Greenplum Database allows a
          trailing <code class="ph codeph">* </code>to be written to explicitly specify the
            non-<code class="ph codeph">ONLY</code> behavior of including child tables. The standard does not
          allow this.</p>
<p class="p">(These points apply equally to all SQL commands supporting the
            <code class="ph codeph">ONLY</code> option.)</p>
</div><div class="sectiondiv" id="topic1__section22"><strong class="ph b">Namespace Available to GROUP BY and ORDER BY</strong><p class="p">In the SQL-92
          standard, an <code class="ph codeph">ORDER BY</code> clause may only use output column names or numbers,
          while a <code class="ph codeph">GROUP BY</code> clause may only use expressions based on input column
          names. Greenplum Database extends each of these clauses to allow the other choice as well
          (but it uses the standard's interpretation if there is ambiguity). Greenplum Database also
          allows both clauses to specify arbitrary expressions. Note that names appearing in an
          expression are always taken as input-column names, not as output column names.
          </p>
<p class="p">SQL:1999 and later use a slightly different definition which is not entirely upward
          compatible with SQL-92. In most cases, however, Greenplum Database interprets an
            <code class="ph codeph">ORDER BY</code> or <code class="ph codeph">GROUP BY</code> expression the same way SQL:1999
          does. </p>
</div>
      <div class="sectiondiv"><strong class="ph b">Functional Dependencies</strong>
        <p class="p">Greenplum Database recognizes functional dependency
          (allowing columns to be omitted from <code class="ph codeph">GROUP BY</code>) only when
            a table's primary key is included in the <code class="ph codeph">GROUP BY</code> list.
              The SQL standard specifies additional conditions that should be
              recognized.</p>
</div>
      <div class="sectiondiv"><strong class="ph b">LIMIT and OFFSET</strong><p class="p">The clauses <code class="ph codeph">LIMIT</code> and
            <code class="ph codeph">OFFSET</code> are Greenplum Database-specific syntax, also used by MySQL. The
          SQL:2008 standard has introduced the clauses <code class="ph codeph">OFFSET .. FETCH {FIRST|NEXT}
            ...</code> for the same functionality, as shown above. This syntax is also used by IBM
          DB2. (Applications for Oracle frequently use a workaround involving the automatically
          generated <code class="ph codeph">rownum</code> column, which is not available in Greenplum Database, to
          implement the effects of these clauses.)</p>
</div>
      <div class="sectiondiv"><strong class="ph b">FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE, and FOR KEY SHARE</strong>
        <p class="p">Although <code class="ph codeph">FOR UPDATE</code> appears in the SQL standard, the standard allows it
          only as an option of <code class="ph codeph">DECLARE CURSOR</code>. Greenplum Database allows it in any
            <code class="ph codeph">SELECT</code> query as well as in sub-<code class="ph codeph">SELECT</code>s, but this is an
          extension. The <code class="ph codeph">FOR NO KEY UPDATE</code>, <code class="ph codeph">FOR SHARE</code>, and
            <code class="ph codeph">FOR KEY SHARE</code> variants, as well as the <code class="ph codeph">NOWAIT</code> option,
          do not appear in the standard. </p>
</div>
      <div class="sectiondiv"><strong class="ph b">Data-Modifying Statements in WITH</strong><p class="p">Greenplum Database allows <code class="ph codeph">INSERT</code>,
        <code class="ph codeph">UPDATE</code>, and <code class="ph codeph">DELETE</code> to be used as <code class="ph codeph">WITH</code>
          queries. This is not found in the SQL standard.</p>
</div>
      <div class="sectiondiv" id="topic1__section23"><strong class="ph b">Nonstandard Clauses</strong><p class="p">The clause <code class="ph codeph">DISTINCT ON</code> is
          not defined in the SQL standard.</p>
</div><div class="sectiondiv" id="topic1__section24"><strong class="ph b">Limited Use
          of STABLE and VOLATILE Functions</strong><p class="p">To prevent data from becoming out-of-sync across
          the segments in Greenplum Database, any function classified as <code class="ph codeph">STABLE</code> or
            <code class="ph codeph">VOLATILE</code> cannot be run at the segment database level if it
          contains SQL or modifies the database in any way. See <a class="xref" href="CREATE_FUNCTION.html#topic1">CREATE FUNCTION</a> for more
          information.</p>
</div></div>

    <div class="section" id="topic1__section25"><h2 class="title sectiontitle">See Also</h2>
      
      <p class="p"><a class="xref" href="EXPLAIN.html#topic1">EXPLAIN</a></p>

    </div>

  </div>

<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../sql_commands/sql_ref.html">SQL Commands</a></div>
</div>
</div></body>
</html>