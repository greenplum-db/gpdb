<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta name="copyright" content="(C) Copyright 2022" />
<meta name="DC.rights.owner" content="(C) Copyright 2022" />
<meta name="generator" content="DITA-OT" /><meta name="DC.type" content="topic" />
<meta name="DC.title" content="EXPLAIN" />
<meta name="DC.relation" scheme="URI" content="../sql_commands/sql_ref.html" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="topic1" />
<link rel="stylesheet" type="text/css" href="../commonltr.css" />
<title>EXPLAIN</title>
</head>
<body id="topic1">

  <h1 class="title topictitle1" id="topic1__dq20941">EXPLAIN</h1>

  <div class="body">
    <p class="p" id="topic1__sql_command_desc">Shows the query plan of a statement.</p>

    <div class="section" id="topic1__section2"><h2 class="title sectiontitle">Synopsis</h2>
      
      <pre class="pre codeblock" id="topic1__sql_command_synopsis"><code>EXPLAIN [ ( &lt;option&gt; [, ...] ) ] &lt;statement&gt;
EXPLAIN [ANALYZE] [VERBOSE] &lt;statement&gt;</code></pre>
      <div class="p">where <var class="keyword varname">option</var> can be one
        of:<pre class="pre codeblock"><code>    ANALYZE [ &lt;boolean&gt; ]
    VERBOSE [ &lt;boolean&gt; ]
    COSTS [ &lt;boolean&gt; ]
    BUFFERS [ &lt;boolean&gt; ]
    TIMING [ &lt;boolean&gt; ]
    FORMAT { TEXT | XML | JSON | YAML }</code></pre></div>

    </div>

    <div class="section" id="topic1__section3"><h2 class="title sectiontitle">Description</h2>
      
      <p class="p"><code class="ph codeph">EXPLAIN</code> displays the query plan that the Greenplum or Postgres Planner
        generates for the supplied statement. Query plans are a tree plan of nodes. Each node in the
        plan represents a single operation, such as table scan, join, aggregation or a sort.</p>

      <p class="p">Plans should be read from the bottom up as each node feeds rows into the node directly
        above it. The bottom nodes of a plan are usually table scan operations (sequential, index or
        bitmap index scans). If the query requires joins, aggregations, or sorts (or other
        operations on the raw rows) then there will be additional nodes above the scan nodes to
        perform these operations. The topmost plan nodes are usually the Greenplum Database motion
        nodes (redistribute, explicit redistribute, broadcast, or gather motions). These are the
        operations responsible for moving rows between the segment instances during query
        processing.</p>

      <p class="p">The output of <code class="ph codeph">EXPLAIN</code> has one line for each node in the plan tree, showing
        the basic node type plus the following cost estimates that the planner made for the
        execution of that plan node:</p>

      <ul class="ul">
        <li class="li" id="topic1__dq155475"><strong class="ph b">cost</strong> — the planner's guess at how long it will take to run the
          statement (measured in cost units that are arbitrary, but conventionally
          mean disk page fetches). Two cost numbers
          are shown: the start-up cost before the first row can be returned, and
          the total cost to return all the rows. Note that the total cost assumes that all
          rows will be retrieved, which may not always be the case (if using <code class="ph codeph">LIMIT</code>
          for example).</li>

        <li class="li" id="topic1__dq155476"><strong class="ph b">rows</strong> — the total number of rows output by this plan node. This is
          usually less than the actual number of rows processed or scanned by the plan node,
          reflecting the estimated selectivity of any <code class="ph codeph">WHERE</code> clause conditions.
          Ideally the top-level nodes estimate will approximate the number of rows actually
          returned, updated, or deleted by the query.</li>

        <li class="li" id="topic1__dq155477"><strong class="ph b">width</strong> — total bytes of all the rows output by this plan node.</li>

      </ul>

      <p class="p">It is important to note that the cost of an upper-level node includes the cost of all its
        child nodes. The topmost node of the plan has the estimated total execution cost for the
        plan. This is this number that the planner seeks to minimize. It is also important to
        realize that the cost only reflects things that the query optimizer cares about. In
        particular, the cost does not consider the time spent transmitting result rows to the
        client.</p>

      <p class="p"><code class="ph codeph">EXPLAIN ANALYZE</code> causes the statement to be actually run, not only
        planned. The <code class="ph codeph">EXPLAIN ANALYZE</code> plan shows the actual results along with the
        planner's estimates. This is useful for seeing whether the planner's estimates are close to
        reality. In addition to the information shown in the <code class="ph codeph">EXPLAIN</code> plan,
          <code class="ph codeph">EXPLAIN ANALYZE</code> will show the following additional information:</p>

      <ul class="ul">
        <li class="li" id="topic1__dq155498">The total elapsed time (in milliseconds) that it took to run the
          query.</li>

        <li class="li" id="topic1__dq155499">The number of <em class="ph i">workers</em> (segments) involved in a plan node operation.
          Only segments that return rows are counted.</li>

        <li class="li" id="topic1__dq155500">The maximum number of rows returned by the segment that produced the most
          rows for an operation. If multiple segments produce an equal number of rows, the one with
          the longest <em class="ph i">time to end</em> is the one chosen.</li>

        <li class="li" id="topic1__dq155501">The segment id number of the segment that produced the most rows for an
          operation.</li>

        <li class="li" id="topic1__dq155554">For relevant operations, the <var class="keyword varname">work_mem</var> used by the
          operation. If <code class="ph codeph">work_mem</code> was not sufficient to perform the operation in
          memory, the plan will show how much data was spilled to disk and how many passes over the
          data were required for the lowest performing segment. For
          example:<pre class="pre codeblock"><code>Work_mem used: 64K bytes avg, 64K bytes max (seg0).
Work_mem wanted: 90K bytes avg, 90K bytes max (seg0) to abate workfile 
I/O affecting 2 workers.
[seg0] pass 0: 488 groups made from 488 rows; 263 rows written to 
workfile
[seg0] pass 1: 263 groups made from 263 rows</code></pre></li>

        <li class="li" id="topic1__dq155502">The time (in milliseconds) it took to retrieve the first row from the
          segment that produced the most rows, and the total time taken to retrieve all rows from
          that segment. The <em class="ph i">&lt;time&gt; to first row</em> may be omitted if it is the same as the
            <em class="ph i">&lt;time&gt; to end</em>.</li>

      </ul>

      <div class="note important"><span class="importanttitle">Important:</span> Keep in mind that the statement is actually run when
          <code class="ph codeph">ANALYZE</code> is used. Although <code class="ph codeph">EXPLAIN ANALYZE</code> will discard
        any output that a <code class="ph codeph">SELECT</code> would return, other side effects of the statement
        will happen as usual. If you wish to use <code class="ph codeph">EXPLAIN ANALYZE</code> on a DML statement
        without letting the command affect your data, use this
        approach:<pre class="pre codeblock"><code>BEGIN;
EXPLAIN ANALYZE ...;
ROLLBACK;</code></pre></div>

      <p class="p">Only the <code class="ph codeph">ANALYZE</code> and <code class="ph codeph">VERBOSE</code> options can be specified,
        and only in that order, without surrounding the option list in parentheses.</p>

    </div>

    <div class="section" id="topic1__section4"><h2 class="title sectiontitle">Parameters</h2>
      
      <dl class="dl parml">
        
          <dt class="dt pt dlterm">ANALYZE</dt>

          <dd class="dd pd">Carry out the command and show the actual run times and other statistics. This
            parameter defaults to <code class="ph codeph">FALSE</code> if you omit it; specify <code class="ph codeph">ANALYZE
              true</code> to enable it. </dd>

        
        
          <dt class="dt pt dlterm">VERBOSE</dt>

          <dd class="dd pd">Display additional information regarding the plan. Specifically, include the output
            column list for each node in the plan tree, schema-qualify table and function names,
            always label variables in expressions with their range table alias, and always print the
            name of each trigger for which statistics are displayed. This parameter defaults to
              <code class="ph codeph">FALSE</code>if you omit it; specify <code class="ph codeph">VERBOSE true</code> to enable
            it.</dd>

        
        
          <dt class="dt pt dlterm">COSTS</dt>

          <dd class="dd pd">Include information on the estimated startup and total cost of each plan node, as well
            as the estimated number of rows and the estimated width of each row. This parameter
            defaults to <code class="ph codeph">TRUE</code> if you omit it; specify <code class="ph codeph">COSTS false</code>
            to disable it.</dd>

        
        
          <dt class="dt pt dlterm">BUFFERS</dt>

          <dd class="dd pd">Include information on buffer usage. Specifically, include the number of shared blocks
            hit, read, dirtied, and written, the number of local blocks hit, read, dirtied, and
            written, and the number of temp blocks read and written. A <em class="ph i">hit</em> means that a read
            was avoided because the block was found already in cache when needed. Shared blocks
            contain data from regular tables and indexes; local blocks contain data from temporary
            tables and indexes; while temp blocks contain short-term working data used in sorts,
            hashes, Materialize plan nodes, and similar cases. The number of blocks <em class="ph i">dirtied</em>
            indicates the number of previously unmodified blocks that were changed by this query;
            while the number of blocks <em class="ph i">written</em> indicates the number of previously-dirtied
            blocks evicted from cache by this backend during query processing. The number of blocks
            shown for an upper-level node includes those used by all its child nodes. In text
            format, only non-zero values are printed. This parameter may only be used when
              <code class="ph codeph">ANALYZE</code> is also enabled. This parameter defaults to <code class="ph codeph">FALSE</code>
            if you omit it; specify <code class="ph codeph">BUFFERS true</code> to enable it.</dd>

        
        
          <dt class="dt pt dlterm">TIMING</dt>

          <dd class="dd pd">Include actual startup time and time spent in each node in the output. The overhead of
            repeatedly reading the system clock can slow down the query significantly on some
            systems, so it may be useful to set this parameter to <code class="ph codeph">FALSE</code> when only
            actual row counts, and not exact times, are needed. Run time of the entire statement is
            always measured, even when node-level timing is turned off with this option. This
            parameter may only be used when <code class="ph codeph">ANALYZE</code> is also enabled. It defaults to
              <code class="ph codeph">TRUE</code>. </dd>

        
        
          <dt class="dt pt dlterm">FORMAT</dt>

          <dd class="dd pd">Specify the output format, which can be <code class="ph codeph">TEXT</code>, <code class="ph codeph">XML</code>,
              <code class="ph codeph">JSON</code>, or <code class="ph codeph">YAML</code>. Non-text output contains the same
            information as the text output format, but is easier for programs to parse. This
            parameter defaults to <code class="ph codeph">TEXT</code>.</dd>

        
        
          <dt class="dt pt dlterm"><var class="keyword varname">boolean</var></dt>

          <dd class="dd pd">Specifies whether the selected option should be turned on or off. You can write
              <code class="ph codeph">TRUE</code>, <code class="ph codeph">ON</code>, or <code class="ph codeph">1</code> to enable the
            option, and <code class="ph codeph">FALSE</code>, <code class="ph codeph">OFF</code>, or <code class="ph codeph">0</code> to
            disable it. The boolean value can also be omitted, in which case <code class="ph codeph">TRUE</code>
            is assumed.</dd>

        
        
          <dt class="dt pt dlterm"><var class="keyword varname">statement</var></dt>

          <dd class="dd pd">Any <code class="ph codeph">SELECT</code>, <code class="ph codeph">INSERT</code>, <code class="ph codeph">UPDATE</code>,
              <code class="ph codeph">DELETE</code>, <code class="ph codeph">VALUES</code>, <code class="ph codeph">EXECUTE</code>,
              <code class="ph codeph">DECLARE</code>, or <code class="ph codeph">CREATE TABLE AS</code> statement, whose
            execution plan you wish to see.</dd>

        
      </dl>

    </div>

    <div class="section" id="topic1__section5"><h2 class="title sectiontitle">Notes</h2><p class="p">In order to allow the query optimizer to make
        reasonably informed decisions when optimizing queries, the <code class="ph codeph">ANALYZE</code>
        statement should be run to record statistics about the distribution of data within the
        table. If you have not done this (or if the statistical distribution of the data in the
        table has changed significantly since the last time <code class="ph codeph">ANALYZE</code> was run), the
        estimated costs are unlikely to conform to the real properties of the query, and
        consequently an inferior query plan may be chosen.</p>
An SQL statement that is run during
      the execution of an <code class="ph codeph">EXPLAIN ANALYZE</code> command is excluded from Greenplum
      Database resource queues.<p class="p">For more information about query profiling, see "Query Profiling"
        in the <cite class="cite">Greenplum Database Administrator Guide</cite>. For more information about
        resource queues, see "Resource Management with Resource Queues" in the <cite class="cite">Greenplum
          Database Administrator Guide</cite>.</p>
</div>

    <div class="section" id="topic1__section6"><h2 class="title sectiontitle">Examples</h2>
      
      <p class="p">To illustrate how to read an <code class="ph codeph">EXPLAIN</code> query plan, consider the following
        example for a very simple query:</p>

      <pre class="pre codeblock"><code>EXPLAIN SELECT * FROM names WHERE name = 'Joelle';
                                  QUERY PLAN
-------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..431.27 rows=1 width=58)
   -&gt;  Seq Scan on names  (cost=0.00..431.27 rows=1 width=58)
         Filter: (name = 'Joelle'::text)
 Optimizer: Pivotal Optimizer (GPORCA) version 3.23.0
(4 rows)</code></pre>

      <p class="p">If we read the plan from the bottom up, the query optimizer starts by doing a sequential
        scan of the <code class="ph codeph">names</code> table. Notice that the <code class="ph codeph">WHERE</code> clause is
        being applied as a <em class="ph i">filter</em> condition. This means that the scan operation checks the
        condition for each row it scans, and outputs only the ones that pass the condition. </p>

      <p class="p">The results of the scan operation are passed up to a <em class="ph i">gather motion</em> operation. In
        Greenplum Database, a gather motion is when segments send rows up to the master. In this
        case we have 3 segment instances sending to 1 master instance (3:1). This operation is
        working on <code class="ph codeph">slice1</code> of the parallel query execution plan. In Greenplum
        Database a query plan is divided into <em class="ph i">slices</em> so that portions of the query plan can
        be worked on in parallel by the segments.</p>

      <p class="p">The estimated startup cost for this plan is <code class="ph codeph">00.00</code> (no cost) and a total
        cost of <code class="ph codeph">431.27</code>. The planner is estimating that this query will return one
        row.</p>

      <p class="p">Here is the same query, with cost estimates suppressed:</p>

      <pre class="pre codeblock"><code>EXPLAIN (COSTS FALSE) SELECT * FROM names WHERE name = 'Joelle';
                QUERY PLAN
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   -&gt;  Seq Scan on names
         Filter: (name = 'Joelle'::text)
 Optimizer: Pivotal Optimizer (GPORCA) version 3.23.0
(4 rows)</code></pre> 

      <p class="p">Here is the same query, with JSON formatting:</p>

      <pre class="pre codeblock"><code>EXPLAIN (FORMAT JSON) SELECT * FROM names WHERE name = 'Joelle';
                  QUERY PLAN
-----------------------------------------------
 [                                            +
   {                                          +
     "Plan": {                                +
       "Node Type": "Gather Motion",          +
       "Senders": 3,                          +
       "Receivers": 1,                        +
       "Slice": 1,                            +
       "Segments": 3,                         +
       "Gang Type": "primary reader",         +
       "Startup Cost": 0.00,                  +
       "Total Cost": 431.27,                  +
       "Plan Rows": 1,                        +
       "Plan Width": 58,                      +
       "Plans": [                             +
         {                                    +
           "Node Type": "Seq Scan",           +
           "Parent Relationship": "Outer",    +
           "Slice": 1,                        +
           "Segments": 3,                     +
           "Gang Type": "primary reader",     +
           "Relation Name": "names",          +
           "Alias": "names",                  +
           "Startup Cost": 0.00,              +
           "Total Cost": 431.27,              +
           "Plan Rows": 1,                    +
           "Plan Width": 58,                  +
           "Filter": "(name = 'Joelle'::text)"+
         }                                    +
       ]                                      +
     },                                       +
     "Settings": {                            +
       "Optimizer": "Pivotal Optimizer (GPORCA) version 3.23.0"      +
     }                                        +
   }                                          +
 ]
(1 row)</code></pre>
      <div class="p">If there is an index and we use a query with an indexable <code class="ph codeph">WHERE</code> condition,
          <code class="ph codeph">EXPLAIN</code> might show a different plan. This query generates a plan with an
        index scan, with YAML
        formatting:<pre class="pre codeblock"><code>EXPLAIN (FORMAT YAML) SELECT * FROM NAMES WHERE LOCATION='Sydney, Australia';
                          QUERY PLAN
--------------------------------------------------------------
 - Plan:                                                     +
     Node Type: "Gather Motion"                              +
     Senders: 3                                              +
     Receivers: 1                                            +
     Slice: 1                                                +
     Segments: 3                                             +
     Gang Type: "primary reader"                             +
     Startup Cost: 0.00                                      +
     Total Cost: 10.81                                       +
     Plan Rows: 10000                                        +
     Plan Width: 70                                          +
     Plans:                                                  +
       - Node Type: "Index Scan"                             +
         Parent Relationship: "Outer"                        +
         Slice: 1                                            +
         Segments: 3                                         +
         Gang Type: "primary reader"                         +
         Scan Direction: "Forward"                           +
         Index Name: "names_idx_loc"                         +
         Relation Name: "names"                              +
         Alias: "names"                                      +
         Startup Cost: 0.00                                  +
         Total Cost: 7.77                                    +
         Plan Rows: 10000                                    +
         Plan Width: 70                                      +
         Index Cond: "(location = 'Sydney, Australia'::text)"+
   Settings:                                                 +
     Optimizer: "Pivotal Optimizer (GPORCA) version 3.23.0"
(1 row)</code></pre></div>
    </div>

    <div class="section" id="topic1__section7"><h2 class="title sectiontitle">Compatibility</h2>
      
      <p class="p">There is no <code class="ph codeph">EXPLAIN</code> statement defined in the SQL standard.</p>

    </div>

    <div class="section" id="topic1__section8"><h2 class="title sectiontitle">See Also</h2>
      
      <p class="p"><a class="xref" href="ANALYZE.html#topic1">ANALYZE</a></p>

    </div>

  </div>

<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../sql_commands/sql_ref.html">SQL Commands</a></div>
</div>
</div></body>
</html>