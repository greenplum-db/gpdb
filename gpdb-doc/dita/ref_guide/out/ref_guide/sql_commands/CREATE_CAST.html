<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta name="copyright" content="(C) Copyright 2022" />
<meta name="DC.rights.owner" content="(C) Copyright 2022" />
<meta name="generator" content="DITA-OT" /><meta name="DC.type" content="topic" />
<meta name="DC.title" content="CREATE CAST" />
<meta name="DC.relation" scheme="URI" content="../sql_commands/sql_ref.html" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="topic1" />
<link rel="stylesheet" type="text/css" href="../commonltr.css" />
<title>CREATE CAST</title>
</head>
<body id="topic1">
<h1 class="title topictitle1" id="topic1__bn20941">CREATE CAST</h1>
<div class="body"><p class="p" id="topic1__sql_command_desc">Defines a new cast.</p>
<div class="section" id="topic1__section2"><h2 class="title sectiontitle">Synopsis</h2><pre class="pre codeblock" id="topic1__sql_command_synopsis"><code>CREATE CAST (&lt;sourcetype&gt; AS &lt;targettype&gt;) 
       WITH FUNCTION &lt;funcname&gt; (&lt;argtype&gt; [, ...]) 
       [AS ASSIGNMENT | AS IMPLICIT]

CREATE CAST (&lt;sourcetype&gt; AS &lt;targettype&gt;)
       WITHOUT FUNCTION 
       [AS ASSIGNMENT | AS IMPLICIT]

CREATE CAST (&lt;sourcetype&gt; AS &lt;targettype&gt;)
       WITH INOUT 
       [AS ASSIGNMENT | AS IMPLICIT]</code></pre></div>

    <div class="section" id="topic1__section3"><h2 class="title sectiontitle">Description</h2><p class="p"><code class="ph codeph">CREATE CAST</code> defines a new
        cast. A cast specifies how to perform a conversion between two data types. For
        example,</p>
<pre class="pre codeblock"><code>SELECT CAST(42 AS float8);</code></pre><p class="p">converts the integer
        constant <code class="ph codeph">42</code> to type <code class="ph codeph">float8</code> by invoking a previously
        specified function, in this case <code class="ph codeph">float8(int4)</code>. If no suitable cast has been
        defined, the conversion fails. </p>
<p class="p">Two types may be binary coercible, which means that
        the types can be converted into one another without invoking any function. This requires
        that corresponding values use the same internal representation. For instance, the types
          <code class="ph codeph">text</code> and <code class="ph codeph">varchar</code> are binary coercible in both
        directions. Binary coercibility is not necessarily a symmetric relationship. For example,
        the cast from <code class="ph codeph">xml</code> to <code class="ph codeph">text</code> can be performed for free in the
        present implementation, but the reverse direction requires a function that performs at least
        a syntax check. (Two types that are binary coercible both ways are also referred to as
        binary compatible.)</p>

      <p class="p">You can define a cast as an <em class="ph i">I/O conversion cast</em> by using the <code class="ph codeph">WITH
          INOUT</code> syntax. An I/O conversion cast is performed by invoking the output function
        of the source data type, and passing the resulting string to the input function of the
        target data type. In many common cases, this feature avoids the need to write a separate
        cast function for conversion. An I/O conversion cast acts the same as a regular
        function-based cast; only the implementation is different.</p>

      <p class="p">By default, a cast can be invoked only by an explicit cast request, that is an explicit
          <code class="ph codeph">CAST(x AS </code>
        <var class="keyword varname">typename</var><code class="ph codeph">)</code> or <code class="ph codeph">x::
          <var class="keyword varname">typename</var></code> construct.</p>
<p class="p">If the cast is marked <code class="ph codeph">AS
          ASSIGNMENT</code> then it can be invoked implicitly when assigning a value to a column
        of the target data type. For example, supposing that <code class="ph codeph">foo.f1</code> is a column of
        type <code class="ph codeph">text</code>,
        then:</p>
<pre class="pre codeblock"><code>INSERT INTO foo (f1) VALUES (42);</code></pre><p class="p">will be allowed if the
        cast from type <code class="ph codeph">integer</code> to type <code class="ph codeph">text</code> is marked <code class="ph codeph">AS
          ASSIGNMENT</code>, otherwise not. The term <em class="ph i">assignment cast</em> is typically used to
        describe this kind of cast.</p>
<p class="p">If the cast is marked <code class="ph codeph">AS IMPLICIT</code> then it
        can be invoked implicitly in any context, whether assignment or internally in an expression.
        The term <em class="ph i">implicit cast</em> is typically used to describe this kind of cast. For example,
        consider this query:</p>

      <pre class="pre codeblock"><code>SELECT 2 + 4.0;</code></pre><p class="p">The parser initially marks the constants as being of
        type <code class="ph codeph">integer</code> and <code class="ph codeph">numeric</code>, respectively. There is no
          <code class="ph codeph">integer + numeric</code> operator in the system catalogs, but there is a
          <code class="ph codeph">numeric + numeric</code> operator. This query succeeds if a cast from
          <code class="ph codeph">integer</code> to <code class="ph codeph">numeric</code> exists (it does) and is marked
          <code class="ph codeph">AS IMPLICIT</code>, which in fact it is. The parser applies only the implicit
        cast and resolves the query as if it had been written as the following:</p>

      <pre class="pre codeblock"><code>SELECT CAST ( 2 AS numeric ) + 4.0;</code></pre>
      <p class="p">The catalogs also provide a cast from <code class="ph codeph">numeric</code> to <code class="ph codeph">integer</code>.
        If that cast were marked <code class="ph codeph">AS IMPLICIT</code>, which it is not, then the parser
        would be faced with choosing between the above interpretation and the alternative of casting
        the <code class="ph codeph">numeric</code> constant to <code class="ph codeph">integer</code> and applying the
          <code class="ph codeph">integer + integer</code> operator. Lacking any knowledge of which choice to
        prefer, the parser would give up and declare the query ambiguous. The fact that only one of
        the two casts is implicit is the way in which we teach the parser to prefer resolution of a
        mixed <code class="ph codeph">numeric</code>-and-<code class="ph codeph">integer</code> expression as
          <code class="ph codeph">numeric</code>; the parser has no built-in knowledge about that.</p>

      <p class="p">It is wise to be conservative about marking casts as implicit. An overabundance of implicit
        casting paths can cause Greenplum Database to choose surprising interpretations of commands,
        or to be unable to resolve commands at all because there are multiple possible
        interpretations. A good general rule is to make a cast implicitly invokable only for
        information-preserving transformations between types in the same general type category. For
        example, the cast from <code class="ph codeph">int2</code> to <code class="ph codeph">int4</code> can reasonably be
        implicit, but the cast from <code class="ph codeph">float8</code> to <code class="ph codeph">int4</code> should probably
        be assignment-only. Cross-type-category casts, such as <code class="ph codeph">text</code> to
          <code class="ph codeph">int4</code>, are best made explicit-only. </p>

      <div class="note"><span class="notetitle">Note:</span> Sometimes it is necessary for usability or standards-compliance reasons to provide
        multiple implicit casts among a set of types, resulting in ambiguity that cannot be avoided
        as described above. The parser uses a fallback heuristic based on type categories and
        preferred types that helps to provide desired behavior in such cases. See <a class="xref" href="CREATE_TYPE.html#topic1">CREATE TYPE</a> for more
        information.</div>

      <p class="p">To be able to create a cast, you must own the source or the target data type and have
          <code class="ph codeph">USAGE</code> privilege on the other type. To create a binary-coercible cast, you
        must be superuser. (This restriction is made because an erroneous binary-coercible cast
        conversion can easily crash the server.)</p>
</div>

<div class="section" id="topic1__section4"><h2 class="title sectiontitle">Parameters</h2><dl class="dl parml"><dt class="dt pt dlterm"><var class="keyword varname">sourcetype</var></dt>
<dd class="dd pd">The name of the source data type of the cast. </dd>
<dt class="dt pt dlterm"><var class="keyword varname">targettype</var></dt>
<dd class="dd pd">The name of the target data type of the cast. </dd>
<dt class="dt pt dlterm"><var class="keyword varname">funcname</var>(<var class="keyword varname">argtype</var> [, ...])</dt>

  <dd class="dd pd">The function used to perform the cast. The function name may be schema-qualified.
If it is not, Greenplum Database looks for the function in the schema search path.
The function's result data type must match the target type of the cast.</dd>
<dd class="dd pd ddexpand">Cast implementation functions may have one to three arguments. The first argument type must be
            identical to or binary-coercible from the cast's source type. The second
            argument, if present, must be type
              <code class="ph codeph">integer</code>; it receives the type modifier associated with the
            destination type, or <code class="ph codeph">-1</code> if there is none. The third argument, if
            present, must be type <code class="ph codeph">boolean</code>; it receives <code class="ph codeph">true</code> if the
            cast is an explicit cast, <code class="ph codeph">false</code> otherwise. The SQL specification
            demands different behaviors for explicit and implicit casts in some cases. This argument
            is supplied for functions that must implement such casts. It is not recommended that you
            design your own data types this way.</dd>
<dd class="dd pd ddexpand">The return type of a cast function must be identical to or binary-coercible to the cast's target type.</dd>
<dd class="dd pd ddexpand">Ordinarily a cast must have different source and target data types.
However, you are permitted to declare a cast with identical source and target
types if it has a cast implementation function that takes more than one argument.
This is used to represent type-specific length coercion functions in
the system catalogs. The named function is used to coerce a value of
the type to the type modifier value given by its second argument.
</dd>
<dd class="dd pd ddexpand">When a cast has different source and target types and a function
that takes more than one argument, the cast converts from one
type to another and applies a length coercion in a single step. When
no such entry is available, coercion to a type that uses a type modifier
involves two steps, one to convert between data types and a second to
apply the modifier.</dd>

          <dd class="dd pd ddexpand">A cast to or from a domain type currently has no effect. Casting to or from a domain
            uses the casts associated with its underlying type. </dd>

    <dt class="dt pt dlterm">WITHOUT FUNCTION</dt>
<dd class="dd pd">Indicates that the source type is binary-coercible to the target type,
so no function is required to perform the cast.</dd>

    <dt class="dt pt dlterm">WITH INOUT</dt>
<dd class="dd pd">Indicates that the cast is an I/O conversion
      cast, performed by invoking the output function of the source data type,
      and passing the resulting string to the input function of the target data type.</dd>

    <dt class="dt pt dlterm">AS ASSIGNMENT</dt>
<dd class="dd pd">Indicates that the cast may be invoked implicitly in assignment contexts.</dd>

    <dt class="dt pt dlterm">AS IMPLICIT</dt>
<dd class="dd pd">Indicates that the cast may be invoked implicitly in any context.</dd>
</dl>
</div>
<div class="section" id="topic1__section5"><h2 class="title sectiontitle">Notes</h2><p class="p">Note that in this release of Greenplum Database, user-defined functions
used in a user-defined cast must be defined as <code class="ph codeph">IMMUTABLE</code>.
Any compiled code (shared library files) for custom functions must be
placed in the same location on every host in your Greenplum Database
array (master and all segments). This location must also be in the <code class="ph codeph">LD_LIBRARY_PATH</code>
so that the server can locate the files.</p>
<p class="p">Remember that if you want to be able to convert types both ways you
need to declare casts both ways explicitly. </p>

  <p class="p">It is normally not necessary to create casts between user-defined types
    and the standard string types (<code class="ph codeph">text</code>, <code class="ph codeph">varchar</code>,
    and <code class="ph codeph">char(<em class="ph i">n</em>)</code>, as well as user-defined types that
    are defined to be in the string category). Greenplum Database provides
    automatic I/O conversion casts for these. The automatic casts to string
    types are treated as assignment casts, while the automatic casts from
    string types are explicit-only. You can override this behavior by
    declaring your own cast to replace an automatic cast, but usually the
    only reason to do so is if you want the conversion to be more easily
    invokable than the standard assignment-only or explicit-only setting.
    Another possible reason is that you want the conversion to behave
    differently from the type's I/O function - think twice before doing this.
    (A small number of the built-in types do indeed have different behaviors
     for conversions, mostly because of requirements of the SQL standard.)</p>

  <p class="p">It is recommended that you follow the convention of naming cast implementation functions after
        the target data type, as the built-in cast implementation functions are named. Many users
        are used to being able to cast data types using a function-style notation, that is
            <code class="ph codeph"><var class="keyword varname">typename</var>(x)</code>.</p>

  <p class="p">There are two cases in which a function-call construct is treated as
    a cast request without having matched it to an actual function. If a
    function call <code class="ph codeph"><em class="ph i">name(x)</em></code> does not exactly match
    any existing function, but <code class="ph codeph"><em class="ph i">name</em></code> is the name of
    a data type and <code class="ph codeph">pg_cast</code> provides a binary-coercible
    cast to this type from the type of <code class="ph codeph"><em class="ph i">x</em></code>, then the
    call will be construed as a binary-coercible cast. Greenplum Database
    makes this exception so that binary-coercible casts can be invoked
    using functional syntax, even though they lack any function. Likewise,
    if there is no <code class="ph codeph">pg_cast</code> entry but the cast would be to
    or from a string type, the call is construed as an I/O conversion cast.
    This exception allows I/O conversion casts to be invoked using functional syntax.</p>

  <p class="p">There is an exception to the exception above: I/O conversion casts from
    composite types to string types cannot be invoked using functional
    syntax, but must be written in explicit cast syntax (either <code class="ph codeph">CAST</code> or
    :: notation). This exception exists because after the introduction
    of automatically-provided I/O conversion casts, it was found to be too
    easy to accidentally invoke such a cast when you intended a function or column
    reference.</p>
</div>

<div class="section" id="topic1__section6"><h2 class="title sectiontitle">Examples</h2><p class="p">To create an assignment cast from type <code class="ph codeph">bigint</code> to type <code class="ph codeph">int4</code> using the function
          <code class="ph codeph">int4(bigint)</code> (This cast is already predefined in the system.):</p>
<pre class="pre codeblock"><code>CREATE CAST (bigint AS int4) WITH FUNCTION int4(bigint) AS ASSIGNMENT;</code></pre></div>
<div class="section" id="topic1__section7"><h2 class="title sectiontitle">Compatibility</h2><p class="p">The <code class="ph codeph">CREATE CAST</code> command conforms to the SQL standard,
except that SQL does not make provisions for binary-coercible types
or extra arguments to implementation functions. <code class="ph codeph">AS IMPLICIT</code>
is a Greenplum Database extension, too.</p>
</div>
<div class="section" id="topic1__section8"><h2 class="title sectiontitle">See Also</h2><p class="p"><a class="xref" href="CREATE_FUNCTION.html#topic1">CREATE FUNCTION</a>,
            <a class="xref" href="CREATE_TYPE.html#topic1">CREATE TYPE</a>,
            <a class="xref" href="DROP_CAST.html#topic1">DROP CAST</a></p>
</div>
</div>
<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../sql_commands/sql_ref.html">SQL Commands</a></div>
</div>
</div></body>
</html>