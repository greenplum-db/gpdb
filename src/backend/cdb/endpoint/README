src/backend/cdb/endpoint/README

With the size of greenplum cluster increasing, the performance bottleneck on the
master node becomes more and more obvious.

The parallel retrieve cursor feature is designed to reduce the heavy
burdens of the master node. For a query, it can redirect the results to segments 
instead of gathering them to the master node. When it is executed, user can setup 
retrieve mode connections to segments for retrieving result data in parallel.


Parallel Retrieve Cursor
========================

Like a normal cursor, user can declare a parallel retrieve cursor on
master, then retrieve the query results on each segment directly.

Parallel retrieve cursor has similar declaration and syntax as
normal cursor does. However, some cursor operations are not supported
in parallel retrieve cursor(e.g. MOVE).

#NOTE: Orca doesn't support PARALLEL RETRIEVE CURSOR for now. It should
fall back to postgres optimizer.

Endpoint
========

Once a parallel retrieve cursor has been declared on QD, a corresponding
endpoint will be created on each QE which contains the query result.
Then, those endpoints can be used as the source, and results can be retrieved 
from them in parallel on each QE.


Declare Parallel Retrieve Cursor
================================

Before retrieving data from endpoints in parallel, a parallel retrieve cursor
variable needs to be created alongside with the query statement.

Syntax:
DECLARE cursor_name PARALLEL RETRIEVE CURSOR FOR query;

The cursor_name needs to be unique in current transaction.

Examples:

postgres=# BEGIN;
BEGIN
postgres=# DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE


List Parallel Retrieve Cursors and their endpoints
==================================================

To retrieve the query results of a parallel retrieve cursor, the related
endpoint information is needed before start a retrieve session on QEs. The UDF
gp_endpoints_info(boolean) can be used to list parallel
retrieve cursors and their endpoints information.

Syntax:
gp_endpoints_info(is_for_all_session)

When is_for_all_session is false, only parallel retrieve cursors created in
current session will be listed. Otherwise, all parallel retrieve
cursors created by this user will be listed.

For a superuser, it can list all endpoints info of all users', but for
non-superuser, it can only list the current user's endpoints info for
security reason.

gp_endpoints_info Columns:
|-------------+-----------+------------------------------------------|
| Column Name | Data Type | Description                              |
|-------------+-----------+------------------------------------------|
| auth_token  | text      | Retrieve session authentication token    |
|-------------+-----------+------------------------------------------|
| cursorname  | text      | Parallel retrieve cursor name            |
|-------------+-----------+------------------------------------------|
| sessionid   | integer   | The session where the cursor created in  |
|-------------+-----------+------------------------------------------|
| hostname    | text      | The host to retrieve from                |
|-------------+-----------+------------------------------------------|
| port        | integer   | The port number to start the retrieve    |
|             |           | session                                  |
|-------------+-----------+------------------------------------------|
| dbid        | integer   | The QE's segment id                      |
|-------------+-----------+------------------------------------------|
| userid      | oid       | The oid of the session user              |
|-------------+-----------+------------------------------------------|
| status      | text      | One of the following status for this     |
|             |           | endpoint:                                |
|             |           | READY:                                   |
|             |           | The endpoint is ready to be retrieved    |
|             |           | RETRIEVING:                              |
|             |           | The endpoint is being retrieved          |
|             |           | FINISHED:                                |
|             |           | The endpoint has been fully retrieved    |
|             |           | RELEASED:                                |
|             |           | Due to errors, this endpoint has been    |
|             |           | released and cannot be connected anymore |
|-------------+-----------+------------------------------------------|
| endpoint    | text      | The identification of this endpoint      |
|-------------+-----------+------------------------------------------|

Examples:

postgres=# SELECT * from gp_endpoints_info(false);
              auth_token            | cursorname | sessionid | hostname | port  | dbid | userid | status |     endpointname
------------------------------------+------------+-----------+----------+-------+------+--------+--------+----------------------
 tk071500004015dc6da471b20417afed65 | c1         |      5383 | mdw      | 25432 |    2 |     10 | READY  | c1_00001507_00000000
 tk1903000016d13df15aab23265ce70de1 | c1         |      5383 | mdw      | 25433 |    3 |     10 | READY  | c1_00001507_00000001
 tk19030000313f450b16bcef3f196e7e47 | c1         |      5383 | mdw      | 25434 |    4 |     10 | READY  | c1_00001507_00000002
(3 rows)

For convenience, a view named GP_ENDPOINTS can also be used to list endpoints in current session, which is equivalence to gp_endpoints_info(false).

Examples:

postgres=# SELECT * from GP_ENDPOINTS;
              auth_token            | cursorname | sessionid | hostname | port  | dbid | userid | status |     endpointname
------------------------------------+------------+-----------+----------+-------+------+--------+--------+----------------------
 tk071500004015dc6da471b20417afed65 | c1         |      5383 | mdw      | 25432 |    2 |     10 | READY  | c1_00001507_00000000
 tk1903000016d13df15aab23265ce70de1 | c1         |      5383 | mdw      | 25433 |    3 |     10 | READY  | c1_00001507_00000001
 tk19030000313f450b16bcef3f196e7e47 | c1         |      5383 | mdw      | 25434 |    4 |     10 | READY  | c1_00001507_00000002
(3 rows)

The userid of the endpoint is the session user, not the current user. For example, 
if login the database with "user1", then set role to another user "user2" and declare a parallel retrieve cursor.
The userid of these endpoints is "user1" 's oid, not "user2". The session user should be used to start
a retrieve connection. 

Start A Retrieve Session
========================

Once a parallel retrieve cursor has been declared, retrieve sessions can
be started on each endpoint's host by using the endpoint's token as the
session authentication password. The user of this retrieve session is the session user 
who declares this parallel retrieve cursor. 
 
Parameter "gp_role=retrieve" needs to be provided to start retrieve
session.

Examples:

$> PGOPTIONS="-c gp_role=retrieve" psql -h mdw -p 25432 -d postgres -U user1
Password: tk071500004015dc6da471b20417afed65
postgres=#

Here the "tk071500004015dc6da471b20417afed65", "mdw" and "25432" are the
endpoint "c1_00001507_00000000"'s token, hostname and port.

Besides the user and password should match, the user also
needs login permission. Otherwise this role is not allowed to login, even with correct password.

Multiple parallel retrieve cursors can be retrieved from the same retrieve
session as long as their token is the same.



Retrieve From Endpoint
======================

In each retrieve session, the query result on that segment can be
retrieved by using statement "RETRIEVE" and its corresponding endpoint
name.

Syntax:
RETRIEVE { ALL | count } FROM ENDPOINT endpoint_name;

Parameter "ALL" means to retrieve all the results from the endpoint.
Otherwise, a positive integer value needs to be provided as the "count"
to specify how many rows to retrieve.
An empty set will be returned if no more tuples for the endpoint.

Examples:

postgres=# RETRIEVE ALL FROM ENDPOINT c1_00001507_00000000;
 col1 | col2
------+------
 0    | 0
 1    | 1
(2 rows)


List Endpoints In Utility Session On Endpoint QE
================================================

It is possible to list all sessions' endpoints status in the UTILITY
connection to specific endpoint (master or segment node) by using UDF
"gp_endpoints_status_info()". Same as the UDF gp_endpoints_info(true),
for a superuser, he can see all endpoints info of all users', but for
non-superuser, he can only see his endpoints info for security reason.

Syntax:
gp_endpoints_status_info()

gp_endpoints_status_info Columns:
|--------------+-----------+------------------------------------------|
| Column Name  | Data Type | Description                              |
|--------------+-----------+------------------------------------------|
| auth_token   | text      | Retrieve session authentication token    |
|--------------+-----------+------------------------------------------|
| databaseid   | integer   | The database where the cursor is created |
|--------------+-----------+------------------------------------------|
|              |           | on                                       |
|--------------+-----------+------------------------------------------|
| senderpid    | integer   | The process where the query results are  |
|              |           | sent from                                |
|--------------+-----------+------------------------------------------|
| receiverpid  | integer   | The process where the results are being  |
|              |           | received on                              |
|--------------+-----------+------------------------------------------|
| status       | text      | The status for the endpoint              |
|              |           | See gp_endpoints_info for more details   |
|--------------+-----------+------------------------------------------|
| dbid         | integer   | The QE's segment id                      |
|--------------+-----------+------------------------------------------|
| sessionid    | integer   | The session where the cursor created in  |
|--------------+-----------+------------------------------------------|
| userid       | oid       | The user who created this endpoint       |
|--------------+-----------+------------------------------------------|
| endpointname | text      | The identification of this endpoint      |
|--------------+-----------+------------------------------------------|
| cursorname   | text      | Parallel retrieve cursor name            |
|--------------+-----------+------------------------------------------|

Examples:

# Connect the segment in utility mode
$> PGOPTIONS="-c gp_role=utility" psql -h mdw -p 25432 -d postgres

postgres=# select * from gp_endpoints_status_info();
             auth_token             | databaseid | senderpid | receiverpid | status | dbid | sessionid | userid |     endpointname     | cursorname
------------------------------------+------------+-----------+-------------+--------+------+-----------+--------+----------------------+------------
 tk071500004015dc6da471b20417afed65 |      16532 |    736783 |          -1 | READY  |    2 |      5383 |     10 | c2_00001507_00000000 | c2
(1 row)


Check Parallel Retrieve Cursor Retrieving Status
================================================

UDF gp_check_parallel_retrieve_cursor(text) is designed for checking if
all endpoints have been fully retrieved for the given parallel retrieve
cursor.
It will abort the current transaction if any error happens in the
retrieving sessions. If error happens, the parallel retrieve cursor will
be closed and all related endpoints will be freed.

Syntax:
gp_check_parallel_retrieve_cursor(cursor_name)

cursor_name is the parallel retrieve cursor name to be checked.
It returns true if all endpoints have been fully retrieved. If any
endpoint for the cursor has data remained, it returns false. It throws
error message if any error happens during retrieving on segments.

Examples:

postgres=# SELECT gp_check_parallel_retrieve_cursor('c2');
 gp_check_parallel_retrieve_cursor
-----------------------------------
 t
(1 row)


Wait Parallel Retrieve Cursor To Be Fully Retrieved
===================================================

UDF gp_wait_parallel_retrieve_cursor(text) is designed to block until
all the endpoints have been fully retrieved for the given parallel
retrieve cursor. It will block the master session until all the relevant
endpoints are fully retrieved or any error happens in the retrieving
sessions. When error happens, the current transaction will be aborted,
all parallel retrieve cursors and their endpoints in current transaction
will be freed. If it is interrupted by signals, the transaction will be
aborted as well.

Syntax:
gp_wait_parallel_retrieve_cursor(cursor_name)

It will only return true if all endpoints fully retrieved. In any other
cases, an error message will be thrown.

Examples:

postgres=# SELECT gp_wait_parallel_retrieve_cursor('c2'); <waiting...>
 gp_wait_parallel_retrieve_cursor
-----------------------------------
 t
(1 row)


Error Handling In Retrieve Session
==================================

When error happens in a retrieve session, the endpoint will be removed
from QE. By checking GP_ENDPOINTS on QD, the endpoint won't be shown in
the list anymore. The other retrieve sessions can still retrieve from
other endpoints which belong to this session at this time. But if
"gp_check_parallel_retrieve_cursor", "gp_wait_parallel_retrieve_cursor"
or "CLOSE" are executed on QD, the other retrieve sessions will be
canceled since the error is delivered to QD and treated as an error
happens in the transaction.

When the endpoint is partially retrieved and then the corresponding
retrieve session quits, the case will be treated as a retrieve session
error as well. The endpoint will be removed and an error will be
reported on QD when checking or waiting on the retrieve status. "CLOSE"
will also report error in this case.


Close Parallel Retrieve Cursor
==============================

Use "CLOSE" statement to close the parallel retrieve cursor and release
its endpoints. All the related on-going retrieve statements will be
canceled.

Syntax:
CLOSE cursor_name;

Examples:

postgres=# CLOSE C1
CLOSE


Walk-Through Example
====================

Assumes we have a table named "t1" with an integer column "id", and its
data distributed as following:

| id | location |
| 0  | segment0 |
| 1  | segment0 |
| 2  | segment0 |
| 3  | segment1 |
| 4  | segment1 |
| 5  | segment1 |

To declare a parallel retrieve cursor on master in order to select all
tuples from t1:

-- Begin transaction first
master=# BEGIN;
BEGIN
-- Create the parallel retrieve cursor for the intent query
master=# DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM t1;
DECLARE
-- List endpoints to get the needed information to start retrieving
-- sessions on segments
master=# SELECT * FROM GP_ENDPOINTS;
             auth_token             | cursorname | sessionid | hostname | port  | dbid | userid | status |     endpointname
------------------------------------+------------+-----------+----------+-------+------+--------+--------+----------------------
 tk071500004015dc6da471b20417afed65 | c1         |      5383 | mdw      | 25432 |    2 |     10 | READY  | c1_00001507_00000000
 tk071500004015dc6da471b20417afed65 | c1         |      5383 | mdw      | 25433 |    3 |     10 | READY  | c1_00001507_00000001
(2 rows)

Now start a retrieve session on mdw:25432:

# gp_role=retrieve is needed as the runtime parameter
$> PGOPTIONS="-c gp_role=retrieve" psql -h mdw -p 25432 -d postgres
Password: tk071500004015dc6da471b20417afed65

-- Retrieve all rows on this endpoint
seg0=# RETRIEVE ALL FROM ENDPOINT c1_00001507_00000000;
 id
----
 0
 1
 2
(3 rows)

Now the status of endpoint "c1_00001507_00000000" should become
"FINISHED" since all results on seg0 have been retrieved.

-- List endpoints on master to check
master=# SELECT * FROM GP_ENDPOINTS;
             auth_token             | cursorname | sessionid | hostname | port  | dbid | userid | status   |     endpointname
------------------------------------+------------+-----------+----------+-------+------+--------+----------+----------------------
 tk071500004015dc6da471b20417afed65 | c1         |      5383 | mdw      | 25432 |    2 |     10 | FINISHED | c1_00001507_00000000
 tk071500004015dc6da471b20417afed65 | c1         |      5383 | mdw      | 25433 |    3 |     10 | READY    | c1_00001507_00000001
(2 rows)


Start another retrieve session on mdw:25433

$> PGOPTIONS="-c gp_role=retrieve" psql -h mdw -p 25432 -d postgres
Password: tk071500004015dc6da471b20417afed65

-- Retrieve 1 row on this endpoint
seg1=# RETRIEVE 1 FROM ENDPOINT c1_00001507_00000001;
 id
----
 4
(1 row)

The status of endpoint "c1_00001507_00000001" will firstly becomes "RETRIEVING", then becomes "ATTACHED".
RETRIEVING means that a receiver is retrieving data from the endpoint. If a recevier finishes retrieving a part of data(but not retrieve all the data),
the status becomes ATTACHED, means that this endpoint has been attached by a receiver. If the receiver has retrieved all the data from
the endpoint, the status becomes FINISHED.

-- List endpoints on master to check
master=# SELECT * FROM GP_ENDPOINTS;
             auth_token             | cursorname | sessionid | hostname | port  | dbid | userid | status    |     endpointname
------------------------------------+------------+-----------+----------+-------+------+--------+-----------+----------------------
 tk071500004015dc6da471b20417afed65 | c1         |      5383 | mdw      | 25432 |    2 |     10 | FINISHED  | c1_00001507_00000000
 tk071500004015dc6da471b20417afed65 | c1         |      5383 | mdw      | 25433 |    3 |     10 | ATTACHED  | c1_00001507_00000001
(2 rows)
-- To check if the retrieving finished
master=# select gp_check_parallel_retrieve_cursor('c2');
 gp_check_parallel_retrieve_cursor
-----------------------------------
 f
(1 row)


We can just close the cursor now if we decide to not retrieve the
remaining query results:

master=# CLOSE c1;
CLOSE
-- All endpoints are gone
master=# SELECT * FROM GP_ENDPOINTS;
 auth_token | cursorname | sessionid | hostname | port | dbid | userid | status | endpointname
------------+------------+-----------+----------+------+------+--------+--------+--------------
(0 rows)
-- End the transaction
master=# END;
END

