-- Objective of these tests is to ensure if IndexScan is being picked up when order by clause has columns that match
-- prefix of any existing btree indices. This is for queries with both order by and a limit.
-- Tests for queries with order by and limit on B-tree indices.
CREATE TABLE test_index_with_orderby_limit (a int, b int, c float, d int);
CREATE INDEX index_a on test_index_with_orderby_limit using btree(a);
CREATE INDEX index_ab on test_index_with_orderby_limit using btree(a, b);
CREATE INDEX index_bda on test_index_with_orderby_limit using btree(b, d, a);
CREATE INDEX index_c on test_index_with_orderby_limit using hash(c);
INSERT INTO test_index_with_orderby_limit select i, i-2, i/3, i+1 from generate_series(1,10000) i;
ANALYZE test_index_with_orderby_limit;
-- should use index scan
explain (costs off) select a from test_index_with_orderby_limit order by a limit 10;
                                 QUERY PLAN
-----------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Index Scan using index_a on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select a from test_index_with_orderby_limit order by a limit 10;
 a  
----
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
(10 rows)

-- order by using a hash indexed column, should use SeqScan
explain (costs off) select c from test_index_with_orderby_limit order by c limit 10;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c
         ->  Limit
               ->  Sort
                     Sort Key: c
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select c from test_index_with_orderby_limit order by c limit 10;
 c 
---
 0
 0
 1
 1
 1
 2
 2
 2
 3
 3
(10 rows)

-- should use index scan
explain (costs off) select b from test_index_with_orderby_limit order by b limit 10;
                                  QUERY PLAN
-------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b
         ->  Limit
               ->  Index Scan using index_bda on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select b from test_index_with_orderby_limit order by b limit 10;
 b  
----
 -1
  0
  1
  2
  3
  4
  5
  6
  7
  8
(10 rows)

-- should use index scan
explain (costs off) select a, b from test_index_with_orderby_limit order by a, b limit 10;
                                  QUERY PLAN
------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a, b
         ->  Limit
               ->  Index Scan using index_ab on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select a, b from test_index_with_orderby_limit order by a, b limit 10;
 a  | b  
----+----
  1 | -1
  2 |  0
  3 |  1
  4 |  2
  5 |  3
  6 |  4
  7 |  5
  8 |  6
  9 |  7
 10 |  8
(10 rows)

-- should use index scan
explain (costs off) select b, d from test_index_with_orderby_limit order by b, d limit 10;
                                  QUERY PLAN
-------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, d
         ->  Limit
               ->  Index Scan using index_bda on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select b, d from test_index_with_orderby_limit order by b, d limit 10;
 b  | d  
----+----
 -1 |  2
  0 |  3
  1 |  4
  2 |  5
  3 |  6
  4 |  7
  5 |  8
  6 |  9
  7 | 10
  8 | 11
(10 rows)

-- should use seq scan
explain (costs off) select d, b from test_index_with_orderby_limit order by d, b limit 10;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: d, b
         ->  Limit
               ->  Sort
                     Sort Key: d, b
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select d, b from test_index_with_orderby_limit order by d, b limit 10;
 d  | b  
----+----
  2 | -1
  3 |  0
  4 |  1
  5 |  2
  6 |  3
  7 |  4
  8 |  5
  9 |  6
 10 |  7
 11 |  8
(10 rows)

-- should use seq scan
explain (costs off) select d, a from test_index_with_orderby_limit order by d, a limit 10;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: d, a
         ->  Limit
               ->  Sort
                     Sort Key: d, a
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select d, a from test_index_with_orderby_limit order by d, a limit 10;
 d  | a  
----+----
  2 |  1
  3 |  2
  4 |  3
  5 |  4
  6 |  5
  7 |  6
  8 |  7
  9 |  8
 10 |  9
 11 | 10
(10 rows)

-- should use seq scan
explain (costs off) select a, c from test_index_with_orderby_limit order by a, c limit 10;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a, c
         ->  Limit
               ->  Sort
                     Sort Key: a, c
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select a, c from test_index_with_orderby_limit order by a, c limit 10;
 a  | c 
----+---
  1 | 0
  2 | 0
  3 | 1
  4 | 1
  5 | 1
  6 | 2
  7 | 2
  8 | 2
  9 | 3
 10 | 3
(10 rows)

-- should use index scan
explain (costs off) select b, d, a from test_index_with_orderby_limit order by b, d, a limit 10;
                                  QUERY PLAN
-------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, d, a
         ->  Limit
               ->  Index Scan using index_bda on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select b, d, a from test_index_with_orderby_limit order by b, d, a limit 10;
 b  | d  | a  
----+----+----
 -1 |  2 |  1
  0 |  3 |  2
  1 |  4 |  3
  2 |  5 |  4
  3 |  6 |  5
  4 |  7 |  6
  5 |  8 |  7
  6 |  9 |  8
  7 | 10 |  9
  8 | 11 | 10
(10 rows)

-- should use seq scan
explain (costs off) select b, d, c from test_index_with_orderby_limit order by b, d, c limit 10;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, d, c
         ->  Limit
               ->  Sort
                     Sort Key: b, d, c
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select b, d, c from test_index_with_orderby_limit order by b, d, c limit 10;
 b  | d  | c 
----+----+---
 -1 |  2 | 0
  0 |  3 | 0
  1 |  4 | 1
  2 |  5 | 1
  3 |  6 | 1
  4 |  7 | 2
  5 |  8 | 2
  6 |  9 | 2
  7 | 10 | 3
  8 | 11 | 3
(10 rows)

-- should use seq scan
explain (costs off) select c, b, a from test_index_with_orderby_limit order by c, b, a limit 10;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c, b, a
         ->  Limit
               ->  Sort
                     Sort Key: c, b, a
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select c, b, a from test_index_with_orderby_limit order by c, b, a limit 10;
 c | b  | a  
---+----+----
 0 | -1 |  1
 0 |  0 |  2
 1 |  1 |  3
 1 |  2 |  4
 1 |  3 |  5
 2 |  4 |  6
 2 |  5 |  7
 2 |  6 |  8
 3 |  7 |  9
 3 |  8 | 10
(10 rows)

-- with offset and without limit
explain (costs off) select a  from test_index_with_orderby_limit order by a offset 9990;
                              QUERY PLAN
-----------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Index Scan using index_a on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(5 rows)

select a  from test_index_with_orderby_limit order by a offset 9990;
   a   
-------
  9991
  9992
  9993
  9994
  9995
  9996
  9997
  9998
  9999
 10000
(10 rows)

-- limit value in subquery
explain (costs off) select a from test_index_with_orderby_limit order by a limit (select min(a) from test_index_with_orderby_limit);
                                                         QUERY PLAN
----------------------------------------------------------------------------------------------------------------------------
 Limit
   InitPlan 2 (returns $1)  (slice2)
     ->  Result
           InitPlan 1 (returns $0)  (slice3)
             ->  Limit
                   ->  Gather Motion 3:1  (slice4; segments: 3)
                         Merge Key: test_index_with_orderby_limit_1.a
                         ->  Index Only Scan using index_a on test_index_with_orderby_limit test_index_with_orderby_limit_1
                               Index Cond: (a IS NOT NULL)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: test_index_with_orderby_limit.a
         ->  Limit
               ->  Index Only Scan using index_a on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(14 rows)

select a from test_index_with_orderby_limit order by a limit (select min(a) from test_index_with_orderby_limit);
 a 
---
 1
(1 row)

-- offset value in a subquery
explain (costs off) select c from test_index_with_orderby_limit order by c offset (select 9990);
                         QUERY PLAN
-------------------------------------------------------------
 Limit
   InitPlan 1 (returns $0)  (slice2)
     ->  Result
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: test_index_with_orderby_limit.c
         ->  Sort
               Sort Key: test_index_with_orderby_limit.c
               ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Postgres query optimizer
(9 rows)

select c from test_index_with_orderby_limit order by c offset (select 9990);
  c   
------
 3330
 3330
 3331
 3331
 3331
 3332
 3332
 3332
 3333
 3333
(10 rows)

-- order by opposite to index sort direction
explain (costs off) select a from test_index_with_orderby_limit order by a desc limit 10;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Index Scan Backward using index_a on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select a from test_index_with_orderby_limit order by a desc limit 10;
   a   
-------
 10000
  9999
  9998
  9997
  9996
  9995
  9994
  9993
  9992
  9991
(10 rows)

-- order by opposite to nulls direction in index
explain (costs off) select a from test_index_with_orderby_limit order by a NULLS FIRST limit 10;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Sort
                     Sort Key: a NULLS FIRST
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select a from test_index_with_orderby_limit order by a NULLS FIRST limit 10;
 a  
----
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
(10 rows)

-- order by desc with nulls last
explain (costs off) select a from test_index_with_orderby_limit order by a desc NULLS LAST limit 10;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Sort
                     Sort Key: a DESC NULLS LAST
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select a from test_index_with_orderby_limit order by a desc NULLS LAST limit 10;
   a   
-------
 10000
  9999
  9998
  9997
  9996
  9995
  9994
  9993
  9992
  9991
(10 rows)

-- order by as sum of two columns, uses SeqScan with Sort
explain (costs off) select a, b from test_index_with_orderby_limit order by a+b, c limit 3;
                               QUERY PLAN
-------------------------------------------------------------------------
 Result
   ->  Limit
         ->  Gather Motion 3:1  (slice1; segments: 3)
               Merge Key: ((a + b)), c
               ->  Limit
                     ->  Sort
                           Sort Key: ((a + b)), c
                           ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

select a, b from test_index_with_orderby_limit order by a+b, c limit 3;
 a | b  
---+----
 1 | -1
 2 |  0
 3 |  1
(3 rows)

explain (costs off) select a+b as sum from test_index_with_orderby_limit order by sum limit 3;
                            QUERY PLAN
-------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: ((a + b))
         ->  Limit
               ->  Sort
                     Sort Key: ((a + b))
                     ->  Seq Scan on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select a+b as sum from test_index_with_orderby_limit order by sum limit 3;
 sum 
-----
   0
   2
   4
(3 rows)

-- order by using column number
explain (costs off) select a from test_index_with_orderby_limit order by 1 limit 3;
                                 QUERY PLAN
-----------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Index Scan using index_a on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select a from test_index_with_orderby_limit order by 1 limit 3;
 a 
---
 1
 2
 3
(3 rows)

-- check if index-only scan is leveraged when required
set optimizer_enable_indexscan to off;
-- project only columns in the Index
explain (costs off) select b from test_index_with_orderby_limit order by b limit 10;
                                     QUERY PLAN
------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b
         ->  Limit
               ->  Index Only Scan using index_bda on test_index_with_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select b from test_index_with_orderby_limit order by b limit 10;
 b  
----
 -1
  0
  1
  2
  3
  4
  5
  6
  7
  8
(10 rows)

-- re-enable indexscan
set optimizer_enable_indexscan to on;
DROP TABLE test_index_with_orderby_limit;
-- Test Case: Test on a regular table with mixed data type columns.
-- Purpose: Validate if IndexScan with correct scan direction is used on expected index for queries with order by and limit.
CREATE TABLE test_index_with_sort_directions_on_orderby_limit (a int, b text, c float, d int, e text, f int);
-- single col index with default order
CREATE INDEX dir_index_a on test_index_with_sort_directions_on_orderby_limit using btree(a);
-- single col index with reverse order
CREATE INDEX dir_index_b on test_index_with_sort_directions_on_orderby_limit using btree(b desc);
-- single col index with opp nulls direction
CREATE INDEX dir_index_c on test_index_with_sort_directions_on_orderby_limit using btree(c nulls first);
-- multi col index all with all index keys asc
CREATE INDEX dir_index_bcd on test_index_with_sort_directions_on_orderby_limit using btree(b,c,d);
-- multi col index all with all index keys desc
CREATE INDEX dir_index_fde on test_index_with_sort_directions_on_orderby_limit using btree(f desc,d desc,e desc);
-- multi col index with mixed index keys properties
CREATE INDEX dir_index_eda on test_index_with_sort_directions_on_orderby_limit using btree(e, d desc nulls last,a);
-- Covering index with descending and one include column
CREATE INDEX dir_covering_index_db ON test_index_with_sort_directions_on_orderby_limit(d desc) INCLUDE (b);
INSERT INTO test_index_with_sort_directions_on_orderby_limit select i, CONCAT('col_b', i)::text, i/3.2, i+1, CONCAT('col_e', i)::text, i+3 from generate_series(1,10000) i;
-- Inserting nulls to verify results match when index key specifies nulls first or desc
INSERT INTO test_index_with_sort_directions_on_orderby_limit values (null, null, null, null, null);
ANALYZE test_index_with_sort_directions_on_orderby_limit;
-- Positive tests: Validate if IndexScan Forward/Backward is chosen.
-- Validate if 'dir_index_a' is used for order by cols matching/commutative to the index cols
-- Expected to use Forward IndexScan
explain (costs off) select a from test_index_with_sort_directions_on_orderby_limit order by a limit 3;
                                             QUERY PLAN
----------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Index Scan using dir_index_a on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select a from test_index_with_sort_directions_on_orderby_limit order by a limit 3;
 a 
---
 1
 2
 3
(3 rows)

-- Expected to use Backward IndexScan
explain (costs off) select a from test_index_with_sort_directions_on_orderby_limit order by a desc limit 3;
                                                 QUERY PLAN
-------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Index Scan Backward using dir_index_a on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select a from test_index_with_sort_directions_on_orderby_limit order by a desc limit 3;
   a   
-------
      
 10000
  9999
(3 rows)

-- Validate if 'dir_index_b' is used for order by cols matching/commutative to the index cols
-- Expected to use Forward IndexScan
explain (costs off) select b from test_index_with_sort_directions_on_orderby_limit order by b desc limit 3;
                                             QUERY PLAN
----------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b
         ->  Limit
               ->  Index Scan using dir_index_b on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select b from test_index_with_sort_directions_on_orderby_limit order by b desc limit 3;
     b     
-----------
 
 col_b9999
 col_b9998
(3 rows)

-- Expected to use Backward IndexScan
explain (costs off) select b from test_index_with_sort_directions_on_orderby_limit order by b limit 3;
                                                 QUERY PLAN
-------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b
         ->  Limit
               ->  Index Scan Backward using dir_index_b on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select b from test_index_with_sort_directions_on_orderby_limit order by b limit 3;
    b     
----------
 col_b1
 col_b10
 col_b100
(3 rows)

-- Validate if 'dir_index_c' is used for order by cols matching/commutative to the index cols
-- Expected to use Forward IndexScan
explain (costs off) select c from test_index_with_sort_directions_on_orderby_limit order by c nulls first limit 3;
                                             QUERY PLAN
----------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c
         ->  Limit
               ->  Index Scan using dir_index_c on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select c from test_index_with_sort_directions_on_orderby_limit order by c nulls first limit 3;
   c    
--------
       
 0.3125
  0.625
(3 rows)

-- Expected to use Backward IndexScan
explain (costs off) select c from test_index_with_sort_directions_on_orderby_limit order by c desc nulls last limit 3;
                                                 QUERY PLAN
-------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c
         ->  Limit
               ->  Index Scan Backward using dir_index_c on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select c from test_index_with_sort_directions_on_orderby_limit order by c desc nulls last limit 3;
     c     
-----------
      3125
 3124.6875
  3124.375
(3 rows)

-- Validate if 'dir_index_bcd' is used for order by cols matching/commutative to the index cols
-- Testing various permutations of order by columns that are expected to choose Forward IndexScan
explain (costs off) select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b,c,d limit 3;
                                              QUERY PLAN
------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, c, d
         ->  Limit
               ->  Index Scan using dir_index_bcd on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b,c,d limit 3;
    b     |   c    |  d  
----------+--------+-----
 col_b1   | 0.3125 |   2
 col_b10  |  3.125 |  11
 col_b100 |  31.25 | 101
(3 rows)

explain (costs off) select b,c from test_index_with_sort_directions_on_orderby_limit order by b,c limit 3;
                                              QUERY PLAN
------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, c
         ->  Limit
               ->  Index Scan using dir_index_bcd on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select b,c from test_index_with_sort_directions_on_orderby_limit order by b,c limit 3;
    b     |   c    
----------+--------
 col_b1   | 0.3125
 col_b10  |  3.125
 col_b100 |  31.25
(3 rows)

-- Testing various permutations of order by columns that are expected to choose Backward IndexScan
explain (costs off) select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b desc,c desc,d desc limit 3;
                                                  QUERY PLAN
---------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, c, d
         ->  Limit
               ->  Index Scan Backward using dir_index_bcd on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b desc,c desc,d desc limit 3;
     b     |     c     |   d   
-----------+-----------+-------
           |           |      
 col_b9999 | 3124.6875 | 10000
 col_b9998 |  3124.375 |  9999
(3 rows)

explain (costs off) select b,c from test_index_with_sort_directions_on_orderby_limit order by b desc,c desc limit 3;
                                                  QUERY PLAN
---------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, c
         ->  Limit
               ->  Index Scan Backward using dir_index_bcd on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select b,c from test_index_with_sort_directions_on_orderby_limit order by b desc,c desc limit 3;
     b     |     c     
-----------+-----------
           |          
 col_b9999 | 3124.6875
 col_b9998 |  3124.375
(3 rows)

-- Validate if 'dir_index_fde' is used for order by cols matching/commutative to the index cols
-- Testing various permutations of order by columns that are expected to choose Forward IndexScan
explain (costs off) select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f desc,d desc,e desc limit 3;
                                              QUERY PLAN
------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: f, d, e
         ->  Limit
               ->  Index Scan using dir_index_fde on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f desc,d desc,e desc limit 3;
   f   |   d   |     e      
-------+-------+------------
       |       | 
 10003 | 10001 | col_e10000
 10002 | 10000 | col_e9999
(3 rows)

explain (costs off) select f,d from test_index_with_sort_directions_on_orderby_limit order by f desc,d desc limit 3;
                                              QUERY PLAN
------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: f, d
         ->  Limit
               ->  Index Scan using dir_index_fde on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select f,d from test_index_with_sort_directions_on_orderby_limit order by f desc,d desc limit 3;
   f   |   d   
-------+-------
       |      
 10003 | 10001
 10002 | 10000
(3 rows)

-- Testing various permutations of order by columns that are expected to choose Backward IndexScan
explain (costs off) select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f,d,e limit 3;
                                                  QUERY PLAN
---------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: f, d, e
         ->  Limit
               ->  Index Scan Backward using dir_index_fde on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f,d,e limit 3;
 f | d |   e    
---+---+--------
 4 | 2 | col_e1
 5 | 3 | col_e2
 6 | 4 | col_e3
(3 rows)

explain (costs off) select f,d from test_index_with_sort_directions_on_orderby_limit order by f,d limit 3;
                                                  QUERY PLAN
---------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: f, d
         ->  Limit
               ->  Index Scan Backward using dir_index_fde on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select f,d from test_index_with_sort_directions_on_orderby_limit order by f,d limit 3;
 f | d 
---+---
 4 | 2
 5 | 3
 6 | 4
(3 rows)

-- Validate if 'dir_index_eda' is used for order by cols matching/commutative to the index cols
-- Testing various permutations of order by columns that are expected to choose Forward IndexScan
explain (costs off) select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e, d desc nulls last,a limit 3;
                                              QUERY PLAN
------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d, a
         ->  Limit
               ->  Index Scan using dir_index_eda on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e, d desc nulls last,a limit 3;
    e     |  d  |  a  
----------+-----+-----
 col_e1   |   2 |   1
 col_e10  |  11 |  10
 col_e100 | 101 | 100
(3 rows)

explain (costs off) select e,d from test_index_with_sort_directions_on_orderby_limit order by e, d desc nulls last limit 3;
                                              QUERY PLAN
------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d
         ->  Limit
               ->  Index Scan using dir_index_eda on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select e,d from test_index_with_sort_directions_on_orderby_limit order by e, d desc nulls last limit 3;
    e     |  d  
----------+-----
 col_e1   |   2
 col_e10  |  11
 col_e100 | 101
(3 rows)

-- Testing various permutations of order by columns that are expected to choose Backward IndexScan
explain (costs off) select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e desc,d nulls first,a desc limit 3;
                                                  QUERY PLAN
---------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d, a
         ->  Limit
               ->  Index Scan Backward using dir_index_eda on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e desc,d nulls first,a desc limit 3;
     e     |   d   |  a   
-----------+-------+------
           |       |     
 col_e9999 | 10000 | 9999
 col_e9998 |  9999 | 9998
(3 rows)

explain (costs off) select e,d from test_index_with_sort_directions_on_orderby_limit order by e desc,d nulls first limit 3;
                                                  QUERY PLAN
---------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d
         ->  Limit
               ->  Index Scan Backward using dir_index_eda on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select e,d from test_index_with_sort_directions_on_orderby_limit order by e desc,d nulls first limit 3;
     e     |   d   
-----------+-------
           |      
 col_e9999 | 10000
 col_e9998 |  9999
(3 rows)

-- Validate if IndexScan is chosen and on covering index
-- Expected to use Forward IndexScan
explain (costs off) select d from test_index_with_sort_directions_on_orderby_limit order by d desc limit 3;
                                                  QUERY PLAN
--------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: d
         ->  Limit
               ->  Index Scan using dir_covering_index_db on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select d from test_index_with_sort_directions_on_orderby_limit order by d desc limit 3;
   d   
-------
      
 10001
 10000
(3 rows)

-- Expected to use Backward IndexScan
explain (costs off) select d from test_index_with_sort_directions_on_orderby_limit order by d limit 3;
                                                      QUERY PLAN
-----------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: d
         ->  Limit
               ->  Index Scan Backward using dir_covering_index_db on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select d from test_index_with_sort_directions_on_orderby_limit order by d limit 3;
 d 
---
 2
 3
 4
(3 rows)

-- Validate if Backward IndexScan is chosen for query with offset and without limit
explain (costs off) select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e desc,d nulls first,a desc offset 9990;
                                               QUERY PLAN
---------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d, a
         ->  Index Scan Backward using dir_index_eda on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(5 rows)

select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e desc,d nulls first,a desc offset 9997;
     e     |  d   |  a   
-----------+------+------
 col_e1000 | 1001 | 1000
 col_e100  |  101 |  100
 col_e10   |   11 |   10
 col_e1    |    2 |    1
(4 rows)

-- Validate if Backward IndexScan is chosen for query with offset value in subquery
-- ORCA_FEATURE_NOT_SUPPORTED: ORCA doesn't support limit or offset values specified as part of a subquery
explain (costs off) select c from test_index_with_sort_directions_on_orderby_limit order by c desc nulls last offset (select 9997);
                                                 QUERY PLAN
------------------------------------------------------------------------------------------------------------
 Limit
   InitPlan 1 (returns $0)  (slice2)
     ->  Result
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: test_index_with_sort_directions_on_orderby_limit.c
         ->  Index Only Scan Backward using dir_index_c on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(7 rows)

select c from test_index_with_sort_directions_on_orderby_limit order by c desc nulls last offset (select 9997);
   c    
--------
 0.9375
  0.625
 0.3125
       
(4 rows)

-- Validate if Backward IndexScan is chosen for query with limit value in subquery
-- ORCA_FEATURE_NOT_SUPPORTED: ORCA doesn't support limit or offset values specified as part of a subquery
explain (costs off) select c from test_index_with_sort_directions_on_orderby_limit order by c desc nulls last limit (select 3);
                                                    QUERY PLAN
------------------------------------------------------------------------------------------------------------------
 Limit
   InitPlan 1 (returns $0)  (slice2)
     ->  Result
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: test_index_with_sort_directions_on_orderby_limit.c
         ->  Limit
               ->  Index Only Scan Backward using dir_index_c on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Postgres query optimizer
(8 rows)

select c from test_index_with_sort_directions_on_orderby_limit order by c desc nulls last limit (select 3);
     c     
-----------
      3125
 3124.6875
  3124.375
(3 rows)

-- Negative tests: Validate if a SeqScan is chosen if order by cols directions do not matching indices keys directions.
--                 Expected to choose SeqScan with Sort
-- Testing various permutations that are not matching keys in 'dir_index_a'
explain (costs off) select a from test_index_with_sort_directions_on_orderby_limit order by a nulls first limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Sort
                     Sort Key: a NULLS FIRST
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select a from test_index_with_sort_directions_on_orderby_limit order by a nulls first limit 3;
 a 
---
  
 1
 2
(3 rows)

explain (costs off) select a from test_index_with_sort_directions_on_orderby_limit order by a desc nulls last limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Sort
                     Sort Key: a DESC NULLS LAST
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select a from test_index_with_sort_directions_on_orderby_limit order by a desc nulls last limit 3;
   a   
-------
 10000
  9999
  9998
(3 rows)

-- Testing various permutations that are not matching keys in 'dir_index_b'
explain (costs off) select b from test_index_with_sort_directions_on_orderby_limit order by b nulls first limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b
         ->  Limit
               ->  Sort
                     Sort Key: b NULLS FIRST
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select b from test_index_with_sort_directions_on_orderby_limit order by b nulls first limit 3;
    b    
---------
 
 col_b1
 col_b10
(3 rows)

explain (costs off) select b from test_index_with_sort_directions_on_orderby_limit order by b desc nulls last limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b
         ->  Limit
               ->  Sort
                     Sort Key: b DESC NULLS LAST
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select b from test_index_with_sort_directions_on_orderby_limit order by b desc nulls last limit 3;
     b     
-----------
 col_b9999
 col_b9998
 col_b9997
(3 rows)

-- Testing various permutations that are not matching keys in 'dir_index_c'
explain (costs off) select c from test_index_with_sort_directions_on_orderby_limit order by c limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c
         ->  Limit
               ->  Sort
                     Sort Key: c
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select c from test_index_with_sort_directions_on_orderby_limit order by c  limit 3;
   c    
--------
 0.3125
  0.625
 0.9375
(3 rows)

explain (costs off) select c from test_index_with_sort_directions_on_orderby_limit order by c desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c
         ->  Limit
               ->  Sort
                     Sort Key: c DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select c from test_index_with_sort_directions_on_orderby_limit order by c desc limit 3;
     c     
-----------
          
      3125
 3124.6875
(3 rows)

-- Testing various permutations that are not matching keys in 'dir_index_bcd'
explain (costs off) select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b ,c desc,d desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, c, d
         ->  Limit
               ->  Sort
                     Sort Key: b, c DESC, d DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b ,c desc,d desc limit 3;
    b     |   c    |  d  
----------+--------+-----
 col_b1   | 0.3125 |   2
 col_b10  |  3.125 |  11
 col_b100 |  31.25 | 101
(3 rows)

explain (costs off) select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b ,c ,d desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, c, d
         ->  Limit
               ->  Sort
                     Sort Key: b, c, d DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b ,c ,d desc limit 3;
    b     |   c    |  d  
----------+--------+-----
 col_b1   | 0.3125 |   2
 col_b10  |  3.125 |  11
 col_b100 |  31.25 | 101
(3 rows)

explain (costs off) select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b desc, c ,d desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, c, d
         ->  Limit
               ->  Sort
                     Sort Key: b DESC, c, d DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select b,c,d from test_index_with_sort_directions_on_orderby_limit order by b desc, c ,d desc limit 3;
     b     |     c     |   d   
-----------+-----------+-------
           |           |      
 col_b9999 | 3124.6875 | 10000
 col_b9998 |  3124.375 |  9999
(3 rows)

-- Testing various permutations that are not matching keys in 'dir_index_fde'
explain (costs off) select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f ,d desc,e desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: f, d, e
         ->  Limit
               ->  Sort
                     Sort Key: f, d DESC, e DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f ,d desc,e desc limit 3;
 f | d |   e    
---+---+--------
 4 | 2 | col_e1
 5 | 3 | col_e2
 6 | 4 | col_e3
(3 rows)

explain (costs off) select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f,d ,e desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: f, d, e
         ->  Limit
               ->  Sort
                     Sort Key: f, d, e DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f,d ,e desc limit 3;
 f | d |   e    
---+---+--------
 4 | 2 | col_e1
 5 | 3 | col_e2
 6 | 4 | col_e3
(3 rows)

explain (costs off) select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f desc, d ,e desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: f, d, e
         ->  Limit
               ->  Sort
                     Sort Key: f DESC, d, e DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select f,d,e from test_index_with_sort_directions_on_orderby_limit order by f desc, d ,e desc limit 3;
   f   |   d   |     e      
-------+-------+------------
       |       | 
 10003 | 10001 | col_e10000
 10002 | 10000 | col_e9999
(3 rows)

-- Testing various permutations that are not matching keys in 'dir_index_eda'
explain (costs off) select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e, d desc,a desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d, a
         ->  Limit
               ->  Sort
                     Sort Key: e, d DESC, a DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e, d desc,a desc limit 3;
    e     |  d  |  a  
----------+-----+-----
 col_e1   |   2 |   1
 col_e10  |  11 |  10
 col_e100 | 101 | 100
(3 rows)

explain (costs off) select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e desc,d desc,a desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d, a
         ->  Limit
               ->  Sort
                     Sort Key: e DESC, d DESC, a DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e desc,d desc,a desc limit 3;
     e     |   d   |  a   
-----------+-------+------
           |       |     
 col_e9999 | 10000 | 9999
 col_e9998 |  9999 | 9998
(3 rows)

explain (costs off) select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e ,d ,a  limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d, a
         ->  Limit
               ->  Sort
                     Sort Key: e, d, a
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e ,d ,a  limit 3;
    e     |  d  |  a  
----------+-----+-----
 col_e1   |   2 |   1
 col_e10  |  11 |  10
 col_e100 | 101 | 100
(3 rows)

-- Testing various permutations of order by on non-index columns. Expected to choose SeqScan with Sort
explain (costs off) select d, f from test_index_with_sort_directions_on_orderby_limit order by d, f limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: d, f
         ->  Limit
               ->  Sort
                     Sort Key: d, f
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select d, f from test_index_with_sort_directions_on_orderby_limit order by d, f limit 3;
 d | f 
---+---
 2 | 4
 3 | 5
 4 | 6
(3 rows)

explain (costs off) select a,e from test_index_with_sort_directions_on_orderby_limit order by a,e limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a, e
         ->  Limit
               ->  Sort
                     Sort Key: a, e
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select a,e from test_index_with_sort_directions_on_orderby_limit order by a,e limit 3;
 a |   e    
---+--------
 1 | col_e1
 2 | col_e2
 3 | col_e3
(3 rows)

explain (costs off) select d,a from test_index_with_sort_directions_on_orderby_limit order by d,a desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: d, a
         ->  Limit
               ->  Sort
                     Sort Key: d, a DESC
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select d,a from test_index_with_sort_directions_on_orderby_limit order by d,a desc limit 3;
 d | a 
---+---
 2 | 1
 3 | 2
 4 | 3
(3 rows)

explain (costs off) select d,c from test_index_with_sort_directions_on_orderby_limit order by d desc,c limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: d, c
         ->  Limit
               ->  Sort
                     Sort Key: d DESC, c
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select d,c from test_index_with_sort_directions_on_orderby_limit order by d desc,c limit 3;
   d   |     c     
-------+-----------
       |          
 10001 |      3125
 10000 | 3124.6875
(3 rows)

-- Validate if SeqScan is chosen if order by cols also have the Included Column of covering index
explain (costs off) select e,b from test_index_with_sort_directions_on_orderby_limit order by e, b limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, b
         ->  Limit
               ->  Sort
                     Sort Key: e, b
                     ->  Seq Scan on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

select e,b from test_index_with_sort_directions_on_orderby_limit order by e,b limit 3;
    e     |    b     
----------+----------
 col_e1   | col_b1
 col_e10  | col_b10
 col_e100 | col_b100
(3 rows)

-- Purpose: Validate if IndexOnlyScan Forward/Backward is chosen when required for queries with order by and limit
-- Vacuum table to Ensure IndexOnlyScan is chosen
vacuum test_index_with_sort_directions_on_orderby_limit;
-- Testing various permutations of order by columns that are expected to choose IndexOnlyScan Forward
explain (costs off) select b from test_index_with_sort_directions_on_orderby_limit order by b desc limit 3;
                                               QUERY PLAN
---------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b
         ->  Limit
               ->  Index Only Scan using dir_index_b on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select b from test_index_with_sort_directions_on_orderby_limit order by b desc limit 3;
     b     
-----------
 
 col_b9999
 col_b9998
(3 rows)

explain (costs off) select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e, d desc nulls last limit 3;
                                                QUERY PLAN
-----------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d
         ->  Limit
               ->  Index Only Scan using dir_index_eda on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e, d desc nulls last limit 3;
    e     |  d  |  a  
----------+-----+-----
 col_e1   |   2 |   1
 col_e10  |  11 |  10
 col_e100 | 101 | 100
(3 rows)

-- Testing various permutations of order by columns that are expected to choose IndexOnlyScan Backward
explain (costs off) select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e desc,d nulls first limit 3;
                                                     QUERY PLAN
--------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d
         ->  Limit
               ->  Index Only Scan Backward using dir_index_eda on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e desc,d nulls first limit 3;
     e     |   d   |  a   
-----------+-------+------
           |       |     
 col_e9999 | 10000 | 9999
 col_e9998 |  9999 | 9998
(3 rows)

explain (costs off) select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e desc,d nulls first,a desc limit 3;
                                                     QUERY PLAN
--------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d, a
         ->  Limit
               ->  Index Only Scan Backward using dir_index_eda on test_index_with_sort_directions_on_orderby_limit
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select e,d,a from test_index_with_sort_directions_on_orderby_limit order by e desc,d nulls first,a desc limit 3;
     e     |   d   |  a   
-----------+-------+------
           |       |     
 col_e9999 | 10000 | 9999
 col_e9998 |  9999 | 9998
(3 rows)

-- Clean Up
DROP TABLE test_index_with_sort_directions_on_orderby_limit;
-- Test Case: Test on a Partition table with mixed data type columns.
-- Purpose: Validate if DynamicIndexScan/DynamicIndexOnlyScan with correct scan direction is used on expected index for queries with order by and limit.
CREATE TABLE test_partition_table(a int, b int, c float, d text, e numeric, f int) DISTRIBUTED BY (a) PARTITION BY range(a) (start (0) end(10000) every(2000));
-- single col index with opp nulls direction on partition column
CREATE INDEX part_index_a on test_partition_table using btree(a nulls first);
-- multi col index all with all index keys asc
CREATE INDEX part_index_bcd on test_partition_table using btree(b,c,d);
-- multi col index all with all index keys desc
CREATE INDEX part_index_fde on test_partition_table using btree(f desc,d desc,e desc);
-- multi col index with mixed index keys properties
CREATE INDEX part_index_eda on test_partition_table using btree(e desc nulls last, d,a desc);
-- Covering index on partition column
CREATE INDEX part_covering_index_cb ON test_partition_table(c desc) INCLUDE (b);
INSERT INTO test_partition_table SELECT i, i+3, i/4.2, concat('sample_text ',i), i/5, i from generate_series(1,9998) i;
-- Inserting nulls to verify results match when index key specifies nulls first or desc
INSERT INTO test_partition_table values (9999, null, null, null, null, null);
ANALYZE test_partition_table;
-- Positive tests: Validate if DynamicIndexScan Forward/Backward is chosen.
-- Using explain analyze to validate number of partitions scanned
-- Validate if 'part_index_a' is used for order by cols matching/commutative to the index cols
-- Expected to use Forward DynamicIndexScan
explain analyze select a from test_partition_table order by a nulls first limit 3;
                                                                          QUERY PLAN
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..6.01 rows=3 width=4) (actual time=6.743..6.744 rows=3 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..6.01 rows=3 width=4) (actual time=6.741..6.742 rows=3 loops=1)
         Merge Key: a
         ->  Limit  (cost=0.00..6.01 rows=1 width=4) (actual time=0.361..0.363 rows=3 loops=1)
               ->  Dynamic Index Scan using part_index_a on test_partition_table  (cost=0.00..6.01 rows=33 width=4) (actual time=0.360..0.362 rows=3 loops=1)
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 8.404 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 45K bytes avg x 3 workers, 45K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 10.719 ms
(13 rows)

select a from test_partition_table order by a nulls first limit 3;
 a 
---
 1
 2
 3
(3 rows)

-- Expected to use Backward DynamicIndexScan
explain analyze select a from test_partition_table order by a desc nulls last limit 3;
                                                                              QUERY PLAN
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..6.01 rows=3 width=4) (actual time=21.108..21.111 rows=3 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..6.01 rows=3 width=4) (actual time=21.107..21.108 rows=3 loops=1)
         Merge Key: a
         ->  Limit  (cost=0.00..6.01 rows=1 width=4) (actual time=7.002..7.227 rows=3 loops=1)
               ->  Dynamic Index Scan Backward using part_index_a on test_partition_table  (cost=0.00..6.01 rows=33 width=4) (actual time=7.001..7.096 rows=3 loops=1)
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 3.273 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 45K bytes avg x 3 workers, 45K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 21.680 ms
(13 rows)

select a from test_partition_table order by a desc nulls last limit 3;
  a   
------
 9999
 9998
 9997
(3 rows)

-- Validate if 'part_index_bcd' is used for order by cols matching/commutative to the index cols
-- Testing various permutations of order by columns that are expected to choose Forward DynamicIndexScan
explain analyze select b,c,d from test_partition_table order by b,c,d limit 3;
                                                                            QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..8.58 rows=3 width=20) (actual time=0.390..0.392 rows=3 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..8.58 rows=3 width=20) (actual time=0.389..0.390 rows=3 loops=1)
         Merge Key: b, c, d
         ->  Limit  (cost=0.00..8.58 rows=1 width=20) (actual time=0.185..0.187 rows=3 loops=1)
               ->  Dynamic Index Scan using part_index_bcd on test_partition_table  (cost=0.00..8.45 rows=3333 width=20) (actual time=0.185..0.186 rows=3 loops=1)
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 3.260 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 47K bytes avg x 3 workers, 47K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 0.712 ms
(13 rows)

select b,c,d from test_partition_table order by b,c,d limit 3;
 b |          c          |       d       
---+---------------------+---------------
 4 | 0.23809523809523808 | sample_text 1
 5 | 0.47619047619047616 | sample_text 2
 6 |  0.7142857142857143 | sample_text 3
(3 rows)

explain analyze select b,c from test_partition_table order by b,c limit 13;
                                                                             QUERY PLAN
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..8.53 rows=13 width=12) (actual time=0.388..0.392 rows=13 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..8.53 rows=13 width=12) (actual time=0.387..0.390 rows=13 loops=1)
         Merge Key: b, c
         ->  Limit  (cost=0.00..8.53 rows=5 width=12) (actual time=0.181..0.187 rows=13 loops=1)
               ->  Dynamic Index Scan using part_index_bcd on test_partition_table  (cost=0.00..8.45 rows=3333 width=12) (actual time=0.181..0.186 rows=13 loops=1)
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 3.391 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 45K bytes avg x 3 workers, 45K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 0.693 ms
(13 rows)

select b,c from test_partition_table order by b,c limit 13;
 b  |          c          
----+---------------------
  4 | 0.23809523809523808
  5 | 0.47619047619047616
  6 |  0.7142857142857143
  7 |  0.9523809523809523
  8 |  1.1904761904761905
  9 |  1.4285714285714286
 10 |  1.6666666666666667
 11 |  1.9047619047619049
 12 |   2.142857142857143
 13 |   2.380952380952381
 14 |   2.619047619047619
 15 |   2.857142857142857
 16 |  3.0952380952380953
(13 rows)

-- Testing various permutations of order by columns that are expected to choose Backward DynamicIndexScan
explain analyze select b,c,d from test_partition_table order by b desc,c desc,d desc limit 3;
                                                                                 QUERY PLAN
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..8.58 rows=3 width=20) (actual time=0.486..0.489 rows=3 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..8.58 rows=3 width=20) (actual time=0.485..0.486 rows=3 loops=1)
         Merge Key: b, c, d
         ->  Limit  (cost=0.00..8.58 rows=1 width=20) (actual time=0.186..0.188 rows=3 loops=1)
               ->  Dynamic Index Scan Backward using part_index_bcd on test_partition_table  (cost=0.00..8.45 rows=3333 width=20) (actual time=0.185..0.187 rows=3 loops=1)
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 3.187 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 47K bytes avg x 3 workers, 47K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 0.782 ms
(13 rows)

select b,c,d from test_partition_table order by b desc,c desc,d desc limit 3;
   b   |         c          |        d         
-------+--------------------+------------------
       |                    | 
 10001 | 2380.4761904761904 | sample_text 9998
 10000 | 2380.2380952380954 | sample_text 9997
(3 rows)

explain analyze select b,c from test_partition_table order by b desc,c desc limit 3;
                                                                                 QUERY PLAN
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..8.53 rows=3 width=12) (actual time=1.035..1.036 rows=3 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..8.53 rows=3 width=12) (actual time=1.034..1.035 rows=3 loops=1)
         Merge Key: b, c
         ->  Limit  (cost=0.00..8.53 rows=1 width=12) (actual time=0.501..0.506 rows=3 loops=1)
               ->  Dynamic Index Scan Backward using part_index_bcd on test_partition_table  (cost=0.00..8.45 rows=3333 width=12) (actual time=0.500..0.503 rows=3 loops=1)
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 3.094 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 45K bytes avg x 3 workers, 45K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 1.444 ms
(13 rows)

select b,c from test_partition_table order by b desc,c desc limit 3;
   b   |         c          
-------+--------------------
       |                   
 10001 | 2380.4761904761904
 10000 | 2380.2380952380954
(3 rows)

-- Validate if 'part_index_fde' is used for order by cols matching/commutative to the index cols. Average partitions scanned
-- for this query are more as the limit value is higher.
-- Testing various permutations of order by columns that expected to choose Forward DynamicIndexScan
explain analyze select f,d,e from test_partition_table order by f desc,d desc,e desc limit 23;
                                                                             QUERY PLAN
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..8.58 rows=23 width=20) (actual time=2.058..2.066 rows=23 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..8.58 rows=23 width=20) (actual time=2.058..2.063 rows=23 loops=1)
         Merge Key: f, d, e
         ->  Limit  (cost=0.00..8.58 rows=8 width=20) (actual time=0.650..0.680 rows=23 loops=1)
               ->  Dynamic Index Scan using part_index_fde on test_partition_table  (cost=0.00..8.45 rows=3333 width=20) (actual time=0.649..0.675 rows=23 loops=1)
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 3.258 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 47K bytes avg x 3 workers, 47K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 2.415 ms
(13 rows)

select f,d,e from test_partition_table order by f desc,d desc,e desc limit 23;
  f   |        d         |  e  
------+------------------+-----
 1999 | sample_text 1999 | 399
 1998 | sample_text 1998 | 399
 1997 | sample_text 1997 | 399
 1996 | sample_text 1996 | 399
 1995 | sample_text 1995 | 399
 1994 | sample_text 1994 | 398
 1993 | sample_text 1993 | 398
 1992 | sample_text 1992 | 398
 1991 | sample_text 1991 | 398
 1990 | sample_text 1990 | 398
 1989 | sample_text 1989 | 397
 1988 | sample_text 1988 | 397
 1987 | sample_text 1987 | 397
 1986 | sample_text 1986 | 397
 1985 | sample_text 1985 | 397
 1984 | sample_text 1984 | 396
 1983 | sample_text 1983 | 396
 1982 | sample_text 1982 | 396
 1981 | sample_text 1981 | 396
 1980 | sample_text 1980 | 396
 1979 | sample_text 1979 | 395
 1978 | sample_text 1978 | 395
 1977 | sample_text 1977 | 395
(23 rows)

explain analyze select f,d from test_partition_table order by f desc,d desc limit 3;
                                                                            QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..8.53 rows=3 width=12) (actual time=1.152..1.154 rows=3 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..8.53 rows=3 width=12) (actual time=1.151..1.152 rows=3 loops=1)
         Merge Key: f, d
         ->  Limit  (cost=0.00..8.53 rows=1 width=12) (actual time=0.561..0.565 rows=3 loops=1)
               ->  Dynamic Index Scan using part_index_fde on test_partition_table  (cost=0.00..8.45 rows=3333 width=12) (actual time=0.559..0.562 rows=3 loops=1)
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 3.042 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 45K bytes avg x 3 workers, 45K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 1.516 ms
(13 rows)

select f,d from test_partition_table order by f desc,d desc limit 3;
  f   |        d         
------+------------------
 1999 | sample_text 1999
 1998 | sample_text 1998
 1997 | sample_text 1997
(3 rows)

-- Testing various permutations of order by columns that should pick Backward DynamicIndexScan
explain analyze select f,d,e from test_partition_table order by f,d,e limit 3;
                                                                                 QUERY PLAN
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..8.58 rows=3 width=20) (actual time=1.089..1.090 rows=3 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..8.58 rows=3 width=20) (actual time=1.088..1.089 rows=3 loops=1)
         Merge Key: f, d, e
         ->  Limit  (cost=0.00..8.58 rows=1 width=20) (actual time=0.567..0.571 rows=3 loops=1)
               ->  Dynamic Index Scan Backward using part_index_fde on test_partition_table  (cost=0.00..8.45 rows=3333 width=20) (actual time=0.566..0.569 rows=3 loops=1)
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 3.316 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 47K bytes avg x 3 workers, 47K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 1.461 ms
(13 rows)

select f,d,e from test_partition_table order by f,d,e limit 3;
  f   |        d         |  e   
------+------------------+------
 8000 | sample_text 8000 | 1600
 8001 | sample_text 8001 | 1600
 8002 | sample_text 8002 | 1600
(3 rows)

explain analyze select f,d from test_partition_table order by f,d limit 3;
                                                                                 QUERY PLAN
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..8.53 rows=3 width=12) (actual time=1.067..1.068 rows=3 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..8.53 rows=3 width=12) (actual time=1.066..1.067 rows=3 loops=1)
         Merge Key: f, d
         ->  Limit  (cost=0.00..8.53 rows=1 width=12) (actual time=0.558..0.562 rows=3 loops=1)
               ->  Dynamic Index Scan Backward using part_index_fde on test_partition_table  (cost=0.00..8.45 rows=3333 width=12) (actual time=0.557..0.560 rows=3 loops=1)
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 3.073 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 45K bytes avg x 3 workers, 45K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 1.599 ms
(13 rows)

select f,d from test_partition_table order by f,d limit 3;
  f   |        d         
------+------------------
 8000 | sample_text 8000
 8001 | sample_text 8001
 8002 | sample_text 8002
(3 rows)

-- Validate if 'part_index_eda' is used for order by cols matching/commutative to the index cols
-- Testing various permutations of order by columns that expected to choose Forward DynamicIndexScan
explain analyze select e,d,a from test_partition_table order by e desc nulls last, d, a desc limit 3;
                                                                            QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..8.58 rows=3 width=20) (actual time=2.920..2.923 rows=3 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..8.58 rows=3 width=20) (actual time=2.919..2.922 rows=3 loops=1)
         Merge Key: e, d, a
         ->  Limit  (cost=0.00..8.58 rows=1 width=20) (actual time=0.752..0.756 rows=3 loops=1)
               ->  Dynamic Index Scan using part_index_eda on test_partition_table  (cost=0.00..8.45 rows=3333 width=20) (actual time=0.751..0.754 rows=3 loops=1)
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 3.084 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 47K bytes avg x 3 workers, 47K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 3.297 ms
(13 rows)

select e,d,a from test_partition_table order by e desc nulls last, d, a desc limit 3;
  e  |        d         |  a   
-----+------------------+------
 399 | sample_text 1995 | 1995
 399 | sample_text 1996 | 1996
 399 | sample_text 1997 | 1997
(3 rows)

explain analyze select e,d,a from test_partition_table order by e desc nulls last, d limit 3;
                                                                            QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..8.58 rows=3 width=20) (actual time=3.230..3.232 rows=3 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..8.58 rows=3 width=20) (actual time=3.229..3.231 rows=3 loops=1)
         Merge Key: e, d
         ->  Limit  (cost=0.00..8.58 rows=1 width=20) (actual time=2.109..2.118 rows=3 loops=1)
               ->  Dynamic Index Scan using part_index_eda on test_partition_table  (cost=0.00..8.45 rows=3333 width=20) (actual time=2.106..2.114 rows=3 loops=1)
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 3.521 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 47K bytes avg x 3 workers, 47K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 3.816 ms
(13 rows)

select e,d,a from test_partition_table order by e desc nulls last, d limit 3;
  e  |        d         |  a   
-----+------------------+------
 399 | sample_text 1995 | 1995
 399 | sample_text 1996 | 1996
 399 | sample_text 1997 | 1997
(3 rows)

-- Testing various permutations of order by columns that expected to choose Backward DynamicIndexScan
explain analyze select e,d,a from test_partition_table order by e nulls first, d desc, a limit 3;
                                                                                 QUERY PLAN
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..8.58 rows=3 width=20) (actual time=2.885..2.889 rows=3 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..8.58 rows=3 width=20) (actual time=2.884..2.888 rows=3 loops=1)
         Merge Key: e, d, a
         ->  Limit  (cost=0.00..8.58 rows=1 width=20) (actual time=1.681..1.691 rows=3 loops=1)
               ->  Dynamic Index Scan Backward using part_index_eda on test_partition_table  (cost=0.00..8.45 rows=3333 width=20) (actual time=1.678..1.685 rows=3 loops=1)
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 3.455 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 47K bytes avg x 3 workers, 47K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 3.834 ms
(13 rows)

select e,d,a from test_partition_table order by e nulls first, d desc, a limit 3;
  e   |        d         |  a   
------+------------------+------
      |                  | 9999
 1600 | sample_text 8004 | 8004
 1600 | sample_text 8003 | 8003
(3 rows)

explain analyze select e,d from test_partition_table order by e nulls first, d desc limit 3;
                                                                                 QUERY PLAN
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..8.55 rows=3 width=16) (actual time=1.179..1.184 rows=3 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..8.55 rows=3 width=16) (actual time=1.178..1.183 rows=3 loops=1)
         Merge Key: e, d
         ->  Limit  (cost=0.00..8.55 rows=1 width=16) (actual time=0.649..0.653 rows=3 loops=1)
               ->  Dynamic Index Scan Backward using part_index_eda on test_partition_table  (cost=0.00..8.45 rows=3333 width=16) (actual time=0.648..0.651 rows=3 loops=1)
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 3.258 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 45K bytes avg x 3 workers, 45K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 1.563 ms
(13 rows)

select e,d from test_partition_table order by e nulls first, d desc limit 3;
  e   |        d         
------+------------------
      | 
 1600 | sample_text 8004
 1600 | sample_text 8003
(3 rows)

-- Validate if DynamicIndexScan works on covering index
-- Expected to choose Forward DynamicIndexScan
explain analyze select c from test_partition_table order by c desc limit 3;
                                                                                QUERY PLAN
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..7.45 rows=3 width=8) (actual time=2.954..2.956 rows=3 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..7.45 rows=3 width=8) (actual time=2.954..2.955 rows=3 loops=1)
         Merge Key: c
         ->  Limit  (cost=0.00..7.45 rows=1 width=8) (actual time=1.865..1.875 rows=3 loops=1)
               ->  Dynamic Index Scan using part_covering_index_cb on test_partition_table  (cost=0.00..7.40 rows=3333 width=8) (actual time=1.863..1.869 rows=3 loops=1)
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 3.147 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 45K bytes avg x 3 workers, 45K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 3.461 ms
(13 rows)

select c from test_partition_table order by c desc limit 3;
         c          
--------------------
 475.95238095238096
  475.7142857142857
  475.4761904761905
(3 rows)

-- Expected to choose Backward DynamicIndexScan
explain analyze select c from test_partition_table order by c limit 3;
                                                                                    QUERY PLAN
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..7.45 rows=3 width=8) (actual time=2.312..2.314 rows=3 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..7.45 rows=3 width=8) (actual time=2.312..2.313 rows=3 loops=1)
         Merge Key: c
         ->  Limit  (cost=0.00..7.45 rows=1 width=8) (actual time=1.157..1.161 rows=3 loops=1)
               ->  Dynamic Index Scan Backward using part_covering_index_cb on test_partition_table  (cost=0.00..7.40 rows=3333 width=8) (actual time=1.154..1.157 rows=3 loops=1)
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 3.122 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 45K bytes avg x 3 workers, 45K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 2.712 ms
(13 rows)

select c from test_partition_table order by c limit 3;
         c          
--------------------
 1904.7619047619048
               1905
 1905.2380952380952
(3 rows)

-- Negative tests: Validate if a DynamicSeqScan is chosen if order by cols directions do not matching indices keys directions.
--                 Expected to choose DynamicSeqScan with Sort
-- Testing various permutations that are not matching keys in 'part_index_a'
explain(costs off) select a from test_partition_table order by a limit 3;
                              QUERY PLAN
----------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Sort
                     Sort Key: a
                     ->  Dynamic Seq Scan on test_partition_table
                           Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

select a from test_partition_table order by a  limit 3;
 a 
---
 1
 2
 3
(3 rows)

-- Testing various permutations that are not matching keys in 'part_index_bcd'
explain(costs off) select b,c,d from test_partition_table order by b ,c desc,d desc limit 3;
                              QUERY PLAN
----------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, c, d
         ->  Limit
               ->  Sort
                     Sort Key: b, c DESC, d DESC
                     ->  Dynamic Seq Scan on test_partition_table
                           Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

select b,c,d from test_partition_table order by b ,c desc,d desc limit 3;
 b |          c          |       d       
---+---------------------+---------------
 4 | 0.23809523809523808 | sample_text 1
 5 | 0.47619047619047616 | sample_text 2
 6 |  0.7142857142857143 | sample_text 3
(3 rows)

explain(costs off) select b,c,d from test_partition_table order by b ,c ,d desc limit 3;
                              QUERY PLAN
----------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, c, d
         ->  Limit
               ->  Sort
                     Sort Key: b, c, d DESC
                     ->  Dynamic Seq Scan on test_partition_table
                           Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

select b,c,d from test_partition_table order by b ,c ,d desc limit 3;
 b |          c          |       d       
---+---------------------+---------------
 4 | 0.23809523809523808 | sample_text 1
 5 | 0.47619047619047616 | sample_text 2
 6 |  0.7142857142857143 | sample_text 3
(3 rows)

explain(costs off) select b,c,d from test_partition_table order by b desc, c ,d desc limit 3;
                              QUERY PLAN
----------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b, c, d
         ->  Limit
               ->  Sort
                     Sort Key: b DESC, c, d DESC
                     ->  Dynamic Seq Scan on test_partition_table
                           Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

select b,c,d from test_partition_table order by b desc, c ,d desc limit 3;
   b   |         c          |        d         
-------+--------------------+------------------
       |                    | 
 10001 | 2380.4761904761904 | sample_text 9998
 10000 | 2380.2380952380954 | sample_text 9997
(3 rows)

-- Testing various permutations that are not matching keys in 'part_index_fde'
explain(costs off) select f,d,e from test_partition_table order by f ,d desc,e desc limit 3;
                              QUERY PLAN
----------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: f, d, e
         ->  Limit
               ->  Sort
                     Sort Key: f, d DESC, e DESC
                     ->  Dynamic Seq Scan on test_partition_table
                           Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

select f,d,e from test_partition_table order by f ,d desc,e desc limit 3;
 f |       d       | e 
---+---------------+---
 1 | sample_text 1 | 0
 2 | sample_text 2 | 0
 3 | sample_text 3 | 0
(3 rows)

explain(costs off) select f,d,e from test_partition_table order by f,d ,e desc limit 3;
                              QUERY PLAN
----------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: f, d, e
         ->  Limit
               ->  Sort
                     Sort Key: f, d, e DESC
                     ->  Dynamic Seq Scan on test_partition_table
                           Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

select f,d,e from test_partition_table order by f,d ,e desc limit 3;
 f |       d       | e 
---+---------------+---
 1 | sample_text 1 | 0
 2 | sample_text 2 | 0
 3 | sample_text 3 | 0
(3 rows)

explain(costs off) select f,d,e from test_partition_table order by f desc, d ,e desc limit 3;
                              QUERY PLAN
----------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: f, d, e
         ->  Limit
               ->  Sort
                     Sort Key: f DESC, d, e DESC
                     ->  Dynamic Seq Scan on test_partition_table
                           Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

select f,d,e from test_partition_table order by f desc, d ,e desc limit 3;
  f   |        d         |  e   
------+------------------+------
      |                  |     
 9998 | sample_text 9998 | 1999
 9997 | sample_text 9997 | 1999
(3 rows)

-- Testing various permutations that are not matching keys in 'part_index_eda'
explain(costs off) select e,d,a from test_partition_table order by e, d desc,a desc limit 3;
                              QUERY PLAN
----------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d, a
         ->  Limit
               ->  Sort
                     Sort Key: e, d DESC, a DESC
                     ->  Dynamic Seq Scan on test_partition_table
                           Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

select e,d,a from test_partition_table order by e, d desc,a desc limit 3;
 e |       d       | a 
---+---------------+---
 0 | sample_text 4 | 4
 0 | sample_text 3 | 3
 0 | sample_text 2 | 2
(3 rows)

explain(costs off) select e,d,a from test_partition_table order by e desc,d desc,a desc limit 3;
                              QUERY PLAN
----------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d, a
         ->  Limit
               ->  Sort
                     Sort Key: e DESC, d DESC, a DESC
                     ->  Dynamic Seq Scan on test_partition_table
                           Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

select e,d,a from test_partition_table order by e desc,d desc,a desc limit 3;
  e   |        d         |  a   
------+------------------+------
      |                  | 9999
 1999 | sample_text 9998 | 9998
 1999 | sample_text 9997 | 9997
(3 rows)

explain(costs off) select e,d,a from test_partition_table order by e ,d ,a  limit 3;
                              QUERY PLAN
----------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d, a
         ->  Limit
               ->  Sort
                     Sort Key: e, d, a
                     ->  Dynamic Seq Scan on test_partition_table
                           Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

select e,d,a from test_partition_table order by e ,d ,a  limit 3;
 e |       d       | a 
---+---------------+---
 0 | sample_text 1 | 1
 0 | sample_text 2 | 2
 0 | sample_text 3 | 3
(3 rows)

-- -- Testing various permutations of order by on non-index columns. Expected to choose DynamicSeqScan with Sort
explain(costs off) select d from test_partition_table order by d limit 3;
                              QUERY PLAN
----------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: d
         ->  Limit
               ->  Sort
                     Sort Key: d
                     ->  Dynamic Seq Scan on test_partition_table
                           Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

select d from test_partition_table order by d limit 3;
        d        
-----------------
 sample_text 1
 sample_text 10
 sample_text 100
(3 rows)

explain(costs off) select a,e from test_partition_table order by a,e limit 3;
                              QUERY PLAN
----------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a, e
         ->  Limit
               ->  Sort
                     Sort Key: a, e
                     ->  Dynamic Seq Scan on test_partition_table
                           Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

select a,e from test_partition_table order by a,e limit 3;
 a | e 
---+---
 1 | 0
 2 | 0
 3 | 0
(3 rows)

explain(costs off) select d,a from test_partition_table order by d,a desc limit 3;
                              QUERY PLAN
----------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: d, a
         ->  Limit
               ->  Sort
                     Sort Key: d, a DESC
                     ->  Dynamic Seq Scan on test_partition_table
                           Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

select d,a from test_partition_table order by d,a desc limit 3;
        d        |  a  
-----------------+-----
 sample_text 1   |   1
 sample_text 10  |  10
 sample_text 100 | 100
(3 rows)

explain(costs off) select d,c from test_partition_table order by d desc,c limit 3;
                              QUERY PLAN
----------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: d, c
         ->  Limit
               ->  Sort
                     Sort Key: d DESC, c
                     ->  Dynamic Seq Scan on test_partition_table
                           Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

select d,c from test_partition_table order by d desc,c limit 3;
        d         |         c          
------------------+--------------------
                  |                   
 sample_text 9998 | 2380.4761904761904
 sample_text 9997 | 2380.2380952380954
(3 rows)

-- Purpose: Validate if DynamicIndexOnlyScan Forward/Backward is chosen when required for queries with order by and limit
-- Vacuum table to ensure DynamicIndexOnlyScans are choosen
vacuum test_partition_table;
-- Testing various permutations of order by columns that are expected to choose DynamicIndexOnlyScan Forward
explain analyze select a from test_partition_table order by a nulls first limit 3;
                                                                             QUERY PLAN
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..6.57 rows=3 width=4) (actual time=1.366..1.369 rows=3 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..6.57 rows=3 width=4) (actual time=1.365..1.366 rows=3 loops=1)
         Merge Key: a
         ->  Limit  (cost=0.00..6.57 rows=1 width=4) (actual time=0.614..0.618 rows=3 loops=1)
               ->  Dynamic Index Only Scan using part_index_a on test_partition_table  (cost=0.00..6.55 rows=3333 width=4) (actual time=0.613..0.615 rows=3 loops=1)
                     Heap Fetches: 0
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 8.336 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 108K bytes avg x 3 workers, 108K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 1.915 ms
(14 rows)

select a from test_partition_table order by a nulls first limit 3;
 a 
---
 1
 2
 3
(3 rows)

explain analyze select e,d,a from test_partition_table order by e desc nulls last, d limit 3;
                                                                               QUERY PLAN
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..7.77 rows=3 width=20) (actual time=2.710..2.714 rows=3 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..7.77 rows=3 width=20) (actual time=2.708..2.711 rows=3 loops=1)
         Merge Key: e, d
         ->  Limit  (cost=0.00..7.77 rows=1 width=20) (actual time=2.010..2.014 rows=3 loops=1)
               ->  Dynamic Index Only Scan using part_index_eda on test_partition_table  (cost=0.00..7.65 rows=3333 width=20) (actual time=2.008..2.010 rows=3 loops=1)
                     Heap Fetches: 0
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 5.335 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 110K bytes avg x 3 workers, 110K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 3.208 ms
(14 rows)

select e,d,a from test_partition_table order by e desc nulls last, d limit 3;
  e  |        d         |  a   
-----+------------------+------
 399 | sample_text 1995 | 1995
 399 | sample_text 1996 | 1996
 399 | sample_text 1997 | 1997
(3 rows)

-- Testing various permutations of order by columns that are expected to choose DynamicIndexOnlyScan Backward
explain analyze select a from test_partition_table order by a desc nulls last limit 3;
                                                                                  QUERY PLAN
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..6.57 rows=3 width=4) (actual time=1.407..1.408 rows=3 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..6.57 rows=3 width=4) (actual time=1.406..1.406 rows=3 loops=1)
         Merge Key: a
         ->  Limit  (cost=0.00..6.57 rows=1 width=4) (actual time=0.754..0.757 rows=3 loops=1)
               ->  Dynamic Index Only Scan Backward using part_index_a on test_partition_table  (cost=0.00..6.55 rows=3333 width=4) (actual time=0.752..0.754 rows=3 loops=1)
                     Heap Fetches: 0
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 3.477 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 108K bytes avg x 3 workers, 108K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 1.878 ms
(14 rows)

select a from test_partition_table order by a desc nulls last limit 3;
  a   
------
 9999
 9998
 9997
(3 rows)

explain analyze select e,d,a from test_partition_table order by e nulls first, d desc, a limit 3;
                                                                                   QUERY PLAN
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..7.77 rows=3 width=20) (actual time=1.521..1.525 rows=3 loops=1)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..7.77 rows=3 width=20) (actual time=1.520..1.524 rows=3 loops=1)
         Merge Key: e, d, a
         ->  Limit  (cost=0.00..7.77 rows=1 width=20) (actual time=0.859..0.862 rows=3 loops=1)
               ->  Dynamic Index Only Scan Backward using part_index_eda on test_partition_table  (cost=0.00..7.65 rows=3333 width=20) (actual time=0.857..0.859 rows=3 loops=1)
                     Heap Fetches: 0
                     Number of partitions to scan: 5 (out of 5)
                     Partitions scanned:  Avg 1.0 x 3 workers.  Max 1 parts (seg0).
 Optimizer: Pivotal Optimizer (GPORCA)
 Planning Time: 4.172 ms
   (slice0)    Executor memory: 38K bytes.
   (slice1)    Executor memory: 110K bytes avg x 3 workers, 110K bytes max (seg0).
 Memory used:  128000kB
 Execution Time: 2.018 ms
(14 rows)

select f,d,e from test_partition_table order by e nulls first, d desc, a limit 3;
  f   |        d         |  e   
------+------------------+------
      |                  |     
 8004 | sample_text 8004 | 1600
 8003 | sample_text 8003 | 1600
(3 rows)

-- Clean Up
DROP TABLE test_partition_table;
-- Test Case: Test on a Replicated table with mixed data type columns.
-- Purpose: Validate if Forward/Backward IndexScan works on Replicated table
CREATE TABLE test_replicated_table(a int, b int, c float, d text, e numeric) DISTRIBUTED REPLICATED;
-- multi col index with mixed index keys properties
CREATE INDEX rep_index_eda on test_replicated_table using btree(e desc nulls last, d,a desc);
INSERT INTO test_replicated_table SELECT i, i+3, i/4.2, concat('sample_text ',i), i/5 from generate_series(1,100) i;
-- Inserting nulls to verify results match when index key specifies nulls first or desc
INSERT INTO test_replicated_table values (null, null, null, null, null);
-- Positive tests: Validate if IndexScan Forward/Backward is chosen.
-- Validate if 'rep_index_eda' is used for order by matching to the index
explain(costs off) select e,d,a from test_replicated_table order by e desc nulls last, d, a desc limit 3;
                             QUERY PLAN
---------------------------------------------------------------------
 Limit
   ->  Gather Motion 1:1  (slice1; segments: 1)
         Merge Key: e, d, a
         ->  Index Scan using rep_index_eda on test_replicated_table
 Optimizer: Pivotal Optimizer (GPORCA)
(5 rows)

select e,d,a from test_replicated_table order by e desc nulls last, d, a desc limit 3;
 e  |        d        |  a  
----+-----------------+-----
 20 | sample_text 100 | 100
 19 | sample_text 95  |  95
 19 | sample_text 96  |  96
(3 rows)

-- Validate if 'rep_index_eda' is used for order by commutative to the index
explain(costs off) select e,d,a from test_replicated_table order by e nulls first, d desc, a limit 3;
                                  QUERY PLAN
------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 1:1  (slice1; segments: 1)
         Merge Key: e, d, a
         ->  Index Scan Backward using rep_index_eda on test_replicated_table
 Optimizer: Pivotal Optimizer (GPORCA)
(5 rows)

select e,d,a from test_replicated_table order by e nulls first, d desc, a limit 3;
 e |       d       | a 
---+---------------+---
   |               |  
 0 | sample_text 4 | 4
 0 | sample_text 3 | 3
(3 rows)

-- Negative tests: Validate if a SeqScan is chosen for order by cols not matching any indices. Expected to choose SeqScan with Sort
explain(costs off) select d,a from test_replicated_table order by d,a desc limit 3;
                     QUERY PLAN
-----------------------------------------------------
 Limit
   ->  Gather Motion 1:1  (slice1; segments: 1)
         Merge Key: d, a
         ->  Sort
               Sort Key: d, a DESC
               ->  Seq Scan on test_replicated_table
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

select d,a from test_replicated_table order by d,a desc limit 3;
        d        |  a  
-----------------+-----
 sample_text 1   |   1
 sample_text 10  |  10
 sample_text 100 | 100
(3 rows)

-- Clean Up
DROP TABLE test_replicated_table;
-- Test Case: Test on AO table with mixed data type columns.
-- ORCA_FEATURE_NOT_SUPPORTED: IndexScans not supported on AO tables
CREATE TABLE test_ao_table(a int, b int, c float, d text, e numeric) WITH (appendonly=true) DISTRIBUTED BY (a);
-- multi col index with mixed index keys properties
CREATE INDEX ao_index_eda on test_ao_table using btree(e desc nulls last, d,a desc);
INSERT INTO test_ao_table SELECT i, i+3, i/4.2, concat('sample_text ',i), i/5 from generate_series(1,100) i;
-- Expected to choose SeqScan with a Sort as it is an AO table
explain(costs off) select e,d,a from test_ao_table order by e desc nulls last, d, a desc limit 3;
                      QUERY PLAN
------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e, d, a
         ->  Sort
               Sort Key: e DESC NULLS LAST, d, a DESC
               ->  Seq Scan on test_ao_table
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

select e,d,a from test_ao_table order by e desc nulls last, d, a desc limit 3;
 e  |        d        |  a  
----+-----------------+-----
 20 | sample_text 100 | 100
 19 | sample_text 95  |  95
 19 | sample_text 96  |  96
(3 rows)

-- Clean Up
DROP TABLE test_ao_table;
-- Test Case: Test on table with all other types of indexes apart from btree(bitmap, hash, brin, spgist, gist, gin)
-- Purpose: Evaluate if Forward/Backward IndexScan works on query with order by and limit, with other type of indices
-- Note: No other index type apart from btree support IndexScans
CREATE TABLE test_multi_index_types_table(a int, b int, c float, d text, e tsquery, f tsvector);
-- create a bitmap index
create index bitmap_a on test_multi_index_types_table using bitmap(a);
-- create a hash index
create index hash_b on test_multi_index_types_table using hash(b);
-- create a brin index
create index brin_c on test_multi_index_types_table using brin(c);
-- create a spgist index
create index spgist_d on test_multi_index_types_table using spgist(d);
-- create a gin index
create index gist_e on test_multi_index_types_table using gist(e);
-- create a gin index
create index gin_f on test_multi_index_types_table using gin(f);
-- All of the below queries are expected to use SeqScan with a Sort as only btree index supports IndexScan
explain(costs off) select a from test_multi_index_types_table order by a limit 3;
                         QUERY PLAN
------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Sort
               Sort Key: a
               ->  Seq Scan on test_multi_index_types_table
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

explain(costs off) select b from test_multi_index_types_table order by b limit 3;
                         QUERY PLAN
------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b
         ->  Sort
               Sort Key: b
               ->  Seq Scan on test_multi_index_types_table
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

explain(costs off) select c from test_multi_index_types_table order by c limit 3;
                         QUERY PLAN
------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c
         ->  Sort
               Sort Key: c
               ->  Seq Scan on test_multi_index_types_table
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

explain(costs off) select d from test_multi_index_types_table order by d limit 3;
                         QUERY PLAN
------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: d
         ->  Sort
               Sort Key: d
               ->  Seq Scan on test_multi_index_types_table
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

explain(costs off) select e from test_multi_index_types_table order by e limit 3;
                         QUERY PLAN
------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: e
         ->  Sort
               Sort Key: e
               ->  Seq Scan on test_multi_index_types_table
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

explain(costs off) select f from test_multi_index_types_table order by f limit 3;
                         QUERY PLAN
------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: f
         ->  Sort
               Sort Key: f
               ->  Seq Scan on test_multi_index_types_table
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

-- Clean Up
DROP TABLE test_multi_index_types_table;
-- Purpose: Test Forward/Backward IndexScan over views
create table test_on_views(a int, b int, c float);
INSERT INTO test_on_views SELECT i+3, i, i/4.2 from generate_series(1,100) i;
-- create a index on column b
create index view_index on test_on_views using btree(b);
analyze test_on_views;
-- create view
create view test_view as select b from test_on_views;
-- Expected to use IndexScan Forward
explain(costs off) select * from test_view order by b limit 3;
                           QUERY PLAN
----------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b
         ->  Limit
               ->  Index Scan using view_index on test_on_views
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select * from test_view order by b limit 3;
 b 
---
 1
 2
 3
(3 rows)

-- Expected to use IndexScan Backwards
explain(costs off) select * from test_view order by b desc limit 3;
                               QUERY PLAN
-------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b
         ->  Limit
               ->  Index Scan Backward using view_index on test_on_views
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select * from test_view order by b desc limit 3;
  b  
-----
 100
  99
  98
(3 rows)

-- Clean Up
DROP VIEW test_view;
DROP TABLE test_on_views;
-- Purpose: Test Forward/Backward IndexScan over partial indices
-- ORCA_FEATURE_NOT_SUPPORTED: partial indexes are not supported
create table test_on_partial_indices(a int, b int, c float);
-- create a partial index on column b
create index partial_index on test_on_partial_indices(b desc) where b<54;
analyze test_on_partial_indices;
-- Expected to use SeqScan with Sort
explain(costs off) select b from test_on_partial_indices order by b desc limit 3;
                      QUERY PLAN
-------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: b
         ->  Sort
               Sort Key: b DESC
               ->  Seq Scan on test_on_partial_indices
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

-- Clean Up
DROP TABLE test_on_partial_indices;
-- Purpose: Test Forward/Backward IndexScan over primary key
create table test_on_pk_column(a int primary key , b int, c float);
INSERT INTO test_on_pk_column SELECT i+3, i, i/4.2 from generate_series(1,100) i;
analyze test_on_pk_column;
-- Expected to use Forward IndexScan
explain(costs off) select a from test_on_pk_column order by a limit 3;
                                   QUERY PLAN
--------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Index Scan using test_on_pk_column_pkey on test_on_pk_column
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select a from test_on_pk_column order by a limit 3;
 a 
---
 4
 5
 6
(3 rows)

-- Expected to use Backward IndexScan
explain(costs off) select a from test_on_pk_column order by a desc limit 3;
                                       QUERY PLAN
-----------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  Index Scan Backward using test_on_pk_column_pkey on test_on_pk_column
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select a from test_on_pk_column order by a desc limit 3;
  a  
-----
 103
 102
 101
(3 rows)

-- Clean Up
DROP TABLE test_on_pk_column;
-- Purpose: Test Forward/Backward IndexScan over column with unique constraint
create table test_on_unique_column(a int, b int unique, c float);
INSERT INTO test_on_unique_column SELECT i+3, i, i/4.2 from generate_series(1,100) i;
analyze test_on_unique_column;
-- Expected to use Forward IndexScan
explain(costs off) select a from test_on_unique_column order by b limit 3;
                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Result
   ->  Limit
         ->  Gather Motion 3:1  (slice1; segments: 3)
               Merge Key: b
               ->  Limit
                     ->  Index Scan using test_on_unique_column_b_key on test_on_unique_column
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

select a from test_on_unique_column order by b limit 3;
 a 
---
 4
 5
 6
(3 rows)

-- Expected to use Backward IndexScan
explain(costs off) select a from test_on_unique_column order by b desc limit 3;
                                               QUERY PLAN
--------------------------------------------------------------------------------------------------------
 Result
   ->  Limit
         ->  Gather Motion 3:1  (slice1; segments: 3)
               Merge Key: b
               ->  Limit
                     ->  Index Scan Backward using test_on_unique_column_b_key on test_on_unique_column
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

select a from test_on_unique_column order by b desc limit 3;
  a  
-----
 103
 102
 101
(3 rows)

-- Clean Up
DROP TABLE test_on_unique_column;
-- Purpose: Test Forward/Backward IndexScan with order by on Index Expressions
-- ORCA_FEATURE_NOT_SUPPORTED: Indexes on Expressions are not supported by ORCA
create table test_on_index_expressions(a int, b int, c float);
CREATE INDEX expr_index_a on test_on_index_expressions using btree(a);
analyze test_on_index_expressions;
-- Expected to use SeqScan with Sort
explain(costs off) select a,b from test_on_index_expressions order by a*b desc limit 3;
                          QUERY PLAN
---------------------------------------------------------------
 Result
   ->  Limit
         ->  Gather Motion 3:1  (slice1; segments: 3)
               Merge Key: ((a * b))
               ->  Sort
                     Sort Key: ((a * b)) DESC
                     ->  Seq Scan on test_on_index_expressions
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

-- Expected to use SeqScan with Sort
explain(costs off) select a from test_on_index_expressions order by a|2 limit 3;
                          QUERY PLAN
---------------------------------------------------------------
 Result
   ->  Limit
         ->  Gather Motion 3:1  (slice1; segments: 3)
               Merge Key: ((a | 2))
               ->  Sort
                     Sort Key: ((a | 2))
                     ->  Seq Scan on test_on_index_expressions
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

-- Expected to use SeqScan with Sort
explain(costs off) select a from test_on_index_expressions order by a is not null desc limit 3;
                          QUERY PLAN
---------------------------------------------------------------
 Result
   ->  Limit
         ->  Gather Motion 3:1  (slice1; segments: 3)
               Merge Key: ((NOT (a IS NULL)))
               ->  Sort
                     Sort Key: ((NOT (a IS NULL))) DESC
                     ->  Seq Scan on test_on_index_expressions
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

-- Expected to use SeqScan with Sort
explain(costs off) select a from test_on_index_expressions order by a>3 limit 3;
                          QUERY PLAN
---------------------------------------------------------------
 Result
   ->  Limit
         ->  Gather Motion 3:1  (slice1; segments: 3)
               Merge Key: ((a > 3))
               ->  Sort
                     Sort Key: ((a > 3))
                     ->  Seq Scan on test_on_index_expressions
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

-- define a simple multiplication function
CREATE OR REPLACE FUNCTION multiply_by_two(integer)
RETURNS INTEGER
LANGUAGE 'plpgsql'
AS $$
BEGIN
RETURN $1 * 2;
END;
$$;
-- Order by using multiplication function. Expected to use SeqScan with Sort
explain(costs off) select a from test_on_index_expressions order by multiply_by_two(a) limit 3;
                          QUERY PLAN
---------------------------------------------------------------
 Result
   ->  Limit
         ->  Gather Motion 3:1  (slice1; segments: 3)
               Merge Key: (multiply_by_two(a))
               ->  Sort
                     Sort Key: (multiply_by_two(a))
                     ->  Seq Scan on test_on_index_expressions
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

-- Clean Up
DROP TABLE test_on_index_expressions;
-- Purpose: Test Forward/Backward IndexScan with order by on custom data type
-- create a custom type
CREATE TYPE person_type AS (
    name VARCHAR,
    age INTEGER);
create table test_on_custom_data_type(a int, b float, c person_type);
create index index_on_custom_type on test_on_custom_data_type using btree(c);
insert into test_on_custom_data_type select i, i/3, (concat('person', i), i)::person_type from generate_series(1,100)i;
analyze test_on_custom_data_type;
-- Expected to use Forward IndexScan
explain(costs off) select c from test_on_custom_data_type order by c limit 3;
                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c
         ->  Limit
               ->  Index Scan using index_on_custom_type on test_on_custom_data_type
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select c from test_on_custom_data_type order by c limit 3;
        c        
-----------------
 (person1,1)
 (person10,10)
 (person100,100)
(3 rows)

-- Expected to use Backward IndexScan
explain(costs off) select c from test_on_custom_data_type order by c desc limit 3;
                                          QUERY PLAN
----------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c
         ->  Limit
               ->  Index Scan Backward using index_on_custom_type on test_on_custom_data_type
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

select c from test_on_custom_data_type order by c desc limit 3;
       c       
---------------
 (person99,99)
 (person98,98)
 (person97,97)
(3 rows)

-- Clean Up
DROP TABLE test_on_custom_data_type;
-- Purpose: This section includes tests on general table where backward index scan could be used, but is not used currently since
--          those cases are not supported as part of this initial addition of backward index support.
CREATE TABLE test_yet_unsupported_backwrd_idxscan_cases (a int, b text, c float, d int, e int);
-- single col index with default order
CREATE INDEX index_a on test_yet_unsupported_backwrd_idxscan_cases using btree(a);
-- single col index with reverse order
CREATE INDEX index_b on test_yet_unsupported_backwrd_idxscan_cases using btree(b desc);
CREATE INDEX index_cd on test_yet_unsupported_backwrd_idxscan_cases using btree(c, d);
-- Inserting data to demonstrate that Planner chooses IndexScans for these cases
INSERT INTO test_yet_unsupported_backwrd_idxscan_cases select i, concat('sample_text', i), i/3.3, i,i-2 from generate_series(1,10000)i;
ANALYZE test_yet_unsupported_backwrd_idxscan_cases;
-- Cases with just order by without limit
explain(costs off) select a from test_yet_unsupported_backwrd_idxscan_cases order by a desc;
                             QUERY PLAN
--------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: a
   ->  Sort
         Sort Key: a DESC
         ->  Seq Scan on test_yet_unsupported_backwrd_idxscan_cases
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

explain(costs off) select c,d from test_yet_unsupported_backwrd_idxscan_cases order by c desc, d desc;
                             QUERY PLAN
--------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: c, d
   ->  Sort
         Sort Key: c DESC, d DESC
         ->  Seq Scan on test_yet_unsupported_backwrd_idxscan_cases
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

-- Since col a is asc in index, max(a) could use a backward index scan
explain(costs off) select max(a) from test_yet_unsupported_backwrd_idxscan_cases;
                                QUERY PLAN
--------------------------------------------------------------------------
 Finalize Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Partial Aggregate
               ->  Seq Scan on test_yet_unsupported_backwrd_idxscan_cases
 Optimizer: Pivotal Optimizer (GPORCA)
(5 rows)

-- Cases with a predicate and order by (with/without limit). Order by columns commutating index column
explain(costs off) select * from test_yet_unsupported_backwrd_idxscan_cases where a>997 order by c desc, d desc;
                                     QUERY PLAN
------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: c, d
   ->  Sort
         Sort Key: c DESC, d DESC
         ->  Index Scan using index_a on test_yet_unsupported_backwrd_idxscan_cases
               Index Cond: (a > 997)
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

explain(costs off) select * from test_yet_unsupported_backwrd_idxscan_cases where a>997 order by c desc, d desc limit 3;
                                           QUERY PLAN
------------------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c, d
         ->  Limit
               ->  Sort
                     Sort Key: c DESC, d DESC
                     ->  Index Scan using index_a on test_yet_unsupported_backwrd_idxscan_cases
                           Index Cond: (a > 997)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

-- Cases with group by, order by (with/without limit). Order by cols commutating index column
explain(costs off) select  a, sum(d) from test_yet_unsupported_backwrd_idxscan_cases group by a order by a desc;
                                QUERY PLAN
--------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: a
   ->  GroupAggregate
         Group Key: a
         ->  Sort
               Sort Key: a DESC
               ->  Seq Scan on test_yet_unsupported_backwrd_idxscan_cases
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

explain(costs off) select  a, sum(d) from test_yet_unsupported_backwrd_idxscan_cases group by a order by a desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  GroupAggregate
                     Group Key: a
                     ->  Sort
                           Sort Key: a DESC
                           ->  Seq Scan on test_yet_unsupported_backwrd_idxscan_cases
 Optimizer: Pivotal Optimizer (GPORCA)
(10 rows)

-- Case with group by, order by and a having clause (with/without limit). Order by cols commutating index.
explain(costs off) select  a, sum(d) from test_yet_unsupported_backwrd_idxscan_cases group by a having a>30 order by a desc;
                                        QUERY PLAN
------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: a
   ->  GroupAggregate
         Group Key: a
         ->  Sort
               Sort Key: a DESC
               ->  Index Scan using index_a on test_yet_unsupported_backwrd_idxscan_cases
                     Index Cond: (a > 30)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

explain(costs off) select  a, sum(d) from test_yet_unsupported_backwrd_idxscan_cases group by a having a>30 order by a desc;
                                        QUERY PLAN
------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: a
   ->  GroupAggregate
         Group Key: a
         ->  Sort
               Sort Key: a DESC
               ->  Index Scan using index_a on test_yet_unsupported_backwrd_idxscan_cases
                     Index Cond: (a > 30)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

-- Case with ordering via over() using window aggregates (with/without limit): rank(), row_number(), percent_rank() etc...
explain(costs off) select c,d, rank() over (order by c desc, d desc) from test_yet_unsupported_backwrd_idxscan_cases;
                                QUERY PLAN
--------------------------------------------------------------------------
 WindowAgg
   Order By: c, d
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c, d
         ->  Sort
               Sort Key: c DESC, d DESC
               ->  Seq Scan on test_yet_unsupported_backwrd_idxscan_cases
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

explain(costs off) select c,d, rank() over (order by c desc, d desc) from test_yet_unsupported_backwrd_idxscan_cases limit 3;
                                   QUERY PLAN
--------------------------------------------------------------------------------
 Limit
   ->  WindowAgg
         Order By: c, d
         ->  Gather Motion 3:1  (slice1; segments: 3)
               Merge Key: c, d
               ->  Sort
                     Sort Key: c DESC, d DESC
                     ->  Seq Scan on test_yet_unsupported_backwrd_idxscan_cases
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

-- Case with distinct and order by (with/without limit)
explain(costs off) select distinct(a) from test_yet_unsupported_backwrd_idxscan_cases order by a desc;
                                QUERY PLAN
--------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: a
   ->  GroupAggregate
         Group Key: a
         ->  Sort
               Sort Key: a DESC
               ->  Seq Scan on test_yet_unsupported_backwrd_idxscan_cases
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

explain(costs off) select distinct(a) from test_yet_unsupported_backwrd_idxscan_cases order by a desc limit 3;
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  GroupAggregate
                     Group Key: a
                     ->  Sort
                           Sort Key: a DESC
                           ->  Seq Scan on test_yet_unsupported_backwrd_idxscan_cases
 Optimizer: Pivotal Optimizer (GPORCA)
(10 rows)

-- Order by within a CTE without limit
explain(costs off) with sorted_by_cd as (select c,d from test_yet_unsupported_backwrd_idxscan_cases order by c desc, d desc) select c from sorted_by_cd;
                          QUERY PLAN
--------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on test_yet_unsupported_backwrd_idxscan_cases
 Optimizer: Pivotal Optimizer (GPORCA)
(3 rows)

-- Order by within a CTE, with limit outside CTE expression
explain(costs off) with sorted_by_cd as (select c,d from test_yet_unsupported_backwrd_idxscan_cases order by c desc, d desc) select c from sorted_by_cd limit 3;
                                QUERY PLAN
--------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Limit
               ->  Seq Scan on test_yet_unsupported_backwrd_idxscan_cases
 Optimizer: Pivotal Optimizer (GPORCA)
(5 rows)

-- Clean Up
DROP TABLE test_yet_unsupported_backwrd_idxscan_cases;
-- Test Case: NL Joins can utilize IndexScan's sort property, but currently ORCA doesn't generate IndexScan alternatives
--            for NL joins. This tests the case where IndexScan's order property could be used for joining two tables
CREATE TABLE employee(id int, name text, dep_id int, salary int);
CREATE TABLE department(dep_id int, dep_name text);
CREATE INDEX index_salary on employee using btree(salary);
ANALYZE employee;
ANALYZE department;
-- Forcing planner, ORCA to use a NL join
set enable_hashjoin to off;
set optimizer_enable_hashjoin to off;
-- Planner uses NL Join with IndexScan Backwards and the sort property of index 'index_salary',
-- but ORCA, since it doesn't generate IndexScan alternative uses NL join with a Sort operator.
explain(costs off) select e.id, e.name, e.salary, d.dep_name from employee e join department d on e.id=d.dep_id order by e.salary desc;
                          QUERY PLAN
--------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: employee.salary
   ->  Sort
         Sort Key: employee.salary DESC
         ->  Nested Loop
               Join Filter: (employee.id = department.dep_id)
               ->  Seq Scan on employee
               ->  Seq Scan on department
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

explain(costs off) select e.id, e.name, e.salary, d.dep_name from employee e join department d on e.id=d.dep_id order by e.salary desc limit 3;
                             QUERY PLAN
--------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: employee.salary
         ->  Sort
               Sort Key: employee.salary DESC
               ->  Nested Loop
                     Join Filter: (employee.id = department.dep_id)
                     ->  Seq Scan on employee
                     ->  Seq Scan on department
 Optimizer: Pivotal Optimizer (GPORCA)
(10 rows)

-- Clean up
reset enable_hashjoin;
reset optimizer_enable_hashjoin;
DROP TABLE employee;
DROP TABLE department;
-- Test Case: Union all of two tables with order by on their indexed column uses IndexScan's sort property with MergeAppend node
--            in Planner. However in ORCA we don't generate IndexScan alternative for union all, also we don't support MergeAppend.
--            But documenting this case for reference
CREATE TABLE table1(a int, b int);
CREATE TABLE table2(a int, b int);
CREATE INDEX tab1_idx on table1 using btree(b);
CREATE INDEX tab2_idx on table2 using btree(b);
-- inserting data and disabling seq_scan to avoid Planner generating a plan with Sort operator and Append node
-- instead of IndexScan with MergeAppend
set enable_seqscan to off;
INSERT INTO table1 select i, i from generate_series(1,99)i;
INSERT INTO table2 select i, i from generate_series(1,99)i;
ANALYZE table1;
ANALYZE table2;
explain(costs off) select b from table1 union all select b from table2 order by b desc;
                QUERY PLAN
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: table1.b
   ->  Sort
         Sort Key: table1.b DESC
         ->  Append
               ->  Seq Scan on table1
               ->  Seq Scan on table2
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

reset enable_seqscan;
DROP TABLE table1;
DROP TABLE table2;
-- Purpose: This section includes tests on partition table where backward DynamicIndexScan could be used, but is not used currently since
--          those cases are not supported as part of this initial addition of backward index support.
CREATE TABLE test_partition_table(a int, b text, c float, d int, e int) DISTRIBUTED BY (a) PARTITION BY range(a) (start (0) end(10000) every(2000));
-- single col index with opp nulls direction on partition column
CREATE INDEX part_index_a on test_partition_table using btree(a);
-- multi col index all with all index keys asc
CREATE INDEX part_index_b on test_partition_table using btree(b desc);
-- multi col index all with all index keys desc
CREATE INDEX part_index_cd on test_partition_table using btree(c,d);
-- Inserting data to demonstrate that Planner chooses IndexScans for these cases
INSERT INTO test_partition_table select i, concat('sample_text', i), i/3.3, i,i-2 from generate_series(1,9999)i;
ANALYZE test_partition_table;
-- Cases with just order by without limit
explain(costs off) select a from test_partition_table order by a desc;
                        QUERY PLAN
----------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: a
   ->  Sort
         Sort Key: a DESC
         ->  Dynamic Seq Scan on test_partition_table
               Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

explain(costs off) select c,d from test_partition_table order by c desc, d desc;
                        QUERY PLAN
----------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: c, d
   ->  Sort
         Sort Key: c DESC, d DESC
         ->  Dynamic Seq Scan on test_partition_table
               Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(7 rows)

-- Since col a is asc in index, max(a) could use a backward index scan
explain(costs off) select max(a) from test_partition_table;
                           QUERY PLAN
----------------------------------------------------------------
 Finalize Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Partial Aggregate
               ->  Dynamic Seq Scan on test_partition_table
                     Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

-- Cases with a predicate and order by (with/without limit). Order by columns commutating index column
explain(costs off) select * from test_partition_table where a BETWEEN 40 and 4000 or c not between 4000 and 6000 order by c desc, d desc;
                                                       QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: c, d
   ->  Sort
         Sort Key: c DESC, d DESC
         ->  Dynamic Seq Scan on test_partition_table
               Number of partitions to scan: 5 (out of 5)
               Filter: (((a >= 40) AND (a <= 4000)) OR (c < '4000'::double precision) OR (c > '6000'::double precision))
 Optimizer: Pivotal Optimizer (GPORCA)
(8 rows)

explain(costs off) select * from test_partition_table where a>7 order by c desc, d desc limit 4;
                                      QUERY PLAN
---------------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c, d
         ->  Limit
               ->  Sort
                     Sort Key: c DESC, d DESC
                     ->  Dynamic Index Scan using part_index_a on test_partition_table
                           Index Cond: (a > 7)
                           Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(10 rows)

-- Cases with group by, order by (with/without limit). Order by cols commutating index column
explain(costs off) select  a, sum(d) from test_partition_table group by a order by a desc;
                           QUERY PLAN
----------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: a
   ->  GroupAggregate
         Group Key: a
         ->  Sort
               Sort Key: a DESC
               ->  Dynamic Seq Scan on test_partition_table
                     Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

explain(costs off) select  a, sum(d) from test_partition_table group by a order by a desc limit 3;
                                 QUERY PLAN
----------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  GroupAggregate
                     Group Key: a
                     ->  Sort
                           Sort Key: a DESC
                           ->  Dynamic Seq Scan on test_partition_table
                                 Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(11 rows)

-- Case with group by, order by and a having clause (with/without limit). Order by cols commutating index.
explain(costs off) select  a, sum(d) from test_partition_table group by a having a>30 order by a desc;
                                   QUERY PLAN
---------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: a
   ->  GroupAggregate
         Group Key: a
         ->  Sort
               Sort Key: a DESC
               ->  Dynamic Index Scan using part_index_a on test_partition_table
                     Index Cond: (a > 30)
                     Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(10 rows)

explain(costs off) select  a, sum(d) from test_partition_table group by a having a>30 order by a desc;
                                   QUERY PLAN
---------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: a
   ->  GroupAggregate
         Group Key: a
         ->  Sort
               Sort Key: a DESC
               ->  Dynamic Index Scan using part_index_a on test_partition_table
                     Index Cond: (a > 30)
                     Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(10 rows)

-- Case with ordering via over() using window aggregates (with/without limit): rank(), row_number(), percent_rank() etc...
explain(costs off) select c,d, rank() over (order by c desc, d desc) from test_partition_table;
                           QUERY PLAN
----------------------------------------------------------------
 WindowAgg
   Order By: c, d
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: c, d
         ->  Sort
               Sort Key: c DESC, d DESC
               ->  Dynamic Seq Scan on test_partition_table
                     Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

explain(costs off) select c,d, rank() over (order by c desc, d desc) from test_partition_table limit 3;
                              QUERY PLAN
----------------------------------------------------------------------
 Limit
   ->  WindowAgg
         Order By: c, d
         ->  Gather Motion 3:1  (slice1; segments: 3)
               Merge Key: c, d
               ->  Sort
                     Sort Key: c DESC, d DESC
                     ->  Dynamic Seq Scan on test_partition_table
                           Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(10 rows)

-- Case with distinct and order by (with/without limit)
explain(costs off) select distinct(a) from test_partition_table order by a desc;
                           QUERY PLAN
----------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: a
   ->  GroupAggregate
         Group Key: a
         ->  Sort
               Sort Key: a DESC
               ->  Dynamic Seq Scan on test_partition_table
                     Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

explain(costs off) select distinct(a) from test_partition_table order by a desc limit 3;
                                 QUERY PLAN
----------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: a
         ->  Limit
               ->  GroupAggregate
                     Group Key: a
                     ->  Sort
                           Sort Key: a DESC
                           ->  Dynamic Seq Scan on test_partition_table
                                 Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(11 rows)

-- Order by within a CTE without limit
explain(costs off) with sorted_by_cd as (select c,d from test_partition_table order by c desc, d desc) select c from sorted_by_cd;
                     QUERY PLAN
----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Dynamic Seq Scan on test_partition_table
         Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(4 rows)

-- Order by within a CTE, with limit outside CTE expression
explain(costs off) with sorted_by_cd as (select c,d from test_partition_table order by c desc, d desc) select c from sorted_by_cd limit 3;
                           QUERY PLAN
----------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Limit
               ->  Dynamic Seq Scan on test_partition_table
                     Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(6 rows)

-- Clean Up
DROP TABLE test_partition_table;
-- Test Case: NL Joins can utilize IndexScan's sort property, but currently ORCA doesn't generate IndexScan alternatives for NL joins.
--            This tests the case where IndexScan's order property could be used for joining two partition tables
CREATE TABLE part_employee(id int, name text, dep_id int, salary int) PARTITION BY range(id) (start (0) end(10000) every(2000));
CREATE TABLE part_department(dep_id int, dep_name text) PARTITION BY range(dep_id) (start (0) end(10000) every(2000));
CREATE INDEX part_index_salary on part_employee using btree(salary);
ANALYZE part_employee;
ANALYZE part_department;
-- Forcing planner, ORCA to use a NL join
set enable_hashjoin to off;
set optimizer_enable_hashjoin to off;
-- Planner uses NL Join with IndexScan Backwards and the sort property of index 'index_salary',
-- but ORCA since doesn't generate IndexScan alternative uses NL join with a Sort operator.
explain(costs off) select e.id, e.name, e.salary, d.dep_name from part_employee e join part_department d on e.id=d.dep_id order by e.salary desc;
                               QUERY PLAN
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: part_employee.salary
   ->  Sort
         Sort Key: part_employee.salary DESC
         ->  Nested Loop
               Join Filter: (part_employee.id = part_department.dep_id)
               ->  Dynamic Seq Scan on part_employee
                     Number of partitions to scan: 5 (out of 5)
               ->  Dynamic Seq Scan on part_department
                     Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(11 rows)

explain(costs off) select e.id, e.name, e.salary, d.dep_name from part_employee e join part_department d on e.id=d.dep_id order by e.salary desc limit 3;
                                  QUERY PLAN
------------------------------------------------------------------------------
 Limit
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Merge Key: part_employee.salary
         ->  Sort
               Sort Key: part_employee.salary DESC
               ->  Nested Loop
                     Join Filter: (part_employee.id = part_department.dep_id)
                     ->  Dynamic Seq Scan on part_employee
                           Number of partitions to scan: 5 (out of 5)
                     ->  Dynamic Seq Scan on part_department
                           Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(12 rows)

-- Clean up
reset enable_hashjoin;
reset optimizer_enable_hashjoin;
DROP TABLE part_employee;
DROP TABLE part_department;
-- Test Case: Union all of two partition tables with order by on their indexed column uses IndexScan's sort property with MergeAppend node
--            in Planner. However in ORCA we don't generate DynamicIndexScan alternative for union all, also we don't support MergeAppend.
--            But documenting this case for reference
CREATE TABLE part_table1(a int, b int) PARTITION BY range(a) (start (0) end(100) every(20));
CREATE TABLE part_table2(a int, b int) PARTITION BY range(a) (start (0) end(100) every(20));
CREATE INDEX part_tab1_idx on part_table1 using btree(b);
CREATE INDEX part_tab2_idx on part_table2 using btree(b);
-- inserting data and disabling seq_scan to avoid Planner generating a plan with Sort operator and Append node
-- instead of IndexScan with MergeAppend
set enable_seqscan to off;
INSERT INTO part_table1 select i, i from generate_series(1,99)i;
INSERT INTO part_table2 select i, i from generate_series(1,99)i;
ANALYZE part_table1;
ANALYZE part_table2;
explain(costs off) select b from part_table1 union all select b from part_table2 order by b desc;
                           QUERY PLAN
----------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Merge Key: part_table1.b
   ->  Sort
         Sort Key: part_table1.b DESC
         ->  Append
               ->  Dynamic Seq Scan on part_table1
                     Number of partitions to scan: 5 (out of 5)
               ->  Dynamic Seq Scan on part_table2
                     Number of partitions to scan: 5 (out of 5)
 Optimizer: Pivotal Optimizer (GPORCA)
(10 rows)

-- Clean Up
reset enable_seqscan;
DROP TABLE part_table1;
DROP TABLE part_table2;
