--
-- Tests on partition pruning (with ORCA) or constraint exclusion (with the
-- Postgres planner). These tests check that you get an "expected" plan, that
-- only scans the partitions that are needed.
--
-- The "correct" plan for a given query depends a lot on the capabilities of
-- the planner and the rest of the system, so the expected output can need
-- updating, as the system improves.
--
-- Set up common test tables.
CREATE TABLE pt_lt_tab
(
  col1 int,
  col2 decimal,
  col3 text,
  col4 bool
)
distributed by (col1)
partition by list(col2)
(
  partition part1 values(1,2,3,4,5,6,7,8,9,10),
  partition part2 values(11,12,13,14,15,16,17,18,19,20),
  partition part3 values(21,22,23,24,25,26,27,28,29,30),
  partition part4 values(31,32,33,34,35,36,37,38,39,40),
  partition part5 values(41,42,43,44,45,46,47,48,49,50)
);
NOTICE:  CREATE TABLE will create partition "pt_lt_tab_1_prt_part1" for table "pt_lt_tab"
NOTICE:  CREATE TABLE will create partition "pt_lt_tab_1_prt_part2" for table "pt_lt_tab"
NOTICE:  CREATE TABLE will create partition "pt_lt_tab_1_prt_part3" for table "pt_lt_tab"
NOTICE:  CREATE TABLE will create partition "pt_lt_tab_1_prt_part4" for table "pt_lt_tab"
NOTICE:  CREATE TABLE will create partition "pt_lt_tab_1_prt_part5" for table "pt_lt_tab"
INSERT INTO pt_lt_tab SELECT i, i,'a',True FROM generate_series(1,3)i;
INSERT INTO pt_lt_tab SELECT i, i,'b',True FROM generate_series(4,6)i;
INSERT INTO pt_lt_tab SELECT i, i,'c',True FROM generate_series(7,10)i;
INSERT INTO pt_lt_tab SELECT i, i,'e',True FROM generate_series(11,13)i;
INSERT INTO pt_lt_tab SELECT i, i,'f',True FROM generate_series(14,16)i;
INSERT INTO pt_lt_tab SELECT i, i,'g',True FROM generate_series(17,20)i;
INSERT INTO pt_lt_tab SELECT i, i,'i',False FROM generate_series(21,23)i;
INSERT INTO pt_lt_tab SELECT i, i,'k',False FROM generate_series(24,26)i;
INSERT INTO pt_lt_tab SELECT i, i,'h',False FROM generate_series(27,30)i;
INSERT INTO pt_lt_tab SELECT i, i,'m',False FROM generate_series(31,33)i;
INSERT INTO pt_lt_tab SELECT i, i,'o',False FROM generate_series(34,36)i;
INSERT INTO pt_lt_tab SELECT i, i,'n',False FROM generate_series(37,40)i;
INSERT INTO pt_lt_tab SELECT i, i,'p',False FROM generate_series(41,43)i;
INSERT INTO pt_lt_tab SELECT i, i,'s',False FROM generate_series(44,46)i;
INSERT INTO pt_lt_tab SELECT i, i,'q',False FROM generate_series(47,50)i;
ANALYZE pt_lt_tab;
-- pt_lt_tab_df is the same as pt_lt_tab, but with a default partition (and some
-- values in the default partition, including NULLs).
CREATE TABLE pt_lt_tab_df
(
  col1 int,
  col2 decimal,
  col3 text,
  col4 bool
)
distributed by (col1)
partition by list(col2)
(
  partition part1 VALUES(1,2,3,4,5,6,7,8,9,10),
  partition part2 VALUES(11,12,13,14,15,16,17,18,19,20),
  partition part3 VALUES(21,22,23,24,25,26,27,28,29,30),
  partition part4 VALUES(31,32,33,34,35,36,37,38,39,40),
  partition part5 VALUES(41,42,43,44,45,46,47,48,49,50),
  default partition def
);
NOTICE:  CREATE TABLE will create partition "pt_lt_tab_df_1_prt_part1" for table "pt_lt_tab_df"
NOTICE:  CREATE TABLE will create partition "pt_lt_tab_df_1_prt_part2" for table "pt_lt_tab_df"
NOTICE:  CREATE TABLE will create partition "pt_lt_tab_df_1_prt_part3" for table "pt_lt_tab_df"
NOTICE:  CREATE TABLE will create partition "pt_lt_tab_df_1_prt_part4" for table "pt_lt_tab_df"
NOTICE:  CREATE TABLE will create partition "pt_lt_tab_df_1_prt_part5" for table "pt_lt_tab_df"
NOTICE:  CREATE TABLE will create partition "pt_lt_tab_df_1_prt_def" for table "pt_lt_tab_df"
INSERT INTO pt_lt_tab_df SELECT i, i,'a',True FROM generate_series(1,3)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'b',True FROM generate_series(4,6)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'c',True FROM generate_series(7,10)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'e',True FROM generate_series(11,13)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'f',True FROM generate_series(14,16)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'g',True FROM generate_series(17,20)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'i',False FROM generate_series(21,23)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'k',False FROM generate_series(24,26)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'h',False FROM generate_series(27,30)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'m',False FROM generate_series(31,33)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'o',False FROM generate_series(34,36)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'n',False FROM generate_series(37,40)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'p',False FROM generate_series(41,43)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'s',False FROM generate_series(44,46)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'q',False FROM generate_series(47,50)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'u',True FROM generate_series(51,53)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'x',True FROM generate_series(54,56)i;
INSERT INTO pt_lt_tab_df SELECT i, i,'w',True FROM generate_series(57,60)i;
INSERT INTO pt_lt_tab_df VALUES(NULL,NULL,NULL,NULL);
INSERT INTO pt_lt_tab_df VALUES(NULL,NULL,NULL,NULL);
INSERT INTO pt_lt_tab_df VALUES(NULL,NULL,NULL,NULL);
ANALYZE pt_lt_tab_df;
-- @description B-tree single index key = non-partitioning key
CREATE INDEX idx1 on pt_lt_tab(col1);
NOTICE:  building index for child partition "pt_lt_tab_1_prt_part1"
NOTICE:  building index for child partition "pt_lt_tab_1_prt_part2"
NOTICE:  building index for child partition "pt_lt_tab_1_prt_part3"
NOTICE:  building index for child partition "pt_lt_tab_1_prt_part4"
NOTICE:  building index for child partition "pt_lt_tab_1_prt_part5"
SELECT * FROM pt_lt_tab WHERE col1 < 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col1 < 10 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=15.86..15.97 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=15.86..15.97 rows=5 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=15.86..15.87 rows=2 width=14)
               ->  Sort  (cost=15.86..15.89 rows=5 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..15.62 rows=5 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1 pt_lt_tab  (cost=0.00..3.12 rows=4 width=14)
                                 Filter: col1 < 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 < 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 < 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 < 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 < 10
 Optimizer status: legacy query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col1 > 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
(0 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col1 > 50 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=15.68..15.80 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=15.68..15.80 rows=5 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=15.68..15.70 rows=2 width=14)
               ->  Sort  (cost=15.68..15.70 rows=2 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..15.62 rows=2 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 > 50
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 > 50
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 > 50
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 > 50
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 > 50
 Optimizer status: legacy query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col1 = 25 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   25 |   25 | k    | f
(1 row)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col1 = 25 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=15.68..15.80 rows=5 width=14)
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=15.68..15.80 rows=5 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=15.68..15.70 rows=2 width=14)
               ->  Sort  (cost=15.68..15.70 rows=2 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..15.62 rows=2 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 = 25
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 = 25
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 = 25
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 = 25
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 = 25
 Optimizer status: legacy query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col1 <> 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col1 <> 10 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=16.37..16.48 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=16.37..16.48 rows=5 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=16.37..16.38 rows=2 width=14)
               ->  Sort  (cost=16.37..16.48 rows=15 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..15.62 rows=15 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1 pt_lt_tab  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col1 <> 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col1 <> 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col1 <> 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col1 <> 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col1 <> 10
 Optimizer status: legacy query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col1 > 10 AND col1 < 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
   15 |   15 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col1 > 10 AND col1 < 50 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=16.43..16.54 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=16.43..16.54 rows=5 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=16.43..16.44 rows=2 width=14)
               ->  Sort  (cost=16.43..16.53 rows=14 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..15.75 rows=14 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1 pt_lt_tab  (cost=0.00..3.15 rows=1 width=14)
                                 Filter: col1 > 10 AND col1 < 50
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col1 > 10 AND col1 < 50
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col1 > 10 AND col1 < 50
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col1 > 10 AND col1 < 50
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col1 > 10 AND col1 < 50
 Optimizer status: legacy query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col1 > 10 OR col1 = 25 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
   15 |   15 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col1 > 10 OR col1 = 25 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=16.43..16.54 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=16.43..16.54 rows=5 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=16.43..16.44 rows=2 width=14)
               ->  Sort  (cost=16.43..16.53 rows=14 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..15.75 rows=14 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1 pt_lt_tab  (cost=0.00..3.15 rows=1 width=14)
                                 Filter: col1 > 10 OR col1 = 25
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col1 > 10 OR col1 = 25
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col1 > 10 OR col1 = 25
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col1 > 10 OR col1 = 25
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col1 > 10 OR col1 = 25
 Optimizer status: legacy query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col1 between 10 AND 25 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   10 |   10 | c    | t
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col1 between 10 AND 25 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=16.04..16.15 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=16.04..16.15 rows=5 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=16.04..16.05 rows=2 width=14)
               ->  Sort  (cost=16.04..16.08 rows=6 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..15.75 rows=6 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1 pt_lt_tab  (cost=0.00..3.15 rows=1 width=14)
                                 Filter: col1 >= 10 AND col1 <= 25
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col1 >= 10 AND col1 <= 25
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.15 rows=2 width=14)
                                 Filter: col1 >= 10 AND col1 <= 25
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.15 rows=1 width=14)
                                 Filter: col1 >= 10 AND col1 <= 25
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.15 rows=1 width=14)
                                 Filter: col1 >= 10 AND col1 <= 25
 Optimizer status: legacy query optimizer
(18 rows)

DROP INDEX idx1;
WARNING:  Only dropped the index "idx1"
-- have to drop the indexes on the partitions explicitly.
DROP INDEX idx1_1_prt_part1;
DROP INDEX idx1_1_prt_part2;
DROP INDEX idx1_1_prt_part3;
DROP INDEX idx1_1_prt_part4;
DROP INDEX idx1_1_prt_part5;
HINT:  To drop other indexes on child partitions, drop each one explicitly.
-- @description B-tree single index key = partitioning key
CREATE INDEX idx1 on pt_lt_tab(col2);
NOTICE:  building index for child partition "pt_lt_tab_1_prt_part1"
NOTICE:  building index for child partition "pt_lt_tab_1_prt_part2"
NOTICE:  building index for child partition "pt_lt_tab_1_prt_part3"
NOTICE:  building index for child partition "pt_lt_tab_1_prt_part4"
NOTICE:  building index for child partition "pt_lt_tab_1_prt_part5"
SELECT * FROM pt_lt_tab WHERE col2 < 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 < 10 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=3.29..3.40 rows=5 width=15)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=3.29..3.40 rows=5 width=15)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=3.29..3.30 rows=2 width=15)
               ->  Sort  (cost=3.29..3.32 rows=4 width=15)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..3.12 rows=4 width=15)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1 pt_lt_tab  (cost=0.00..3.12 rows=4 width=14)
                                 Filter: col2 < 10::numeric
 Optimizer status: legacy query optimizer
(10 rows)

SELECT * FROM pt_lt_tab WHERE col2 > 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
(0 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 > 50 ORDER BY col2,col3 LIMIT 5;
                           QUERY PLAN                           
----------------------------------------------------------------
 Limit  (cost=0.02..0.03 rows=1 width=0)
   ->  Sort  (cost=0.02..0.03 rows=1 width=0)
         Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Result  (cost=0.00..0.01 rows=1 width=0)
               One-Time Filter: false
 Optimizer status: legacy query optimizer
(6 rows)

SELECT * FROM pt_lt_tab WHERE col2 = 25 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   25 |   25 | k    | f
(1 row)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 = 25 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=3.13..3.16 rows=1 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=3.13..3.16 rows=1 width=14)
         Merge Key: public.pt_lt_tab.col3
         ->  Limit  (cost=3.13..3.14 rows=1 width=14)
               ->  Sort  (cost=3.13..3.14 rows=1 width=14)
                     Sort Key: public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..3.12 rows=1 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col2 = 25::numeric
 Optimizer status: legacy query optimizer
(10 rows)

SELECT * FROM pt_lt_tab WHERE col2 <> 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 <> 10 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=16.37..16.48 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=16.37..16.48 rows=5 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=16.37..16.38 rows=2 width=14)
               ->  Sort  (cost=16.37..16.48 rows=15 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..15.62 rows=15 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1 pt_lt_tab  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col2 <> 10::numeric
 Optimizer status: legacy query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col2 > 10 AND col2 < 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
   15 |   15 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 > 10 AND col2 < 50 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=13.26..13.38 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=13.26..13.38 rows=5 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=13.26..13.28 rows=2 width=14)
               ->  Sort  (cost=13.26..13.36 rows=14 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..12.60 rows=14 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 > 10::numeric AND col2 < 50::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 > 10::numeric AND col2 < 50::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 > 10::numeric AND col2 < 50::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 > 10::numeric AND col2 < 50::numeric
 Optimizer status: legacy query optimizer
(16 rows)

SELECT * FROM pt_lt_tab WHERE col2 > 10 OR col2 = 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
   15 |   15 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 > 10 OR col2 = 50 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=13.26..13.38 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=13.26..13.38 rows=5 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=13.26..13.28 rows=2 width=14)
               ->  Sort  (cost=13.26..13.36 rows=14 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..12.60 rows=14 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 > 10::numeric OR col2 = 50::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 > 10::numeric OR col2 = 50::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 > 10::numeric OR col2 = 50::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 > 10::numeric OR col2 = 50::numeric
 Optimizer status: legacy query optimizer
(16 rows)

SELECT * FROM pt_lt_tab WHERE col2 between 10 AND 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   10 |   10 | c    | t
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 between 10 AND 50 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=16.43..16.54 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=16.43..16.54 rows=5 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=16.43..16.44 rows=2 width=14)
               ->  Sort  (cost=16.43..16.53 rows=14 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..15.75 rows=14 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1 pt_lt_tab  (cost=0.00..3.15 rows=1 width=14)
                                 Filter: col2 >= 10::numeric AND col2 <= 50::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 10::numeric AND col2 <= 50::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 10::numeric AND col2 <= 50::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 10::numeric AND col2 <= 50::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 10::numeric AND col2 <= 50::numeric
 Optimizer status: legacy query optimizer
(18 rows)

DROP INDEX idx1;
WARNING:  Only dropped the index "idx1"
HINT:  To drop other indexes on child partitions, drop each one explicitly.
-- @description multiple column b-tree index
CREATE INDEX idx1 on pt_lt_tab(col1,col2);
NOTICE:  building index for child partition "pt_lt_tab_1_prt_part1"
NOTICE:  building index for child partition "pt_lt_tab_1_prt_part2"
NOTICE:  building index for child partition "pt_lt_tab_1_prt_part3"
NOTICE:  building index for child partition "pt_lt_tab_1_prt_part4"
NOTICE:  building index for child partition "pt_lt_tab_1_prt_part5"
SELECT * FROM pt_lt_tab WHERE col1 < 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col1 < 10 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=15.86..15.97 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=15.86..15.97 rows=5 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=15.86..15.87 rows=2 width=14)
               ->  Sort  (cost=15.86..15.89 rows=5 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..15.62 rows=5 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1 pt_lt_tab  (cost=0.00..3.12 rows=4 width=14)
                                 Filter: col1 < 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 < 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 < 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 < 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 < 10
 Optimizer status: legacy query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col1 > 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
(0 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col1 > 50 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=15.68..15.80 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=15.68..15.80 rows=5 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=15.68..15.70 rows=2 width=14)
               ->  Sort  (cost=15.68..15.70 rows=2 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..15.62 rows=2 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 > 50
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 > 50
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 > 50
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 > 50
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 > 50
 Optimizer status: legacy query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col2 = 25 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   25 |   25 | k    | f
(1 row)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 = 25 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=3.13..3.16 rows=1 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=3.13..3.16 rows=1 width=14)
         Merge Key: public.pt_lt_tab.col3
         ->  Limit  (cost=3.13..3.14 rows=1 width=14)
               ->  Sort  (cost=3.13..3.14 rows=1 width=14)
                     Sort Key: public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..3.12 rows=1 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col2 = 25::numeric
 Optimizer status: legacy query optimizer
(10 rows)

SELECT * FROM pt_lt_tab WHERE col2 <> 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 <> 10 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=16.37..16.48 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=16.37..16.48 rows=5 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=16.37..16.38 rows=2 width=14)
               ->  Sort  (cost=16.37..16.48 rows=15 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..15.62 rows=15 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1 pt_lt_tab  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col2 <> 10::numeric
 Optimizer status: legacy query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col2 > 10 AND col1 = 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
(0 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 > 10 AND col1 = 10 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=12.64..12.73 rows=4 width=14)
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=12.64..12.73 rows=4 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=12.64..12.65 rows=2 width=14)
               ->  Sort  (cost=12.64..12.65 rows=2 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..12.60 rows=2 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.15 rows=1 width=14)
                                 Filter: col2 > 10::numeric AND col1 = 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.15 rows=1 width=14)
                                 Filter: col2 > 10::numeric AND col1 = 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.15 rows=1 width=14)
                                 Filter: col2 > 10::numeric AND col1 = 10
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.15 rows=1 width=14)
                                 Filter: col2 > 10::numeric AND col1 = 10
 Optimizer status: legacy query optimizer
(16 rows)

SELECT * FROM pt_lt_tab WHERE col2 > 10.00 OR col1 = 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
   15 |   15 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 > 10.00 OR col1 = 50 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=16.43..16.54 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=16.43..16.54 rows=5 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=16.43..16.44 rows=2 width=14)
               ->  Sort  (cost=16.43..16.53 rows=14 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..15.75 rows=14 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1 pt_lt_tab  (cost=0.00..3.15 rows=1 width=14)
                                 Filter: col2 > 10.00 OR col1 = 50
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 > 10.00 OR col1 = 50
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 > 10.00 OR col1 = 50
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 > 10.00 OR col1 = 50
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 > 10.00 OR col1 = 50
 Optimizer status: legacy query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col2 between 10 AND 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   10 |   10 | c    | t
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 between 10 AND 50 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=16.43..16.54 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=16.43..16.54 rows=5 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=16.43..16.44 rows=2 width=14)
               ->  Sort  (cost=16.43..16.53 rows=14 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..15.75 rows=14 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1 pt_lt_tab  (cost=0.00..3.15 rows=1 width=14)
                                 Filter: col2 >= 10::numeric AND col2 <= 50::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 10::numeric AND col2 <= 50::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 10::numeric AND col2 <= 50::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 10::numeric AND col2 <= 50::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 10::numeric AND col2 <= 50::numeric
 Optimizer status: legacy query optimizer
(18 rows)

DROP INDEX idx1;
WARNING:  Only dropped the index "idx1"
HINT:  To drop other indexes on child partitions, drop each one explicitly.
-- have to drop the indexes on the partitions explicitly.
DROP INDEX idx1_1_prt_part1;
DROP INDEX idx1_1_prt_part2;
DROP INDEX idx1_1_prt_part3;
DROP INDEX idx1_1_prt_part4;
DROP INDEX idx1_1_prt_part5;
-- @description Heterogeneous index, index on partition key, b-tree index on all partitions
CREATE INDEX idx1 on pt_lt_tab_1_prt_part1(col2);
CREATE INDEX idx2 on pt_lt_tab_1_prt_part2(col2);
CREATE INDEX idx3 on pt_lt_tab_1_prt_part3(col2);
CREATE INDEX idx4 on pt_lt_tab_1_prt_part4(col2);
CREATE INDEX idx5 on pt_lt_tab_1_prt_part5(col2);
SELECT * FROM pt_lt_tab WHERE col2 between 1 AND 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 between 1 AND 50 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=16.58..16.69 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=16.58..16.69 rows=5 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=16.58..16.59 rows=2 width=14)
               ->  Sort  (cost=16.58..16.71 rows=17 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..15.75 rows=17 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 1::numeric AND col2 <= 50::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 1::numeric AND col2 <= 50::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 1::numeric AND col2 <= 50::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 1::numeric AND col2 <= 50::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 1::numeric AND col2 <= 50::numeric
 Optimizer status: legacy query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col2 > 5 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    6 |    6 | b    | t
    7 |    7 | c    | t
    8 |    8 | c    | t
    9 |    9 | c    | t
   10 |   10 | c    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 > 5 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=16.38..16.49 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=16.38..16.49 rows=5 width=14)
         Merge Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
         ->  Limit  (cost=16.38..16.39 rows=2 width=14)
               ->  Sort  (cost=16.38..16.50 rows=16 width=14)
                     Sort Key: public.pt_lt_tab.col2, public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..15.62 rows=16 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1 pt_lt_tab  (cost=0.00..3.12 rows=2 width=14)
                                 Filter: col2 > 5::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part2 pt_lt_tab  (cost=0.00..3.12 rows=4 width=14)
                                 Filter: col2 > 5::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part3 pt_lt_tab  (cost=0.00..3.12 rows=4 width=14)
                                 Filter: col2 > 5::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part4 pt_lt_tab  (cost=0.00..3.12 rows=4 width=14)
                                 Filter: col2 > 5::numeric
                           ->  Seq Scan on pt_lt_tab_1_prt_part5 pt_lt_tab  (cost=0.00..3.12 rows=4 width=14)
                                 Filter: col2 > 5::numeric
 Optimizer status: legacy query optimizer
(18 rows)

SELECT * FROM pt_lt_tab WHERE col2 = 5 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    5 |    5 | b    | t
(1 row)

EXPLAIN SELECT * FROM pt_lt_tab WHERE col2 = 5 ORDER BY col2,col3 LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=3.13..3.16 rows=1 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=3.13..3.16 rows=1 width=14)
         Merge Key: public.pt_lt_tab.col3
         ->  Limit  (cost=3.13..3.14 rows=1 width=14)
               ->  Sort  (cost=3.13..3.14 rows=1 width=14)
                     Sort Key: public.pt_lt_tab.col3
                     ->  Append  (cost=0.00..3.12 rows=1 width=14)
                           ->  Seq Scan on pt_lt_tab_1_prt_part1 pt_lt_tab  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col2 = 5::numeric
 Optimizer status: legacy query optimizer
(10 rows)

DROP INDEX idx1;
DROP INDEX idx2;
DROP INDEX idx3;
DROP INDEX idx4;
DROP INDEX idx5;
-- @description Heterogeneous index,b-tree index on all parts,index, index on non-partition col
CREATE INDEX idx1 on pt_lt_tab_df_1_prt_part1(col1);
CREATE INDEX idx2 on pt_lt_tab_df_1_prt_part2(col1);
CREATE INDEX idx3 on pt_lt_tab_df_1_prt_part3(col1);
CREATE INDEX idx4 on pt_lt_tab_df_1_prt_part4(col1);
CREATE INDEX idx5 on pt_lt_tab_df_1_prt_part5(col1);
CREATE INDEX idx6 on pt_lt_tab_df_1_prt_def(col1);
SELECT * FROM pt_lt_tab_df WHERE col1 between 1 AND 100 ORDER BY col1 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col1 between 1 AND 100 ORDER BY col1 LIMIT 5;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=19.94..20.05 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=19.94..20.05 rows=5 width=14)
         Merge Key: public.pt_lt_tab_df.col1
         ->  Limit  (cost=19.94..19.95 rows=2 width=14)
               ->  Sort  (cost=19.94..20.09 rows=20 width=14)
                     Sort Key: public.pt_lt_tab_df.col1
                     ->  Append  (cost=0.00..18.95 rows=20 width=14)
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part1 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col1 >= 1 AND col1 <= 100
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part2 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col1 >= 1 AND col1 <= 100
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part3 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col1 >= 1 AND col1 <= 100
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part4 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col1 >= 1 AND col1 <= 100
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part5 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col1 >= 1 AND col1 <= 100
                           ->  Seq Scan on pt_lt_tab_df_1_prt_def pt_lt_tab_df  (cost=0.00..3.19 rows=4 width=14)
                                 Filter: col1 >= 1 AND col1 <= 100
 Optimizer status: legacy query optimizer
(20 rows)

SELECT * FROM pt_lt_tab_df WHERE col1 > 50 ORDER BY col1 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   51 |   51 | u    | t
   52 |   52 | u    | t
   53 |   53 | u    | t
   54 |   54 | x    | t
   55 |   55 | x    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col1 > 50 ORDER BY col1 LIMIT 5;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=19.04..19.15 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=19.04..19.15 rows=5 width=14)
         Merge Key: public.pt_lt_tab_df.col1
         ->  Limit  (cost=19.04..19.05 rows=2 width=14)
               ->  Sort  (cost=19.04..19.07 rows=5 width=14)
                     Sort Key: public.pt_lt_tab_df.col1
                     ->  Append  (cost=0.00..18.79 rows=5 width=14)
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part1 pt_lt_tab_df  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 > 50
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part2 pt_lt_tab_df  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 > 50
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part3 pt_lt_tab_df  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 > 50
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part4 pt_lt_tab_df  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 > 50
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part5 pt_lt_tab_df  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 > 50
                           ->  Seq Scan on pt_lt_tab_df_1_prt_def pt_lt_tab_df  (cost=0.00..3.16 rows=4 width=14)
                                 Filter: col1 > 50
 Optimizer status: legacy query optimizer
(20 rows)

SELECT * FROM pt_lt_tab_df WHERE col1 < 50 ORDER BY col1 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col1 < 50 ORDER BY col1 LIMIT 5;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=19.63..19.75 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=19.63..19.75 rows=5 width=14)
         Merge Key: public.pt_lt_tab_df.col1
         ->  Limit  (cost=19.63..19.65 rows=2 width=14)
               ->  Sort  (cost=19.63..19.76 rows=17 width=14)
                     Sort Key: public.pt_lt_tab_df.col1
                     ->  Append  (cost=0.00..18.79 rows=17 width=14)
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part1 pt_lt_tab_df  (cost=0.00..3.12 rows=4 width=14)
                                 Filter: col1 < 50
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part2 pt_lt_tab_df  (cost=0.00..3.12 rows=4 width=14)
                                 Filter: col1 < 50
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part3 pt_lt_tab_df  (cost=0.00..3.12 rows=4 width=14)
                                 Filter: col1 < 50
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part4 pt_lt_tab_df  (cost=0.00..3.12 rows=4 width=14)
                                 Filter: col1 < 50
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part5 pt_lt_tab_df  (cost=0.00..3.12 rows=4 width=14)
                                 Filter: col1 < 50
                           ->  Seq Scan on pt_lt_tab_df_1_prt_def pt_lt_tab_df  (cost=0.00..3.16 rows=1 width=14)
                                 Filter: col1 < 50
 Optimizer status: legacy query optimizer
(20 rows)

DROP INDEX idx1;
DROP INDEX idx2;
DROP INDEX idx3;
DROP INDEX idx4;
DROP INDEX idx5;
DROP INDEX idx6;
-- @description Heterogeneous index,b-tree index on all parts including default, index on partition col
CREATE INDEX idx1 on pt_lt_tab_df_1_prt_part1(col2);
CREATE INDEX idx2 on pt_lt_tab_df_1_prt_part2(col2);
CREATE INDEX idx3 on pt_lt_tab_df_1_prt_part3(col2);
CREATE INDEX idx4 on pt_lt_tab_df_1_prt_part4(col2);
CREATE INDEX idx5 on pt_lt_tab_df_1_prt_part5(col2);
CREATE INDEX idx6 on pt_lt_tab_df_1_prt_def(col2);
SELECT * FROM pt_lt_tab_df WHERE col2 between 1 AND 100 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 between 1 AND 100 ORDER BY col2,col3 LIMIT 5;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=19.94..20.05 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=19.94..20.05 rows=5 width=14)
         Merge Key: public.pt_lt_tab_df.col2, public.pt_lt_tab_df.col3
         ->  Limit  (cost=19.94..19.95 rows=2 width=14)
               ->  Sort  (cost=19.94..20.09 rows=20 width=14)
                     Sort Key: public.pt_lt_tab_df.col2, public.pt_lt_tab_df.col3
                     ->  Append  (cost=0.00..18.95 rows=20 width=14)
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part1 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 1::numeric AND col2 <= 100::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part2 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 1::numeric AND col2 <= 100::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part3 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 1::numeric AND col2 <= 100::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part4 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 1::numeric AND col2 <= 100::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part5 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 1::numeric AND col2 <= 100::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_def pt_lt_tab_df  (cost=0.00..3.19 rows=4 width=14)
                                 Filter: col2 >= 1::numeric AND col2 <= 100::numeric
 Optimizer status: legacy query optimizer
(20 rows)

SELECT * FROM pt_lt_tab_df WHERE col2 > 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   51 |   51 | u    | t
   52 |   52 | u    | t
   53 |   53 | u    | t
   54 |   54 | x    | t
   55 |   55 | x    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 > 50 ORDER BY col2,col3 LIMIT 5;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Limit  (cost=3.33..3.44 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=3.33..3.44 rows=5 width=14)
         Merge Key: public.pt_lt_tab_df.col2, public.pt_lt_tab_df.col3
         ->  Limit  (cost=3.33..3.34 rows=2 width=14)
               ->  Sort  (cost=3.33..3.35 rows=4 width=14)
                     Sort Key: public.pt_lt_tab_df.col2, public.pt_lt_tab_df.col3
                     ->  Append  (cost=0.00..3.16 rows=4 width=14)
                           ->  Seq Scan on pt_lt_tab_df_1_prt_def pt_lt_tab_df  (cost=0.00..3.16 rows=4 width=14)
                                 Filter: col2 > 50::numeric
 Optimizer status: legacy query optimizer
(10 rows)

SELECT * FROM pt_lt_tab_df WHERE col2 = 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   50 |   50 | q    | f
(1 row)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 = 50 ORDER BY col2,col3 LIMIT 5;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=6.30..6.34 rows=2 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=6.30..6.34 rows=2 width=14)
         Merge Key: public.pt_lt_tab_df.col3
         ->  Limit  (cost=6.30..6.30 rows=1 width=14)
               ->  Sort  (cost=6.30..6.30 rows=1 width=14)
                     Sort Key: public.pt_lt_tab_df.col3
                     ->  Append  (cost=0.00..6.29 rows=1 width=14)
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part5 pt_lt_tab_df  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col2 = 50::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_def pt_lt_tab_df  (cost=0.00..3.16 rows=1 width=14)
                                 Filter: col2 = 50::numeric
 Optimizer status: legacy query optimizer
(12 rows)

SELECT * FROM pt_lt_tab_df WHERE col2 <> 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 <> 10 ORDER BY col2,col3 LIMIT 5;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=19.74..19.85 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=19.74..19.85 rows=5 width=14)
         Merge Key: public.pt_lt_tab_df.col2, public.pt_lt_tab_df.col3
         ->  Limit  (cost=19.74..19.75 rows=2 width=14)
               ->  Sort  (cost=19.74..19.88 rows=20 width=14)
                     Sort Key: public.pt_lt_tab_df.col2, public.pt_lt_tab_df.col3
                     ->  Append  (cost=0.00..18.79 rows=20 width=14)
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part1 pt_lt_tab_df  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part2 pt_lt_tab_df  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part3 pt_lt_tab_df  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part4 pt_lt_tab_df  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part5 pt_lt_tab_df  (cost=0.00..3.12 rows=3 width=14)
                                 Filter: col2 <> 10::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_def pt_lt_tab_df  (cost=0.00..3.16 rows=5 width=14)
                                 Filter: col2 <> 10::numeric
 Optimizer status: legacy query optimizer
(20 rows)

SELECT * FROM pt_lt_tab_df WHERE col2 between 1 AND 100 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
    1 |    1 | a    | t
    2 |    2 | a    | t
    3 |    3 | a    | t
    4 |    4 | b    | t
    5 |    5 | b    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 between 1 AND 100 ORDER BY col2,col3 LIMIT 5;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=19.94..20.05 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=19.94..20.05 rows=5 width=14)
         Merge Key: public.pt_lt_tab_df.col2, public.pt_lt_tab_df.col3
         ->  Limit  (cost=19.94..19.95 rows=2 width=14)
               ->  Sort  (cost=19.94..20.09 rows=20 width=14)
                     Sort Key: public.pt_lt_tab_df.col2, public.pt_lt_tab_df.col3
                     ->  Append  (cost=0.00..18.95 rows=20 width=14)
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part1 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 1::numeric AND col2 <= 100::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part2 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 1::numeric AND col2 <= 100::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part3 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 1::numeric AND col2 <= 100::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part4 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 1::numeric AND col2 <= 100::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part5 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 >= 1::numeric AND col2 <= 100::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_def pt_lt_tab_df  (cost=0.00..3.19 rows=4 width=14)
                                 Filter: col2 >= 1::numeric AND col2 <= 100::numeric
 Optimizer status: legacy query optimizer
(20 rows)

SELECT * FROM pt_lt_tab_df WHERE col2 < 50 AND col1 > 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
   15 |   15 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 < 50 AND col1 > 10 ORDER BY col2,col3 LIMIT 5;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=19.64..19.76 rows=5 width=15)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=19.64..19.76 rows=5 width=15)
         Merge Key: public.pt_lt_tab_df.col2, public.pt_lt_tab_df.col3
         ->  Limit  (cost=19.64..19.66 rows=2 width=15)
               ->  Sort  (cost=19.64..19.75 rows=14 width=15)
                     Sort Key: public.pt_lt_tab_df.col2, public.pt_lt_tab_df.col3
                     ->  Append  (cost=0.00..18.95 rows=14 width=15)
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part1 pt_lt_tab_df  (cost=0.00..3.15 rows=1 width=14)
                                 Filter: col2 < 50::numeric AND col1 > 10
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part2 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 < 50::numeric AND col1 > 10
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part3 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 < 50::numeric AND col1 > 10
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part4 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 < 50::numeric AND col1 > 10
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part5 pt_lt_tab_df  (cost=0.00..3.15 rows=4 width=14)
                                 Filter: col2 < 50::numeric AND col1 > 10
                           ->  Seq Scan on pt_lt_tab_df_1_prt_def pt_lt_tab_df  (cost=0.00..3.19 rows=1 width=14)
                                 Filter: col2 < 50::numeric AND col1 > 10
 Optimizer status: legacy query optimizer
(20 rows)

DROP INDEX idx1;
DROP INDEX idx2;
DROP INDEX idx3;
DROP INDEX idx4;
DROP INDEX idx5;
DROP INDEX idx6;
-- @description Heterogeneous index,b-tree index on all parts,index , multiple index 
CREATE INDEX idx1 on pt_lt_tab_df_1_prt_part1(col2,col1);
CREATE INDEX idx2 on pt_lt_tab_df_1_prt_part2(col2,col1);
CREATE INDEX idx3 on pt_lt_tab_df_1_prt_part3(col2,col1);
CREATE INDEX idx4 on pt_lt_tab_df_1_prt_part4(col2,col1);
CREATE INDEX idx5 on pt_lt_tab_df_1_prt_part5(col2,col1);
CREATE INDEX idx6 on pt_lt_tab_df_1_prt_def(col2,col1);
SELECT * FROM pt_lt_tab_df WHERE col2 = 50 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   50 |   50 | q    | f
(1 row)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 = 50 ORDER BY col2,col3 LIMIT 5;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=6.30..6.34 rows=2 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=6.30..6.34 rows=2 width=14)
         Merge Key: public.pt_lt_tab_df.col3
         ->  Limit  (cost=6.30..6.30 rows=1 width=14)
               ->  Sort  (cost=6.30..6.30 rows=1 width=14)
                     Sort Key: public.pt_lt_tab_df.col3
                     ->  Append  (cost=0.00..6.29 rows=1 width=14)
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part5 pt_lt_tab_df  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col2 = 50::numeric
                           ->  Seq Scan on pt_lt_tab_df_1_prt_def pt_lt_tab_df  (cost=0.00..3.16 rows=1 width=14)
                                 Filter: col2 = 50::numeric
 Optimizer status: legacy query optimizer
(12 rows)

SELECT * FROM pt_lt_tab_df WHERE col2 > 10 AND col1 between 1 AND 100 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   11 |   11 | e    | t
   12 |   12 | e    | t
   13 |   13 | e    | t
   14 |   14 | f    | t
   15 |   15 | f    | t
(5 rows)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col2 > 10 AND col1 between 1 AND 100 ORDER BY col2,col3 LIMIT 5;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=16.74..16.85 rows=5 width=14)
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=16.74..16.85 rows=5 width=14)
         Merge Key: public.pt_lt_tab_df.col2, public.pt_lt_tab_df.col3
         ->  Limit  (cost=16.74..16.75 rows=2 width=14)
               ->  Sort  (cost=16.74..16.86 rows=17 width=14)
                     Sort Key: public.pt_lt_tab_df.col2, public.pt_lt_tab_df.col3
                     ->  Append  (cost=0.00..15.93 rows=17 width=14)
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part2 pt_lt_tab_df  (cost=0.00..3.17 rows=4 width=14)
                                 Filter: col2 > 10::numeric AND col1 >= 1 AND col1 <= 100
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part3 pt_lt_tab_df  (cost=0.00..3.17 rows=4 width=14)
                                 Filter: col2 > 10::numeric AND col1 >= 1 AND col1 <= 100
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part4 pt_lt_tab_df  (cost=0.00..3.17 rows=4 width=14)
                                 Filter: col2 > 10::numeric AND col1 >= 1 AND col1 <= 100
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part5 pt_lt_tab_df  (cost=0.00..3.17 rows=4 width=14)
                                 Filter: col2 > 10::numeric AND col1 >= 1 AND col1 <= 100
                           ->  Seq Scan on pt_lt_tab_df_1_prt_def pt_lt_tab_df  (cost=0.00..3.23 rows=3 width=14)
                                 Filter: col2 > 10::numeric AND col1 >= 1 AND col1 <= 100
 Optimizer status: legacy query optimizer
(18 rows)

SELECT * FROM pt_lt_tab_df WHERE col1 = 10 ORDER BY col2,col3 LIMIT 5;
 col1 | col2 | col3 | col4 
------+------+------+------
   10 |   10 | c    | t
(1 row)

EXPLAIN SELECT * FROM pt_lt_tab_df WHERE col1 = 10 ORDER BY col2,col3 LIMIT 5;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=18.87..18.98 rows=5 width=14)
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=18.87..18.98 rows=5 width=14)
         Merge Key: public.pt_lt_tab_df.col2, public.pt_lt_tab_df.col3
         ->  Limit  (cost=18.87..18.88 rows=2 width=14)
               ->  Sort  (cost=18.87..18.88 rows=2 width=14)
                     Sort Key: public.pt_lt_tab_df.col2, public.pt_lt_tab_df.col3
                     ->  Append  (cost=0.00..18.79 rows=2 width=14)
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part1 pt_lt_tab_df  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 = 10
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part2 pt_lt_tab_df  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 = 10
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part3 pt_lt_tab_df  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 = 10
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part4 pt_lt_tab_df  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 = 10
                           ->  Seq Scan on pt_lt_tab_df_1_prt_part5 pt_lt_tab_df  (cost=0.00..3.12 rows=1 width=14)
                                 Filter: col1 = 10
                           ->  Seq Scan on pt_lt_tab_df_1_prt_def pt_lt_tab_df  (cost=0.00..3.16 rows=1 width=14)
                                 Filter: col1 = 10
 Optimizer status: legacy query optimizer
(20 rows)

DROP INDEX idx1;
DROP INDEX idx2;
DROP INDEX idx3;
DROP INDEX idx4;
DROP INDEX idx5;
DROP INDEX idx6;
--
-- See MPP-6861
--
CREATE TABLE ds_4
(
  month_id character varying(6),
  cust_group_acc numeric(10),
  mobile_no character varying(10),
  source character varying(12),
  vas_group numeric(10),
  vas_type numeric(10),
  count_vas integer,
  amt_vas numeric(10,2),
  network_type character varying(3),
  execution_id integer
)
WITH (
  OIDS=FALSE
)
DISTRIBUTED BY (cust_group_acc, mobile_no)
PARTITION BY LIST(month_id)
          (
          PARTITION p200800 VALUES('200800'),
          PARTITION p200801 VALUES('200801'),
          PARTITION p200802 VALUES('200802'),
          PARTITION p200803 VALUES('200803')
);
NOTICE:  CREATE TABLE will create partition "ds_4_1_prt_p200800" for table "ds_4"
NOTICE:  CREATE TABLE will create partition "ds_4_1_prt_p200801" for table "ds_4"
NOTICE:  CREATE TABLE will create partition "ds_4_1_prt_p200802" for table "ds_4"
NOTICE:  CREATE TABLE will create partition "ds_4_1_prt_p200803" for table "ds_4"
-- this is the case that worked before MPP-6861
explain select * from ds_4 where month_id = '200800';
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..0.00 rows=1 width=184)
   ->  Append  (cost=0.00..0.00 rows=1 width=184)
         ->  Seq Scan on ds_4_1_prt_p200800 ds_4  (cost=0.00..0.00 rows=1 width=184)
               Filter: month_id::text = '200800'::text
(4 rows)

-- now we can evaluate this function at planning/prune time
explain select * from ds_4 where month_id::int = 200800;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..0.00 rows=1 width=184)
   ->  Append  (cost=0.00..0.00 rows=1 width=184)
         ->  Seq Scan on ds_4_1_prt_p200800 ds_4  (cost=0.00..0.00 rows=1 width=184)
               Filter: month_id::integer = 200800
(4 rows)

-- this will be satisfied by 200800
explain select * from ds_4 where month_id::int - 801 < 200000;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..0.00 rows=1 width=184)
   ->  Append  (cost=0.00..0.00 rows=1 width=184)
         ->  Seq Scan on ds_4_1_prt_p200800 ds_4  (cost=0.00..0.00 rows=1 width=184)
               Filter: (month_id::integer - 801) < 200000
(4 rows)

-- test OR case -- should NOT get pruning
explain select * from ds_4 where month_id::int - 801 < 200000 OR count_vas > 10;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..0.00 rows=1 width=184)
   ->  Append  (cost=0.00..0.00 rows=1 width=184)
         ->  Seq Scan on ds_4_1_prt_p200800 ds_4  (cost=0.00..0.00 rows=1 width=184)
               Filter: (month_id::integer - 801) < 200000 OR count_vas > 10
         ->  Seq Scan on ds_4_1_prt_p200801 ds_4  (cost=0.00..0.00 rows=1 width=184)
               Filter: (month_id::integer - 801) < 200000 OR count_vas > 10
         ->  Seq Scan on ds_4_1_prt_p200802 ds_4  (cost=0.00..0.00 rows=1 width=184)
               Filter: (month_id::integer - 801) < 200000 OR count_vas > 10
         ->  Seq Scan on ds_4_1_prt_p200803 ds_4  (cost=0.00..0.00 rows=1 width=184)
               Filter: (month_id::integer - 801) < 200000 OR count_vas > 10
(10 rows)

-- test AND case -- should still get pruning
explain select * from ds_4 where month_id::int - 801 < 200000 AND count_vas > 10;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..0.00 rows=1 width=184)
   ->  Append  (cost=0.00..0.00 rows=1 width=184)
         ->  Seq Scan on ds_4_1_prt_p200800 ds_4  (cost=0.00..0.00 rows=1 width=184)
               Filter: (month_id::integer - 801) < 200000 AND count_vas > 10
(4 rows)

-- test expression case : should get pruning
explain select * from ds_4 where case when month_id = '200800' then 100 else 2 end = 100;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..0.00 rows=1 width=184)
   ->  Append  (cost=0.00..0.00 rows=1 width=184)
         ->  Seq Scan on ds_4_1_prt_p200800 ds_4  (cost=0.00..0.00 rows=1 width=184)
               Filter: CASE WHEN month_id::text = '200800'::text THEN 100 ELSE 2 END = 100
(4 rows)

-- test expression case : should get pruning
explain select * from ds_4 where case when month_id = '200800' then NULL else 2 end IS NULL;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..0.00 rows=1 width=184)
   ->  Append  (cost=0.00..0.00 rows=1 width=184)
         ->  Seq Scan on ds_4_1_prt_p200800 ds_4  (cost=0.00..0.00 rows=1 width=184)
               Filter: CASE WHEN month_id::text = '200800'::text THEN NULL::integer ELSE 2 END IS NULL
(4 rows)

-- should still get pruning here -- count_vas is only used in the path for month id = 200800
explain select * from ds_4 where case when month_id::int = 200800 then count_vas else 2 end IS NULL;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..0.00 rows=1 width=184)
   ->  Append  (cost=0.00..0.00 rows=1 width=184)
         ->  Seq Scan on ds_4_1_prt_p200800 ds_4  (cost=0.00..0.00 rows=1 width=184)
               Filter: CASE WHEN month_id::integer = 200800 THEN count_vas ELSE 2 END IS NULL
(4 rows)

-- do one that matches a couple partitions
explain select * from ds_4 where month_id::int in (200801, 1,55,6,6,6,6,66,565,65,65,200803);
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..0.00 rows=1 width=184)
   ->  Append  (cost=0.00..0.00 rows=1 width=184)
         ->  Seq Scan on ds_4_1_prt_p200801 ds_4  (cost=0.00..0.00 rows=1 width=184)
               Filter: month_id::integer = ANY ('{200801,1,55,6,6,6,6,66,565,65,65,200803}'::integer[])
         ->  Seq Scan on ds_4_1_prt_p200803 ds_4  (cost=0.00..0.00 rows=1 width=184)
               Filter: month_id::integer = ANY ('{200801,1,55,6,6,6,6,66,565,65,65,200803}'::integer[])
(6 rows)

-- cleanup
drop table ds_4;
--
-- See MPP-18979
--
CREATE TABLE ds_2
(
  month_id character varying(6),
  cust_group_acc numeric(10),
  mobile_no character varying(10),
  source character varying(12),
  vas_group numeric(10),
  vas_type numeric(10),
  count_vas integer,
  amt_vas numeric(10,2),
  network_type character varying(3),
  execution_id integer
)
WITH (
  OIDS=FALSE
)
DISTRIBUTED BY (cust_group_acc, mobile_no)
PARTITION BY LIST(month_id)
          (
          PARTITION p200800 VALUES('200800'),
          PARTITION p200801 VALUES('200801'),
          PARTITION p200802 VALUES('200802'),
          PARTITION p200803 VALUES('200803'),
          PARTITION p200804 VALUES('200804'),
          PARTITION p200805 VALUES('200805'),
          PARTITION p200806 VALUES('200806'),
          PARTITION p200807 VALUES('200807'),
          PARTITION p200808 VALUES('200808'),
          PARTITION p200809 VALUES('200809')
);
NOTICE:  CREATE TABLE will create partition "ds_2_1_prt_p200800" for table "ds_2"
NOTICE:  CREATE TABLE will create partition "ds_2_1_prt_p200801" for table "ds_2"
NOTICE:  CREATE TABLE will create partition "ds_2_1_prt_p200802" for table "ds_2"
NOTICE:  CREATE TABLE will create partition "ds_2_1_prt_p200803" for table "ds_2"
NOTICE:  CREATE TABLE will create partition "ds_2_1_prt_p200804" for table "ds_2"
NOTICE:  CREATE TABLE will create partition "ds_2_1_prt_p200805" for table "ds_2"
NOTICE:  CREATE TABLE will create partition "ds_2_1_prt_p200806" for table "ds_2"
NOTICE:  CREATE TABLE will create partition "ds_2_1_prt_p200807" for table "ds_2"
NOTICE:  CREATE TABLE will create partition "ds_2_1_prt_p200808" for table "ds_2"
NOTICE:  CREATE TABLE will create partition "ds_2_1_prt_p200809" for table "ds_2"
insert into ds_2(month_id) values('200800');
insert into ds_2(month_id) values('200801');
insert into ds_2(month_id) values('200802');
insert into ds_2(month_id) values('200803');
insert into ds_2(month_id) values('200804');
insert into ds_2(month_id) values('200805');
insert into ds_2(month_id) values('200806');
insert into ds_2(month_id) values('200807');
insert into ds_2(month_id) values('200808');
insert into ds_2(month_id) values('200809');
-- queries without bitmap scan
set optimizer_segments=2;
explain select * from ds_2 where month_id::int in (200808, 1315) order by month_id;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=3.30..3.31 rows=1 width=184)
   Merge Key: month_id
   ->  Sort  (cost=3.30..3.31 rows=1 width=184)
         Sort Key: public.ds_2.month_id
         ->  Append  (cost=0.00..3.29 rows=1 width=184)
               ->  Seq Scan on ds_2_1_prt_p200808 ds_2  (cost=0.00..3.29 rows=1 width=184)
                     Filter: month_id::integer = ANY ('{200808,1315}'::integer[])
(7 rows)

explain  select * from ds_2 where month_id::int in (200808, 200801, 2008010) order by month_id;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=3.50..3.50 rows=1 width=184)
   Merge Key: month_id
   ->  Sort  (cost=3.50..3.50 rows=1 width=184)
         Sort Key: public.ds_2.month_id
         ->  Append  (cost=0.00..3.49 rows=1 width=184)
               ->  Seq Scan on ds_2_1_prt_p200801 ds_2  (cost=0.00..3.49 rows=1 width=184)
                     Filter: month_id::integer = ANY ('{200808,200801,2008010}'::integer[])
               ->  Seq Scan on ds_2_1_prt_p200808 ds_2  (cost=0.00..3.49 rows=1 width=184)
                     Filter: month_id::integer = ANY ('{200808,200801,2008010}'::integer[])
(9 rows)

reset optimizer_segments;
select * from ds_2 where month_id::int in (200907, 1315) order by month_id;
 month_id | cust_group_acc | mobile_no | source | vas_group | vas_type | count_vas | amt_vas | network_type | execution_id 
----------+----------------+-----------+--------+-----------+----------+-----------+---------+--------------+--------------
(0 rows)

select * from ds_2 where month_id::int in (200808, 1315) order by month_id;
 month_id | cust_group_acc | mobile_no | source | vas_group | vas_type | count_vas | amt_vas | network_type | execution_id 
----------+----------------+-----------+--------+-----------+----------+-----------+---------+--------------+--------------
 200808   |                |           |        |           |          |           |         |              |             
(1 row)

select * from ds_2 where month_id::int in (200808, 200801) order by month_id;
 month_id | cust_group_acc | mobile_no | source | vas_group | vas_type | count_vas | amt_vas | network_type | execution_id 
----------+----------------+-----------+--------+-----------+----------+-----------+---------+--------------+--------------
 200801   |                |           |        |           |          |           |         |              |             
 200808   |                |           |        |           |          |           |         |              |             
(2 rows)

select * from ds_2 where month_id::int in (200808, 200801, 2008010) order by month_id;
 month_id | cust_group_acc | mobile_no | source | vas_group | vas_type | count_vas | amt_vas | network_type | execution_id 
----------+----------------+-----------+--------+-----------+----------+-----------+---------+--------------+--------------
 200801   |                |           |        |           |          |           |         |              |             
 200808   |                |           |        |           |          |           |         |              |             
(2 rows)

-- cleanup
drop table ds_2;
Create or replace function public.reverse(text) Returns text as $BODY$
DECLARE
   Original alias for $1;
   Reverse_str text;
   I int4;
BEGIN
   Reverse_str :='';
   For I in reverse length(original)..1 LOOP
   Reverse_str := reverse_str || substr(original,I,1);
END LOOP;
RETURN reverse_str;
END;
$BODY$ LANGUAGE plpgsql IMMUTABLE;
drop table if exists dnsdata cascade;
NOTICE:  table "dnsdata" does not exist, skipping
CREATE TABLE dnsdata(dnsname text) DISTRIBUTED RANDOMLY;
CREATE INDEX dnsdata_d1_idx ON dnsdata USING bitmap (split_part(reverse(dnsname),'.'::text,1));
CREATE INDEX dnsdata_d2_idx ON dnsdata USING bitmap (split_part(reverse(dnsname),'.'::text,2));
insert into dnsdata values('www.google.com');
insert into dnsdata values('www.google1.com');
insert into dnsdata values('1.google.com');
insert into dnsdata values('2.google.com');
insert into dnsdata select 'www.b.com' from generate_series(1, 100000) as x(a);
analyze dnsdata;
-- queries with bitmap scan enabled
set enable_bitmapscan=on;
set enable_indexscan=on;
set enable_seqscan=off;
Select dnsname from dnsdata
where (split_part(reverse('cache.google.com'),'.',1))=(split_part(reverse(dnsname),'.',1))
and (split_part(reverse('cache.google.com'),'.',2))=(split_part(reverse(dnsname),'.',2)) 
order by dnsname;
    dnsname     
----------------
 1.google.com
 2.google.com
 www.google.com
(3 rows)

Select dnsname from dnsdata
where (split_part(reverse('cache.google.com'),'.',1))=(split_part(reverse(dnsname),'.',1))
and (split_part(reverse('cache.google.com'),'.',2))=(split_part(reverse(dnsname),'.',2))
and dnsname = 'cache.google.com'
order by dnsname;
 dnsname 
---------
(0 rows)

-- cleanup
drop table dnsdata cascade;
drop function public.reverse(text) cascade;
Create or replace function public.ZeroFunc(int) Returns int as $BODY$
BEGIN
  RETURN 0;
END;
$BODY$ LANGUAGE plpgsql IMMUTABLE;
drop table if exists mytable cascade;
NOTICE:  table "mytable" does not exist, skipping
create table mytable(i int, j int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into mytable select x, x+1 from generate_series(1, 100000) as x;
analyze mytable;
CREATE INDEX mytable_idx1 ON mytable USING bitmap(zerofunc(i));
select * from mytable where ZeroFunc(i)=0 and i=100 order by i;
  i  |  j  
-----+-----
 100 | 101
(1 row)

select * from mytable where ZeroFunc(i)=0 and i=-1 order by i;
 i | j 
---+---
(0 rows)

-- cleanup
drop function ZeroFunc(int) cascade;
NOTICE:  drop cascades to index mytable_idx1
drop table mytable cascade;
-- start_ignore
create language plpythonu;
-- end_ignore
-- @description Tests for static partition selection (MPP-24709, GPSQL-2879)
create or replace function get_selected_parts(explain_query text) returns text as
$$
rv = plpy.execute('explain ' + explain_query)
search_text = 'Partition Selector'
result = []
result.append(0)
result.append(0)
for i in range(len(rv)):
    cur_line = rv[i]['QUERY PLAN']
    if search_text.lower() in cur_line.lower():
        j = i+1
        temp_line = rv[j]['QUERY PLAN']
        while temp_line.find('Partitions selected:') == -1:
            j += 1
            if j == len(rv) - 1:
                break
            temp_line = rv[j]['QUERY PLAN']

        if temp_line.find('Partitions selected:') != -1:
            result[0] = int(temp_line[temp_line.index('selected: ')+10:temp_line.index(' (out')])
            result[1] = int(temp_line[temp_line.index('out of')+6:temp_line.index(')')])
return result
$$
language plpythonu;
drop table if exists partprune_foo;
create table partprune_foo(a int, b int, c int) partition by range (b) (start (1) end (101) every (10));
insert into partprune_foo select generate_series(1,5), generate_series(1,100), generate_series(1,10);
analyze partprune_foo;
select get_selected_parts(' select * from partprune_foo;');
 get_selected_parts 
--------------------
 [0, 0]
(1 row)

select * from partprune_foo;
 a |  b  | c  
---+-----+----
 1 |   1 |  1
 3 |   3 |  3
 5 |   5 |  5
 1 |   6 |  6
 3 |   8 |  8
 5 |  10 | 10
 1 |  11 |  1
 3 |  13 |  3
 5 |  15 |  5
 1 |  16 |  6
 3 |  18 |  8
 5 |  20 | 10
 1 |  21 |  1
 3 |  23 |  3
 5 |  25 |  5
 1 |  26 |  6
 3 |  28 |  8
 5 |  30 | 10
 1 |  31 |  1
 3 |  33 |  3
 5 |  35 |  5
 1 |  36 |  6
 3 |  38 |  8
 5 |  40 | 10
 1 |  41 |  1
 3 |  43 |  3
 5 |  45 |  5
 1 |  46 |  6
 3 |  48 |  8
 5 |  50 | 10
 1 |  51 |  1
 3 |  53 |  3
 5 |  55 |  5
 1 |  56 |  6
 3 |  58 |  8
 5 |  60 | 10
 1 |  61 |  1
 3 |  63 |  3
 5 |  65 |  5
 1 |  66 |  6
 3 |  68 |  8
 5 |  70 | 10
 1 |  71 |  1
 3 |  73 |  3
 5 |  75 |  5
 1 |  76 |  6
 3 |  78 |  8
 5 |  80 | 10
 1 |  81 |  1
 3 |  83 |  3
 5 |  85 |  5
 1 |  86 |  6
 3 |  88 |  8
 5 |  90 | 10
 1 |  91 |  1
 3 |  93 |  3
 5 |  95 |  5
 1 |  96 |  6
 3 |  98 |  8
 5 | 100 | 10
 2 |   2 |  2
 4 |   4 |  4
 2 |   7 |  7
 4 |   9 |  9
 2 |  12 |  2
 4 |  14 |  4
 2 |  17 |  7
 4 |  19 |  9
 2 |  22 |  2
 4 |  24 |  4
 2 |  27 |  7
 4 |  29 |  9
 2 |  32 |  2
 4 |  34 |  4
 2 |  37 |  7
 4 |  39 |  9
 2 |  42 |  2
 4 |  44 |  4
 2 |  47 |  7
 4 |  49 |  9
 2 |  52 |  2
 4 |  54 |  4
 2 |  57 |  7
 4 |  59 |  9
 2 |  62 |  2
 4 |  64 |  4
 2 |  67 |  7
 4 |  69 |  9
 2 |  72 |  2
 4 |  74 |  4
 2 |  77 |  7
 4 |  79 |  9
 2 |  82 |  2
 4 |  84 |  4
 2 |  87 |  7
 4 |  89 |  9
 2 |  92 |  2
 4 |  94 |  4
 2 |  97 |  7
 4 |  99 |  9
(100 rows)

select get_selected_parts(' select * from partprune_foo where b = 35;');
 get_selected_parts 
--------------------
 [0, 0]
(1 row)

select * from partprune_foo where b = 35;
 a | b  | c 
---+----+---
 5 | 35 | 5
(1 row)

select get_selected_parts(' select * from partprune_foo where b < 35;');
 get_selected_parts 
--------------------
 [0, 0]
(1 row)

select * from partprune_foo where b < 35;
 a | b  | c  
---+----+----
 2 |  2 |  2
 4 |  4 |  4
 2 |  7 |  7
 4 |  9 |  9
 2 | 12 |  2
 4 | 14 |  4
 2 | 17 |  7
 4 | 19 |  9
 2 | 22 |  2
 4 | 24 |  4
 2 | 27 |  7
 4 | 29 |  9
 2 | 32 |  2
 4 | 34 |  4
 1 |  1 |  1
 3 |  3 |  3
 5 |  5 |  5
 1 |  6 |  6
 3 |  8 |  8
 5 | 10 | 10
 1 | 11 |  1
 3 | 13 |  3
 5 | 15 |  5
 1 | 16 |  6
 3 | 18 |  8
 5 | 20 | 10
 1 | 21 |  1
 3 | 23 |  3
 5 | 25 |  5
 1 | 26 |  6
 3 | 28 |  8
 5 | 30 | 10
 1 | 31 |  1
 3 | 33 |  3
(34 rows)

select get_selected_parts(' select * from partprune_foo where b in (5, 6, 14, 23);');
 get_selected_parts 
--------------------
 [0, 0]
(1 row)

select * from partprune_foo where b in (5, 6, 14, 23);
 a | b  | c 
---+----+---
 5 |  5 | 5
 1 |  6 | 6
 3 | 23 | 3
 4 | 14 | 4
(4 rows)

select get_selected_parts(' select * from partprune_foo where b < 15 or b > 60;');
 get_selected_parts 
--------------------
 [0, 0]
(1 row)

select * from partprune_foo where b < 15 or b > 60;
 a |  b  | c  
---+-----+----
 2 |   2 |  2
 4 |   4 |  4
 2 |   7 |  7
 4 |   9 |  9
 2 |  12 |  2
 4 |  14 |  4
 2 |  62 |  2
 4 |  64 |  4
 2 |  67 |  7
 4 |  69 |  9
 2 |  72 |  2
 4 |  74 |  4
 2 |  77 |  7
 4 |  79 |  9
 2 |  82 |  2
 4 |  84 |  4
 2 |  87 |  7
 4 |  89 |  9
 2 |  92 |  2
 4 |  94 |  4
 2 |  97 |  7
 4 |  99 |  9
 1 |   1 |  1
 3 |   3 |  3
 5 |   5 |  5
 1 |   6 |  6
 3 |   8 |  8
 5 |  10 | 10
 1 |  11 |  1
 3 |  13 |  3
 1 |  61 |  1
 3 |  63 |  3
 5 |  65 |  5
 1 |  66 |  6
 3 |  68 |  8
 5 |  70 | 10
 1 |  71 |  1
 3 |  73 |  3
 5 |  75 |  5
 1 |  76 |  6
 3 |  78 |  8
 5 |  80 | 10
 1 |  81 |  1
 3 |  83 |  3
 5 |  85 |  5
 1 |  86 |  6
 3 |  88 |  8
 5 |  90 | 10
 1 |  91 |  1
 3 |  93 |  3
 5 |  95 |  5
 1 |  96 |  6
 3 |  98 |  8
 5 | 100 | 10
(54 rows)

select get_selected_parts(' select * from partprune_foo where b = 150;');
 get_selected_parts 
--------------------
 [0, 0]
(1 row)

select * from partprune_foo where b = 150;
 a | b | c 
---+---+---
(0 rows)

select get_selected_parts(' select * from partprune_foo where b = a*5;');
 get_selected_parts 
--------------------
 [0, 0]
(1 row)

select * from partprune_foo where b = a*5;
 a | b  | c 
---+----+---
 5 | 25 | 5
(1 row)

