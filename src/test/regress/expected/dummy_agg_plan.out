create table t_dummy_agg_plan1(c1 int, c2 int) distributed by (c1);
create table t_dummy_agg_plan2(c1 int, c2 int) distributed by (c1);
analyze t_dummy_agg_plan1;
analyze t_dummy_agg_plan2;
explain
  select c1, sum(c2) from t_dummy_agg_plan1 where 1 < 0 group by c1
  union all
  select c1, sum(c2) from t_dummy_agg_plan2 group by c1;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=1.00..1.06 rows=3 width=12)
   ->  Append  (cost=1.00..1.06 rows=1 width=12)
         ->  HashAggregate  (cost=1.00..1.03 rows=1 width=12)
               Group Key: t_dummy_agg_plan2.c1
               ->  Seq Scan on t_dummy_agg_plan2  (cost=0.00..1.00 rows=1 width=8)
 Optimizer: Postgres query optimizer
(6 rows)

explain
  select count(*), 1 from t_dummy_agg_plan1 where 1 < 0
  union all
  select c1, sum(c2) from t_dummy_agg_plan2 group by c1;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice3; segments: 3)  (cost=0.07..1.16 rows=4 width=12)
   ->  Append  (cost=0.07..1.16 rows=2 width=12)
         ->  Redistribute Motion 1:3  (slice2; segments: 1)  (cost=0.07..0.09 rows=1 width=12)
               Hash Key: "*SELECT* 1".count, ((1)::bigint)
               ->  Subquery Scan on "*SELECT* 1"  (cost=0.07..0.09 rows=1 width=12)
                     ->  Aggregate  (cost=0.07..0.08 rows=1 width=12)
                           ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.01..0.06 rows=1 width=8)
                                 ->  Aggregate  (cost=0.01..0.02 rows=1 width=8)
                                       ->  Result  (cost=0.00..0.01 rows=1 width=0)
                                             One-Time Filter: false
         ->  Subquery Scan on "*SELECT* 2"  (cost=1.00..1.06 rows=1 width=12)
               ->  HashAggregate  (cost=1.00..1.03 rows=1 width=12)
                     Group Key: t_dummy_agg_plan2.c1
                     ->  Seq Scan on t_dummy_agg_plan2  (cost=0.00..1.00 rows=1 width=8)
 Optimizer: Postgres query optimizer
(15 rows)

explain
  with t(c1, c2, c3) as (
    select c1, sum(c2), 1 from t_dummy_agg_plan1 group by c1
    union all
    select c1, sum(c2), 2 from t_dummy_agg_plan2 group by c1
  )
  select * from t where c3 > 1;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..0.06 rows=3 width=16)
   ->  Append  (cost=1.00..1.06 rows=1 width=16)
         ->  HashAggregate  (cost=1.00..1.03 rows=1 width=16)
               Group Key: t_dummy_agg_plan2.c1
               ->  Seq Scan on t_dummy_agg_plan2  (cost=0.00..1.00 rows=1 width=8)
 Optimizer: Postgres query optimizer
(6 rows)

