--
-- CASE
-- Test the case statement
--
CREATE TABLE CASE_TBL (
  i integer,
  f double precision
) distributed by (f);
CREATE TABLE CASE2_TBL (
  i integer,
  j integer
);
INSERT INTO CASE_TBL VALUES (1, 10.1);
INSERT INTO CASE_TBL VALUES (2, 20.2);
INSERT INTO CASE_TBL VALUES (3, -30.3);
INSERT INTO CASE_TBL VALUES (4, NULL);
INSERT INTO CASE2_TBL VALUES (1, -1);
INSERT INTO CASE2_TBL VALUES (2, -2);
INSERT INTO CASE2_TBL VALUES (3, -3);
INSERT INTO CASE2_TBL VALUES (2, -4);
INSERT INTO CASE2_TBL VALUES (1, NULL);
INSERT INTO CASE2_TBL VALUES (NULL, -6);
--
-- Simplest examples without tables
--
SELECT '3' AS "One",
  CASE
    WHEN 1 < 2 THEN 3
  END AS "Simple WHEN";
 One | Simple WHEN 
-----+-------------
 3   |           3
(1 row)

SELECT '<NULL>' AS "One",
  CASE
    WHEN 1 > 2 THEN 3
  END AS "Simple default";
  One   | Simple default 
--------+----------------
 <NULL> |               
(1 row)

SELECT '3' AS "One",
  CASE
    WHEN 1 < 2 THEN 3
    ELSE 4
  END AS "Simple ELSE";
 One | Simple ELSE 
-----+-------------
 3   |           3
(1 row)

SELECT '4' AS "One",
  CASE
    WHEN 1 > 2 THEN 3
    ELSE 4
  END AS "ELSE default";
 One | ELSE default 
-----+--------------
 4   |            4
(1 row)

SELECT '6' AS "One",
  CASE
    WHEN 1 > 2 THEN 3
    WHEN 4 < 5 THEN 6
    ELSE 7
  END AS "Two WHEN with default";
 One | Two WHEN with default 
-----+-----------------------
 6   |                     6
(1 row)

-- Constant-expression folding shouldn't evaluate unreachable subexpressions
SELECT CASE WHEN 1=0 THEN 1/0 WHEN 1=1 THEN 1 ELSE 2/0 END;
 case 
------
    1
(1 row)

SELECT CASE 1 WHEN 0 THEN 1/0 WHEN 1 THEN 1 ELSE 2/0 END;
 case 
------
    1
(1 row)

-- However we do not currently suppress folding of potentially
-- reachable subexpressions  (but MPP does... So we get different answer from postgres).
--SELECT CASE WHEN i > 100 THEN 1/0 ELSE 0 END FROM case_tbl;
-- Test for cases involving untyped literals in test expression
SELECT CASE 'a' WHEN 'a' THEN 1 ELSE 2 END;
 case 
------
    1
(1 row)

--
-- Examples of targets involving tables
--
SELECT '' AS "Five",
  CASE
    WHEN i >= 3 THEN i
  END AS ">= 3 or Null"
  FROM CASE_TBL;
 Five | >= 3 or Null 
------+--------------
      |             
      |             
      |            3
      |            4
(4 rows)

SELECT '' AS "Five",
  CASE WHEN i >= 3 THEN (i + i)
       ELSE i
  END AS "Simplest Math"
  FROM CASE_TBL;
 Five | Simplest Math 
------+---------------
      |             1
      |             2
      |             6
      |             8
(4 rows)

SELECT '' AS "Five", i AS "Value",
  CASE WHEN (i < 0) THEN 'small'
       WHEN (i = 0) THEN 'zero'
       WHEN (i = 1) THEN 'one'
       WHEN (i = 2) THEN 'two'
       ELSE 'big'
  END AS "Category"
  FROM CASE_TBL;
 Five | Value | Category 
------+-------+----------
      |     1 | one
      |     2 | two
      |     3 | big
      |     4 | big
(4 rows)

SELECT '' AS "Five",
  CASE WHEN ((i < 0) or (i < 0)) THEN 'small'
       WHEN ((i = 0) or (i = 0)) THEN 'zero'
       WHEN ((i = 1) or (i = 1)) THEN 'one'
       WHEN ((i = 2) or (i = 2)) THEN 'two'
       ELSE 'big'
  END AS "Category"
  FROM CASE_TBL;
 Five | Category 
------+----------
      | one
      | two
      | big
      | big
(4 rows)

--
-- Examples of qualifications involving tables
--
--
-- NULLIF() and COALESCE()
-- Shorthand forms for typical CASE constructs
--  defined in the SQL92 standard.
--
SELECT * FROM CASE_TBL WHERE COALESCE(f,i) = 4;
 i | f 
---+---
 4 |  
(1 row)

SELECT * FROM CASE_TBL WHERE NULLIF(f,i) = 2;
 i | f 
---+---
(0 rows)

SELECT COALESCE(a.f, b.i, b.j)
  FROM CASE_TBL a, CASE2_TBL b;
 coalesce 
----------
     10.1
     20.2
    -30.3
        1
     10.1
     20.2
    -30.3
        2
     10.1
     20.2
    -30.3
        3
     10.1
     20.2
    -30.3
        2
     10.1
     20.2
    -30.3
        1
     10.1
     20.2
    -30.3
       -6
(24 rows)

SELECT *
  FROM CASE_TBL a, CASE2_TBL b
  WHERE COALESCE(a.f, b.i, b.j) = 2;
 i | f | i | j  
---+---+---+----
 4 |   | 2 | -2
 4 |   | 2 | -4
(2 rows)

SELECT '' AS Five, NULLIF(a.i,b.i) AS "NULLIF(a.i,b.i)",
  NULLIF(b.i, 4) AS "NULLIF(b.i,4)"
  FROM CASE_TBL a, CASE2_TBL b;
 five | NULLIF(a.i,b.i) | NULLIF(b.i,4) 
------+-----------------+---------------
      |                 |             1
      |               2 |             1
      |               3 |             1
      |               4 |             1
      |               1 |             2
      |                 |             2
      |               3 |             2
      |               4 |             2
      |               1 |             3
      |               2 |             3
      |                 |             3
      |               4 |             3
      |               1 |             2
      |                 |             2
      |               3 |             2
      |               4 |             2
      |                 |             1
      |               2 |             1
      |               3 |             1
      |               4 |             1
      |               1 |              
      |               2 |              
      |               3 |              
      |               4 |              
(24 rows)

SELECT '' AS "Two", *
  FROM CASE_TBL a, CASE2_TBL b
  WHERE COALESCE(f,b.i) = 2;
 Two | i | f | i | j  
-----+---+---+---+----
     | 4 |   | 2 | -2
     | 4 |   | 2 | -4
(2 rows)

--
-- Examples of updates involving tables
--
UPDATE CASE_TBL
  SET i = CASE WHEN i >= 3 THEN (- i)
                ELSE (2 * i) END;
SELECT * FROM CASE_TBL;
 i  |   f   
----+-------
  2 |  10.1
  4 |  20.2
 -3 | -30.3
 -4 |      
(4 rows)

UPDATE CASE_TBL
  SET i = CASE WHEN i >= 2 THEN (2 * i)
                ELSE (3 * i) END;
SELECT * FROM CASE_TBL;
  i  |   f   
-----+-------
   4 |  10.1
   8 |  20.2
  -9 | -30.3
 -12 |      
(4 rows)

UPDATE CASE_TBL
  SET i = CASE WHEN b.i >= 2 THEN (2 * j)
                ELSE (3 * j) END
  FROM CASE2_TBL b
  WHERE j = -CASE_TBL.i;
SELECT * FROM CASE_TBL;
  i  |   f   
-----+-------
   8 |  20.2
  -9 | -30.3
 -12 |      
  -8 |  10.1
(4 rows)

--
-- CASE ... WHEN IS NOT DISTINCT FROM ...
--
DROP TABLE IF EXISTS mytable CASCADE;
NOTICE:  table "mytable" does not exist, skipping
CREATE TABLE mytable (a int, b int, c varchar(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO mytable values 	(1,2,'t'),
							(2,3,'e'),
							(3,4,'o'),
							(4,5,'o'),
							(4,4,'o'),
							(5,5,'t'),
							(6,6,'t'),
							(7,6,'a'),
							(8,7,'t'),
							(9,8,'a');
CREATE OR REPLACE FUNCTION negate(int) RETURNS int 
AS 'SELECT $1 * (-1)'
LANGUAGE sql CONTAINS SQL
IMMUTABLE
RETURNS null ON null input;
DROP VIEW IF EXISTS myview;
NOTICE:  view "myview" does not exist, skipping
CREATE VIEW myview AS 
   SELECT a,b, CASE a WHEN IS NOT DISTINCT FROM b THEN b*10
                      WHEN IS NOT DISTINCT FROM b+1 THEN b*100 
                      WHEN b-1 THEN b*1000
                      WHEN b*10 THEN b*10000
                      WHEN negate(b) THEN b*(-1.0)
                      ELSE b END AS newb
     FROM mytable;
SELECT * FROM myview ORDER BY a,b;
 a | b | newb 
---+---+------
 1 | 2 | 2000
 2 | 3 | 3000
 3 | 4 | 4000
 4 | 4 |   40
 4 | 5 | 5000
 5 | 5 |   50
 6 | 6 |   60
 7 | 6 |  600
 8 | 7 |  700
 9 | 8 |  800
(10 rows)

-- Test deparse
select pg_get_viewdef('myview',true); 
                                   pg_get_viewdef                                    
-------------------------------------------------------------------------------------
  SELECT mytable.a, mytable.b,                                                       
         CASE mytable.a                                                              
             WHEN IS NOT DISTINCT FROM mytable.b THEN (mytable.b * 10)::numeric      
             WHEN IS NOT DISTINCT FROM mytable.b + 1 THEN (mytable.b * 100)::numeric 
             WHEN mytable.b - 1 THEN (mytable.b * 1000)::numeric                     
             WHEN mytable.b * 10 THEN (mytable.b * 10000)::numeric                   
             WHEN negate(mytable.b) THEN mytable.b::numeric * (-1.0)                 
             ELSE mytable.b::numeric                                                 
         END AS newb                                                                 
    FROM mytable;
(1 row)

DROP TABLE IF EXISTS products CASCADE;
NOTICE:  table "products" does not exist, skipping
CREATE TABLE products (id serial, name text, price numeric);
NOTICE:  CREATE TABLE will create implicit sequence "products_id_seq" for serial column "products.id"
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO products (name, price) values ('keyboard', 124.99);
INSERT INTO products (name, price) values ('monitor', 299.99);
INSERT INTO products (name, price) values ('mouse', 45.59);
SELECT id,name,price as old_price,
       CASE name WHEN IS NOT DISTINCT FROM 'keyboard' THEN products.price*1.5 
                 WHEN IS NOT DISTINCT FROM 'monitor' THEN price*1.2
                 WHEN 'keyboard tray' THEN price*.9 
                 END AS new_price
  FROM products;
 id |   name   | old_price | new_price 
----+----------+-----------+-----------
  1 | keyboard |    124.99 |   187.485
  2 | monitor  |    299.99 |   359.988
  3 | mouse    |     45.59 |          
(3 rows)

                            
-- testexpr should be evaluated only once
DROP FUNCTION IF EXISTS blip(int);
NOTICE:  function blip(pg_catalog.int4) does not exist, skipping
DROP TABLE IF EXISTS calls_to_blip;
NOTICE:  table "calls_to_blip" does not exist, skipping
CREATE TABLE calls_to_blip (n serial, v int) DISTRIBUTED RANDOMLY;
NOTICE:  CREATE TABLE will create implicit sequence "calls_to_blip_n_seq" for serial column "calls_to_blip.n"
CREATE OR REPLACE FUNCTION blip(int) RETURNS int
LANGUAGE plpgsql MODIFIES SQL DATA
VOLATILE
AS $$
DECLARE
	x alias for $1;
BEGIN
	INSERT INTO calls_to_blip(v) VALUES (x);
	RETURN x;
END;
$$;
SELECT CASE blip(1) 
			WHEN IS NOT DISTINCT FROM blip(2) THEN blip(20)
			WHEN IS NOT DISTINCT FROM blip(3) THEN blip(30)
			WHEN IS NOT DISTINCT FROM blip(4) THEN blip(40)
			ELSE blip(666)
			END AS answer;
 answer 
--------
    666
(1 row)

SELECT * FROM calls_to_blip ORDER BY 1;
 n |  v  
---+-----
 1 |   1
 2 |   2
 3 |   3
 4 |   4
 5 | 666
(5 rows)

-- Negative test
--   1. wrong syntax
--   2. type mismatches
SELECT a,b,CASE WHEN IS NOT DISTINCT FROM b THEN b*100 ELSE b*1000 END FROM mytable;
ERROR:  syntax error at or near "NOT"
LINE 1: SELECT a,b,CASE WHEN IS NOT DISTINCT FROM b THEN b*100 ELSE ...
                                ^
HINT:  Missing <operand> for "CASE <operand> WHEN IS NOT DISTINCT FROM ..."
SELECT a,b,c,CASE c WHEN IS NOT DISTINCT FROM b THEN a
                    WHEN IS NOT DISTINCT FROM b+1 THEN a*100
                    ELSE c END 
  FROM mytable; 
ERROR:  CASE types character varying and integer cannot be matched
LINE 1: SELECT a,b,c,CASE c WHEN IS NOT DISTINCT FROM b THEN a
                          ^
--
-- DECODE(): Oracle compatibility
--
SELECT decode(null,null,true,false);
 case 
------
 t
(1 row)

SELECT decode(NULL, 1, 100, NULL, 200, 300);
 case 
------
  200
(1 row)

SELECT decode('1'::text, '1', 100, '2', 200);
 case 
------
  100
(1 row)

SELECT decode(2, 1, 'ABC', 2, 'DEF');
 case 
------
 DEF
(1 row)

SELECT decode('2009-02-05'::date, '2009-02-05', 'ok');
 case 
------
 ok
(1 row)

SELECT decode('2009-02-05 01:02:03'::timestamp, '2009-02-05 01:02:03', 'ok');
 case 
------
 ok
(1 row)

SELECT b,c,decode(c,'a',b*10,'e',b*100,'o',b*1000,'u',b*10000,'i',b*100000) as newb from mytable;
 b | c | newb 
---+---+------
 2 | t |     
 3 | e |  300
 4 | o | 4000
 5 | o | 5000
 4 | o | 4000
 5 | t |     
 6 | t |     
 6 | a |   60
 7 | t |     
 8 | a |   80
(10 rows)

SELECT b,c,decode(c,'a',ARRAY[1,2],'e',ARRAY[3,4],'o',ARRAY[5,6],'u',ARRAY[7,8],'i',ARRAY[9,10],ARRAY[0]) as newb from mytable;
 b | c | newb  
---+---+-------
 2 | t | {0}
 3 | e | {3,4}
 4 | o | {5,6}
 5 | o | {5,6}
 4 | o | {5,6}
 5 | t | {0}
 6 | t | {0}
 6 | a | {1,2}
 7 | t | {0}
 8 | a | {1,2}
(10 rows)

DROP VIEW IF EXISTS myview;
CREATE VIEW myview as
 SELECT id, name, price, DECODE(id, 1, 'Southlake',
                                    2, 'San Francisco',
                                    3, 'New Jersey',
                                    4, 'Seattle',
                                    5, 'Portland',
                                    6, 'San Francisco',
                                    7, 'Portland',
                                       'Non domestic') Location
  FROM products
 WHERE id < 100;
SELECT * FROM myview ORDER BY id, location;
 id |   name   | price  |   location    
----+----------+--------+---------------
  1 | keyboard | 124.99 | Southlake
  2 | monitor  | 299.99 | San Francisco
  3 | mouse    |  45.59 | New Jersey
(3 rows)

-- Test deparse
select pg_get_viewdef('myview',true); 
                           pg_get_viewdef                           
--------------------------------------------------------------------
  SELECT products.id, products.name, products.price,                
         CASE products.id                                           
             WHEN IS NOT DISTINCT FROM 1 THEN 'Southlake'::text     
             WHEN IS NOT DISTINCT FROM 2 THEN 'San Francisco'::text 
             WHEN IS NOT DISTINCT FROM 3 THEN 'New Jersey'::text    
             WHEN IS NOT DISTINCT FROM 4 THEN 'Seattle'::text       
             WHEN IS NOT DISTINCT FROM 5 THEN 'Portland'::text      
             WHEN IS NOT DISTINCT FROM 6 THEN 'San Francisco'::text 
             WHEN IS NOT DISTINCT FROM 7 THEN 'Portland'::text      
             ELSE 'Non domestic'::text                              
         END AS location                                            
    FROM products                                                   
   WHERE products.id < 100;
(1 row)

-- User-defined DECODE function
CREATE OR REPLACE FUNCTION "decode"(int, int, int) RETURNS int
AS 'select $1 * $2 - $3;'
LANGUAGE sql CONTAINS SQL
IMMUTABLE
RETURNS null ON null input;
SELECT decode(11,8,11);
 case 
------
     
(1 row)

SELECT "decode"(11,8,11);
 decode 
--------
     77
(1 row)

SELECT public.decode(11,8,11);
 decode 
--------
     77
(1 row)

-- Test CASE x WHEN IS NOT DISTINCT FROM y with DECODE
SELECT a,b,decode(a,1,1), 
		CASE decode(a,1,1) WHEN IS NOT DISTINCT FROM 1 THEN b*100
                  		   WHEN IS NOT DISTINCT FROM 4 THEN b*1000 ELSE b END as newb
  FROM mytable ORDER BY a,b; 
 a | b | case | newb 
---+---+------+------
 1 | 2 |    1 |  200
 2 | 3 |      |    3
 3 | 4 |      |    4
 4 | 4 |      |    4
 4 | 5 |      |    5
 5 | 5 |      |    5
 6 | 6 |      |    6
 7 | 6 |      |    6
 8 | 7 |      |    7
 9 | 8 |      |    8
(10 rows)

-- Test CASE WHEN x IS NOT DISTINCT FROM y with DECODE
SELECT a,b,decode(a,1,1), 
		CASE WHEN decode(a,1,1) IS NOT DISTINCT FROM 1 THEN b*100
			 WHEN decode(a,1,1) IS NOT DISTINCT FROM 4 THEN b*1000 ELSE b END as newb
  FROM mytable ORDER BY a,b; 
 a | b | case | newb 
---+---+------+------
 1 | 2 |    1 |  200
 2 | 3 |      |    3
 3 | 4 |      |    4
 4 | 4 |      |    4
 4 | 5 |      |    5
 5 | 5 |      |    5
 6 | 6 |      |    6
 7 | 6 |      |    6
 8 | 7 |      |    7
 9 | 8 |      |    8
(10 rows)

SELECT a,b,"decode"(a,1,1), 
			CASE WHEN "decode"(a,1,1) IS NOT DISTINCT FROM 1 THEN b*100
                 WHEN "decode"(a,1,1) IS NOT DISTINCT FROM 4 THEN b*1000 ELSE b END as newb
  FROM mytable ORDER BY a,b; 
 a | b | decode | newb 
---+---+--------+------
 1 | 2 |      0 |    2
 2 | 3 |      1 |  300
 3 | 4 |      2 |    4
 4 | 4 |      3 |    4
 4 | 5 |      3 |    5
 5 | 5 |      4 | 5000
 6 | 6 |      5 |    6
 7 | 6 |      6 |    6
 8 | 7 |      7 |    7
 9 | 8 |      8 |    8
(10 rows)

-- Negative test: type mismatches
SELECT b,c,decode(c,'a',ARRAY[1,2],'e',ARRAY[3,4],'o',ARRAY[5,6],'u',ARRAY[7,8],'i',ARRAY[9,10],0) as newb from mytable;
ERROR:  CASE types integer and integer[] cannot be matched
LINE 1: SELECT b,c,decode(c,'a',ARRAY[1,2],'e',ARRAY[3,4],'o',ARRAY[...
                          ^
--
-- Clean up
--
DROP TABLE CASE_TBL;
DROP TABLE CASE2_TBL;
DROP TABLE mytable CASCADE;
DROP TABLE products CASCADE;
NOTICE:  drop cascades to rule _RETURN on view myview
NOTICE:  drop cascades to view myview
DROP TABLE calls_to_blip;
DROP FUNCTION negate(int);
DROP FUNCTION "decode"(int, int, int);
DROP FUNCTION blip(int);
