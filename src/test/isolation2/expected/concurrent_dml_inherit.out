-- This test focus on inherit table.
-- DMLs can operate on root or directly on the leaf.
-- Such DMLs on the same partition group might modify
-- the same table even their result relation is not
-- same. So to serialize these DMLs, their root relid
-- is taken into consideration. This test scripts is
-- `test: concurrent_dmls`. The difference is that
-- this concurrent transactions in this test, one is
-- on root table, the other is on leaf table.

-- Test two operations on same table should be serialized on QD: normal update, split-update
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5

1: begin;
BEGIN
2: begin;
BEGIN

1: update tinherit_concurrent_dmls_base set c2 = 999 where c2 = 1;
UPDATE 1
2&: update tinherit_concurrent_dmls_child set c1 = 888 where c1 = 1;  <waiting ...>

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode             | granted 
---------------+--------------+-------------------------------+------------------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | RowExclusiveLock | t       
 -1            | relation-dml | tinherit_concurrent_dmls_base | ExclusiveLock    | f       
(2 rows)

1: end;
END
2<:  <... completed>
UPDATE 0
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2  | c3 
----+-----+----
 3  | 3   | 3  
 1  | 999 | 1  
 13 | 13  | 13 
 14 | 14  | 14 
 15 | 15  | 15 
 2  | 2   | 2  
 5  | 5   | 5  
 6  | 6   | 6  
 9  | 9   | 9  
 10 | 10  | 10 
 12 | 12  | 12 
 4  | 4   | 4  
 7  | 7   | 7  
 8  | 8   | 8  
 11 | 11  | 11 
(15 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 12 | 12 | 12 | 12 
 13 | 13 | 13 | 13 
 14 | 14 | 14 | 14 
 15 | 15 | 15 | 15 
 11 | 11 | 11 | 11 
(5 rows)


drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP

-- Test two operations on same table should be serialized on QD: normal update, update whose plan contains motion
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
create table tinherit_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5
insert into tinherit_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: update tinherit_concurrent_dmls_base set c2 = 777 from tinherit_concurrent_dmls_auxiliary where tinherit_concurrent_dmls_base.c3 = tinherit_concurrent_dmls_auxiliary.c3;
UPDATE 2
2&: update tinherit_concurrent_dmls_child set c2 = 999 where c2 = 1;  <waiting ...>

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode                  | granted 
---------------+--------------+-------------------------------+-----------------------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | ShareRowExclusiveLock | t       
 -1            | relation-dml | tinherit_concurrent_dmls_base | RowExclusiveLock      | f       
(2 rows)

1: end;
END
2<:  <... completed>
UPDATE 0
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2  | c3 
----+-----+----
 4  | 4   | 4  
 7  | 7   | 7  
 8  | 8   | 8  
 11 | 11  | 11 
 5  | 5   | 5  
 6  | 6   | 6  
 9  | 9   | 9  
 10 | 10  | 10 
 2  | 777 | 2  
 12 | 12  | 12 
 3  | 3   | 3  
 1  | 777 | 1  
 13 | 13  | 13 
 14 | 14  | 14 
 15 | 15  | 15 
(15 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 12 | 12 | 12 | 12 
 11 | 11 | 11 | 11 
 13 | 13 | 13 | 13 
 14 | 14 | 14 | 14 
 15 | 15 | 15 | 15 
(5 rows)

select * from tinherit_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 1  | 1  | 1  
 2  | 2  | 2  
(2 rows)

drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP
drop table tinherit_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table should be serialized on QD: normal update, delete whose plan contains motion
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
create table tinherit_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5
insert into tinherit_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tinherit_concurrent_dmls_base using tinherit_concurrent_dmls_auxiliary where tinherit_concurrent_dmls_base.c3 = tinherit_concurrent_dmls_auxiliary.c3;
DELETE 2
2&: update tinherit_concurrent_dmls_child set c2 = 999 where c2 = 1;  <waiting ...>

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode             | granted 
---------------+--------------+-------------------------------+------------------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | ShareLock        | t       
 -1            | relation-dml | tinherit_concurrent_dmls_base | RowExclusiveLock | f       
(2 rows)

1: end;
END
2<:  <... completed>
UPDATE 0
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2 | c3 
----+----+----
 3  | 3  | 3  
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 4  | 4  | 4  
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
(13 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 13 | 13 | 13 | 13 
 14 | 14 | 14 | 14 
 15 | 15 | 15 | 15 
 12 | 12 | 12 | 12 
 11 | 11 | 11 | 11 
(5 rows)

select * from tinherit_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 1  | 1  | 1  
(2 rows)

drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP
drop table tinherit_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table should be serialized on QD: normal delete, split-update
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tinherit_concurrent_dmls_base where c2 = 1;
DELETE 1
2&: update tinherit_concurrent_dmls_child set c1 = 888 where c1 = 1;  <waiting ...>

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode          | granted 
---------------+--------------+-------------------------------+---------------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | ExclusiveLock | f       
 -1            | relation-dml | tinherit_concurrent_dmls_base | RowShareLock  | t       
(2 rows)

1: end;
END
2<:  <... completed>
UPDATE 0
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2 | c3 
----+----+----
 3  | 3  | 3  
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 4  | 4  | 4  
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 2  | 2  | 2  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
(14 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 13 | 13 | 13 | 13 
 14 | 14 | 14 | 14 
 15 | 15 | 15 | 15 
 12 | 12 | 12 | 12 
 11 | 11 | 11 | 11 
(5 rows)


drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP

-- Test two operations on same table should be serialized on QD: split-update, split-update
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5

1: begin;
BEGIN
2: begin;
BEGIN

1: update tinherit_concurrent_dmls_base set c1 = 888 where c1 = 1;
UPDATE 1
2&: update tinherit_concurrent_dmls_child set c1 = 888 where c1 = 1;  <waiting ...>

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode          | granted 
---------------+--------------+-------------------------------+---------------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | ExclusiveLock | f       
 -1            | relation-dml | tinherit_concurrent_dmls_base | ExclusiveLock | t       
(2 rows)

1: end;
END
2<:  <... completed>
UPDATE 0
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1  | c2 | c3 
-----+----+----
 4   | 4  | 4  
 7   | 7  | 7  
 8   | 8  | 8  
 888 | 1  | 1  
 11  | 11 | 11 
 3   | 3  | 3  
 13  | 13 | 13 
 14  | 14 | 14 
 15  | 15 | 15 
 2   | 2  | 2  
 5   | 5  | 5  
 6   | 6  | 6  
 9   | 9  | 9  
 10  | 10 | 10 
 12  | 12 | 12 
(15 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 11 | 11 | 11 | 11 
 13 | 13 | 13 | 13 
 14 | 14 | 14 | 14 
 15 | 15 | 15 | 15 
 12 | 12 | 12 | 12 
(5 rows)


drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP

-- Test two operations on same table should be serialized on QD: split-update, update whose plan contains motion
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
create table tinherit_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5
insert into tinherit_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: update tinherit_concurrent_dmls_base set c2 = 777 from tinherit_concurrent_dmls_auxiliary where tinherit_concurrent_dmls_base.c3 = tinherit_concurrent_dmls_auxiliary.c3;
UPDATE 2
2&: update tinherit_concurrent_dmls_child set c1 = 888 where c1 = 1;  <waiting ...>

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode                  | granted 
---------------+--------------+-------------------------------+-----------------------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | ShareRowExclusiveLock | t       
 -1            | relation-dml | tinherit_concurrent_dmls_base | ExclusiveLock         | f       
(2 rows)

1: end;
END
2<:  <... completed>
UPDATE 0
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2  | c3 
----+-----+----
 5  | 5   | 5  
 6  | 6   | 6  
 9  | 9   | 9  
 10 | 10  | 10 
 2  | 777 | 2  
 12 | 12  | 12 
 3  | 3   | 3  
 1  | 777 | 1  
 13 | 13  | 13 
 14 | 14  | 14 
 15 | 15  | 15 
 4  | 4   | 4  
 7  | 7   | 7  
 8  | 8   | 8  
 11 | 11  | 11 
(15 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 11 | 11 | 11 | 11 
 12 | 12 | 12 | 12 
 13 | 13 | 13 | 13 
 14 | 14 | 14 | 14 
 15 | 15 | 15 | 15 
(5 rows)

select * from tinherit_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 1  | 1  | 1  
 2  | 2  | 2  
(2 rows)

drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP
drop table tinherit_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table should be serialized on QD: split-update, delete whose plan contains motion
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
create table tinherit_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5
insert into tinherit_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tinherit_concurrent_dmls_base using tinherit_concurrent_dmls_auxiliary where tinherit_concurrent_dmls_base.c3 = tinherit_concurrent_dmls_auxiliary.c3;
DELETE 2
2&: update tinherit_concurrent_dmls_child set c1 = 888 where c1 = 1;  <waiting ...>

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode          | granted 
---------------+--------------+-------------------------------+---------------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | ShareLock     | t       
 -1            | relation-dml | tinherit_concurrent_dmls_base | ExclusiveLock | f       
(2 rows)

1: end;
END
2<:  <... completed>
UPDATE 0
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2 | c3 
----+----+----
 4  | 4  | 4  
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
 3  | 3  | 3  
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
(13 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 11 | 11 | 11 | 11 
 13 | 13 | 13 | 13 
 14 | 14 | 14 | 14 
 15 | 15 | 15 | 15 
 12 | 12 | 12 | 12 
(5 rows)

select * from tinherit_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 1  | 1  | 1  
(2 rows)

drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP
drop table tinherit_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table should be serialized on QD: update whose plan contains motion, update whose plan contains motion
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
create table tinherit_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5
insert into tinherit_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: update tinherit_concurrent_dmls_base set c2 = 777 from tinherit_concurrent_dmls_auxiliary where tinherit_concurrent_dmls_base.c3 = tinherit_concurrent_dmls_auxiliary.c3;
UPDATE 2
2&: update tinherit_concurrent_dmls_child set c2 = 777 from tinherit_concurrent_dmls_auxiliary where tinherit_concurrent_dmls_child.c3 = tinherit_concurrent_dmls_auxiliary.c3;  <waiting ...>

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode                  | granted 
---------------+--------------+-------------------------------+-----------------------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | ShareRowExclusiveLock | t       
 -1            | relation-dml | tinherit_concurrent_dmls_base | ShareRowExclusiveLock | f       
(2 rows)

1: end;
END
2<:  <... completed>
UPDATE 0
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2  | c3 
----+-----+----
 4  | 4   | 4  
 7  | 7   | 7  
 8  | 8   | 8  
 11 | 11  | 11 
 5  | 5   | 5  
 6  | 6   | 6  
 9  | 9   | 9  
 10 | 10  | 10 
 2  | 777 | 2  
 12 | 12  | 12 
 3  | 3   | 3  
 1  | 777 | 1  
 13 | 13  | 13 
 14 | 14  | 14 
 15 | 15  | 15 
(15 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 13 | 13 | 13 | 13 
 14 | 14 | 14 | 14 
 15 | 15 | 15 | 15 
 11 | 11 | 11 | 11 
 12 | 12 | 12 | 12 
(5 rows)

select * from tinherit_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 1  | 1  | 1  
(2 rows)

drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP
drop table tinherit_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table should be serialized on QD: update whose plan contains motion, delete whose plan contains motion
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
create table tinherit_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5
insert into tinherit_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tinherit_concurrent_dmls_base using tinherit_concurrent_dmls_auxiliary where tinherit_concurrent_dmls_base.c3 = tinherit_concurrent_dmls_auxiliary.c3;
DELETE 2
2&: update tinherit_concurrent_dmls_child set c2 = 777 from tinherit_concurrent_dmls_auxiliary where tinherit_concurrent_dmls_child.c3 = tinherit_concurrent_dmls_auxiliary.c3;  <waiting ...>

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode                  | granted 
---------------+--------------+-------------------------------+-----------------------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | ShareLock             | t       
 -1            | relation-dml | tinherit_concurrent_dmls_base | ShareRowExclusiveLock | f       
(2 rows)

1: end;
END
2<:  <... completed>
UPDATE 0
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2 | c3 
----+----+----
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
 3  | 3  | 3  
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 4  | 4  | 4  
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
(13 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 11 | 11 | 11 | 11 
 12 | 12 | 12 | 12 
 13 | 13 | 13 | 13 
 14 | 14 | 14 | 14 
 15 | 15 | 15 | 15 
(5 rows)

select * from tinherit_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 1  | 1  | 1  
(2 rows)

drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP
drop table tinherit_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table can be concurrent on QD: normal update, normal delete
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tinherit_concurrent_dmls_base where c2 = 1;
DELETE 1
2: update tinherit_concurrent_dmls_child set c2 =666 where c2 = 2;
UPDATE 0

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode             | granted 
---------------+--------------+-------------------------------+------------------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | RowShareLock     | t       
 -1            | relation-dml | tinherit_concurrent_dmls_base | RowExclusiveLock | t       
(2 rows)
1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
 3  | 3  | 3  
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 4  | 4  | 4  
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
(14 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 12 | 12 | 12 | 12 
 11 | 11 | 11 | 11 
 13 | 13 | 13 | 13 
 14 | 14 | 14 | 14 
 15 | 15 | 15 | 15 
(5 rows)


drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP

-- Test two operations on same table can be concurrent on QD: normal update, insert
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5

1: begin;
BEGIN
2: begin;
BEGIN

1: insert into tinherit_concurrent_dmls_base select * from generate_series(1, 5);
INSERT 5
2: update tinherit_concurrent_dmls_child set c2 =666 where c2 = 2;
UPDATE 0

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode             | granted 
---------------+--------------+-------------------------------+------------------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | RowExclusiveLock | t       
(1 row)
1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 2  |    |    
 5  |    |    
 12 | 12 | 12 
 1  | 1  | 1  
 3  | 3  | 3  
 1  |    |    
 3  |    |    
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 4  | 4  | 4  
 7  | 7  | 7  
 8  | 8  | 8  
 4  |    |    
 11 | 11 | 11 
(20 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 11 | 11 | 11 | 11 
 12 | 12 | 12 | 12 
 13 | 13 | 13 | 13 
 14 | 14 | 14 | 14 
 15 | 15 | 15 | 15 
(5 rows)


drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP

-- Test two operations on same table can be concurrent on QD: normal update, normal update
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5

1: begin;
BEGIN
2: begin;
BEGIN

1: update tinherit_concurrent_dmls_base set c2 = 999 where c2 = 1;
UPDATE 1
2: update tinherit_concurrent_dmls_child set c2 =666 where c2 = 2;
UPDATE 0

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode             | granted 
---------------+--------------+-------------------------------+------------------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | RowExclusiveLock | t       
 -1            | relation-dml | tinherit_concurrent_dmls_base | RowExclusiveLock | t       
(2 rows)
1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2  | c3 
----+-----+----
 4  | 4   | 4  
 7  | 7   | 7  
 8  | 8   | 8  
 11 | 11  | 11 
 2  | 2   | 2  
 5  | 5   | 5  
 6  | 6   | 6  
 9  | 9   | 9  
 10 | 10  | 10 
 12 | 12  | 12 
 3  | 3   | 3  
 1  | 999 | 1  
 13 | 13  | 13 
 14 | 14  | 14 
 15 | 15  | 15 
(15 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 13 | 13 | 13 | 13 
 14 | 14 | 14 | 14 
 15 | 15 | 15 | 15 
 11 | 11 | 11 | 11 
 12 | 12 | 12 | 12 
(5 rows)


drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP

-- Test two operations on same table can be concurrent on QD: normal delete, update whose plan contains motion
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
create table tinherit_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5
insert into tinherit_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tinherit_concurrent_dmls_base where c2 = 1;
DELETE 1
2: update tinherit_concurrent_dmls_child set c2 = 777 from tinherit_concurrent_dmls_auxiliary where tinherit_concurrent_dmls_child.c3 = tinherit_concurrent_dmls_auxiliary.c3;
UPDATE 0

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode                  | granted 
---------------+--------------+-------------------------------+-----------------------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | ShareRowExclusiveLock | t       
 -1            | relation-dml | tinherit_concurrent_dmls_base | RowShareLock          | t       
(2 rows)
1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2 | c3 
----+----+----
 3  | 3  | 3  
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 4  | 4  | 4  
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 2  | 2  | 2  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
(14 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 11 | 11 | 11 | 11 
 13 | 13 | 13 | 13 
 14 | 14 | 14 | 14 
 15 | 15 | 15 | 15 
 12 | 12 | 12 | 12 
(5 rows)

select * from tinherit_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 1  | 1  | 1  
(2 rows)

drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP
drop table tinherit_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table can be concurrent on QD: normal delete, delete whose plan contains motion
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
create table tinherit_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5
insert into tinherit_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tinherit_concurrent_dmls_base where c2 = 1;
DELETE 1
2: delete from tinherit_concurrent_dmls_child using tinherit_concurrent_dmls_auxiliary where tinherit_concurrent_dmls_child.c3 > tinherit_concurrent_dmls_auxiliary.c3 + 10;
DELETE 4

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode         | granted 
---------------+--------------+-------------------------------+--------------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | ShareLock    | t       
 -1            | relation-dml | tinherit_concurrent_dmls_base | RowShareLock | t       
(2 rows)
1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2 | c3 
----+----+----
 4  | 4  | 4  
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 3  | 3  | 3  
 2  | 2  | 2  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
(10 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 11 | 11 | 11 | 11 
(1 row)

select * from tinherit_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 1  | 1  | 1  
(2 rows)

drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP
drop table tinherit_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table can be concurrent on QD: normal delete, normal delete
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tinherit_concurrent_dmls_base where c2 = 1;
DELETE 1
2: delete from tinherit_concurrent_dmls_child where c2 = 2;
DELETE 0

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode         | granted 
---------------+--------------+-------------------------------+--------------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | RowShareLock | t       
 -1            | relation-dml | tinherit_concurrent_dmls_base | RowShareLock | t       
(2 rows)
1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2 | c3 
----+----+----
 3  | 3  | 3  
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 2  | 2  | 2  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
 4  | 4  | 4  
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
(14 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 13 | 13 | 13 | 13 
 14 | 14 | 14 | 14 
 15 | 15 | 15 | 15 
 11 | 11 | 11 | 11 
 12 | 12 | 12 | 12 
(5 rows)


drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP

-- Test two operations on same table can be concurrent on QD: normal delete, insert
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tinherit_concurrent_dmls_base where c2 = 1;
DELETE 1
2: insert into tinherit_concurrent_dmls_child select * from generate_series(1, 5);
INSERT 5

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode         | granted 
---------------+--------------+-------------------------------+--------------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | RowShareLock | t       
(1 row)
1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
 2  |    |    
 5  |    |    
 3  | 3  | 3  
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 1  |    |    
 3  |    |    
 4  | 4  | 4  
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 4  |    |    
(19 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 12 | 12 | 12 | 12 
 2  |    |    |    
 5  |    |    |    
 13 | 13 | 13 | 13 
 14 | 14 | 14 | 14 
 15 | 15 | 15 | 15 
 1  |    |    |    
 3  |    |    |    
 11 | 11 | 11 | 11 
 4  |    |    |    
(10 rows)


drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP

-- Test two operations on same table can be concurrent on QD: split-update, insert
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5

1: begin;
BEGIN
2: begin;
BEGIN

1: insert into tinherit_concurrent_dmls_base select * from generate_series(1, 5);
INSERT 5
2: update tinherit_concurrent_dmls_child set c1 = 888 where c1 = 1;
UPDATE 0

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode          | granted 
---------------+--------------+-------------------------------+---------------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | ExclusiveLock | t       
(1 row)
1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2 | c3 
----+----+----
 4  | 4  | 4  
 7  | 7  | 7  
 8  | 8  | 8  
 4  |    |    
 11 | 11 | 11 
 2  | 2  | 2  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 2  |    |    
 5  |    |    
 12 | 12 | 12 
 1  | 1  | 1  
 3  | 3  | 3  
 1  |    |    
 3  |    |    
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
(20 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 11 | 11 | 11 | 11 
 12 | 12 | 12 | 12 
 13 | 13 | 13 | 13 
 14 | 14 | 14 | 14 
 15 | 15 | 15 | 15 
(5 rows)


drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP

-- Test two operations on same table can be concurrent on QD: update whose plan contains motion, insert
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
create table tinherit_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5
insert into tinherit_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: insert into tinherit_concurrent_dmls_base select * from generate_series(1, 5);
INSERT 5
2: update tinherit_concurrent_dmls_child set c2 = 777 from tinherit_concurrent_dmls_auxiliary where tinherit_concurrent_dmls_child.c3 = tinherit_concurrent_dmls_auxiliary.c3;
UPDATE 0

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode                  | granted 
---------------+--------------+-------------------------------+-----------------------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | ShareRowExclusiveLock | t       
(1 row)
1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 2  |    |    
 5  |    |    
 12 | 12 | 12 
 4  | 4  | 4  
 7  | 7  | 7  
 8  | 8  | 8  
 4  |    |    
 11 | 11 | 11 
 1  | 1  | 1  
 3  | 3  | 3  
 1  |    |    
 3  |    |    
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
(20 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 11 | 11 | 11 | 11 
 12 | 12 | 12 | 12 
 13 | 13 | 13 | 13 
 14 | 14 | 14 | 14 
 15 | 15 | 15 | 15 
(5 rows)

select * from tinherit_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 1  | 1  | 1  
(2 rows)

drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP
drop table tinherit_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table can be concurrent on QD: delete whose plan contains motion, insert
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
create table tinherit_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5
insert into tinherit_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: insert into tinherit_concurrent_dmls_base select * from generate_series(1, 5);
INSERT 5
2: delete from tinherit_concurrent_dmls_child using tinherit_concurrent_dmls_auxiliary where tinherit_concurrent_dmls_child.c3 > tinherit_concurrent_dmls_auxiliary.c3 + 10;
DELETE 4

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode      | granted 
---------------+--------------+-------------------------------+-----------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | ShareLock | t       
(1 row)
1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2 | c3 
----+----+----
 4  | 4  | 4  
 7  | 7  | 7  
 8  | 8  | 8  
 4  |    |    
 11 | 11 | 11 
 1  | 1  | 1  
 3  | 3  | 3  
 1  |    |    
 3  |    |    
 2  | 2  | 2  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 2  |    |    
 5  |    |    
(16 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 11 | 11 | 11 | 11 
(1 row)

select * from tinherit_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 1  | 1  | 1  
(2 rows)

drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP
drop table tinherit_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table can be concurrent on QD: delete whose plan contains motion, delete whose plan contains motion
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
create table tinherit_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5
insert into tinherit_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tinherit_concurrent_dmls_base using tinherit_concurrent_dmls_auxiliary where tinherit_concurrent_dmls_base.c3 = tinherit_concurrent_dmls_auxiliary.c3;
DELETE 2
2: delete from tinherit_concurrent_dmls_child using tinherit_concurrent_dmls_auxiliary where tinherit_concurrent_dmls_child.c3 > tinherit_concurrent_dmls_auxiliary.c3 + 10;
DELETE 4

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype     | relation                      | mode      | granted 
---------------+--------------+-------------------------------+-----------+---------
 -1            | relation-dml | tinherit_concurrent_dmls_base | ShareLock | t       
 -1            | relation-dml | tinherit_concurrent_dmls_base | ShareLock | t       
(2 rows)
1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2 | c3 
----+----+----
 4  | 4  | 4  
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 3  | 3  | 3  
(9 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 11 | 11 | 11 | 11 
(1 row)

select * from tinherit_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 1  | 1  | 1  
(2 rows)

drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP
drop table tinherit_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table can be concurrent on QD: insert, insert
create table tinherit_concurrent_dmls_base(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
create table tinherit_concurrent_dmls_child(c4 int) inherits (tinherit_concurrent_dmls_base);
CREATE
insert into tinherit_concurrent_dmls_base select i,i,i from generate_series(1, 10)i;
INSERT 10
insert into tinherit_concurrent_dmls_child select i,i,i,i from generate_series(11, 15)i;
INSERT 5

1: begin;
BEGIN
2: begin;
BEGIN

1: insert into tinherit_concurrent_dmls_base select * from generate_series(1, 5);
INSERT 5
2: insert into tinherit_concurrent_dmls_child select * from generate_series(1, 5);
INSERT 5

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tinherit_concurrent_dmls%';
 gp_segment_id | locktype | relation | mode | granted 
---------------+----------+----------+------+---------
(0 rows)
1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tinherit_concurrent_dmls_base;
 c1 | c2 | c3 
----+----+----
 4  | 4  | 4  
 7  | 7  | 7  
 8  | 8  | 8  
 4  |    |    
 11 | 11 | 11 
 4  |    |    
 1  | 1  | 1  
 3  | 3  | 3  
 1  |    |    
 3  |    |    
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 1  |    |    
 3  |    |    
 2  | 2  | 2  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 2  |    |    
 5  |    |    
 12 | 12 | 12 
 2  |    |    
 5  |    |    
(25 rows)
select * from tinherit_concurrent_dmls_child;
 c1 | c2 | c3 | c4 
----+----+----+----
 12 | 12 | 12 | 12 
 2  |    |    |    
 5  |    |    |    
 13 | 13 | 13 | 13 
 14 | 14 | 14 | 14 
 15 | 15 | 15 | 15 
 1  |    |    |    
 3  |    |    |    
 11 | 11 | 11 | 11 
 4  |    |    |    
(10 rows)


drop table tinherit_concurrent_dmls_child;
DROP
drop table tinherit_concurrent_dmls_base;
DROP

