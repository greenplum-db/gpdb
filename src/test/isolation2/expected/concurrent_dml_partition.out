-- This test focus on partition table.
-- DMLs can operate on root or directly on the leaf.
-- Such DMLs on the same partition group might modify
-- the same table even their result relation is not
-- same. So to serialize these DMLs, their root relid
-- is taken into consideration. This test scripts is
-- `test: concurrent_dmls`. The difference is that
-- this concurrent transactions in this test, one is
-- on root table, the other is on leaf table.

-- Test two operations on same table should be serialized on QD: normal update, split-update
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20

1: begin;
BEGIN
2: begin;
BEGIN

1: update tpart_concurrent_dmls set c2 = 999 where c2 = 1;
UPDATE 1
2&: update tpart_concurrent_dmls_1_prt_2 set c1 = 888 where c1 = 1;  <waiting ...>

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode             | granted 
---------------+--------------+-----------------------+------------------+---------
 -1            | relation-dml | tpart_concurrent_dmls | ExclusiveLock    | f       
 -1            | relation-dml | tpart_concurrent_dmls | RowExclusiveLock | t       
(2 rows)

1: end;
END
2<:  <... completed>
UPDATE 1
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1  | c2  | c3 
-----+-----+----
 7   | 7   | 7  
 8   | 8   | 8  
 11  | 11  | 11 
 17  | 17  | 17 
 18  | 18  | 18 
 888 | 999 | 1  
 4   | 4   | 4  
 13  | 13  | 13 
 14  | 14  | 14 
 15  | 15  | 15 
 19  | 19  | 19 
 3   | 3   | 3  
 5   | 5   | 5  
 6   | 6   | 6  
 9   | 9   | 9  
 10  | 10  | 10 
 12  | 12  | 12 
 16  | 16  | 16 
 20  | 20  | 20 
 2   | 2   | 2  
(20 rows)

drop table tpart_concurrent_dmls;
DROP

-- Test two operations on same table should be serialized on QD: normal update, update whose plan contains motion
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
create table tpart_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20
insert into tpart_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: update tpart_concurrent_dmls set c2 = 777 from tpart_concurrent_dmls_auxiliary where tpart_concurrent_dmls.c3 = tpart_concurrent_dmls_auxiliary.c3;
UPDATE 2
2&: update tpart_concurrent_dmls_1_prt_2 set c2 = 999 where c2 = 1;  <waiting ...>

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode                  | granted 
---------------+--------------+-----------------------+-----------------------+---------
 -1            | relation-dml | tpart_concurrent_dmls | ShareRowExclusiveLock | t       
 -1            | relation-dml | tpart_concurrent_dmls | RowExclusiveLock      | f       
(2 rows)

1: end;
END
2<:  <... completed>
UPDATE 0
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1 | c2  | c3 
----+-----+----
 7  | 7   | 7  
 8  | 8   | 8  
 11 | 11  | 11 
 17 | 17  | 17 
 18 | 18  | 18 
 4  | 4   | 4  
 13 | 13  | 13 
 14 | 14  | 14 
 15 | 15  | 15 
 19 | 19  | 19 
 1  | 777 | 1  
 3  | 3   | 3  
 5  | 5   | 5  
 6  | 6   | 6  
 9  | 9   | 9  
 10 | 10  | 10 
 12 | 12  | 12 
 16 | 16  | 16 
 20 | 20  | 20 
 2  | 777 | 2  
(20 rows)
select * from tpart_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 1  | 1  | 1  
(2 rows)

drop table tpart_concurrent_dmls;
DROP
drop table tpart_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table should be serialized on QD: normal update, delete whose plan contains motion
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
create table tpart_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20
insert into tpart_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tpart_concurrent_dmls using tpart_concurrent_dmls_auxiliary where tpart_concurrent_dmls.c3 = tpart_concurrent_dmls_auxiliary.c3;
DELETE 2
2&: update tpart_concurrent_dmls_1_prt_2 set c2 = 999 where c2 = 1;  <waiting ...>

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode             | granted 
---------------+--------------+-----------------------+------------------+---------
 -1            | relation-dml | tpart_concurrent_dmls | ShareLock        | t       
 -1            | relation-dml | tpart_concurrent_dmls | RowExclusiveLock | f       
(2 rows)

1: end;
END
2<:  <... completed>
UPDATE 0
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1 | c2 | c3 
----+----+----
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 19 | 19 | 19 
 3  | 3  | 3  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
 16 | 16 | 16 
 20 | 20 | 20 
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 17 | 17 | 17 
 18 | 18 | 18 
 4  | 4  | 4  
(18 rows)
select * from tpart_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 1  | 1  | 1  
(2 rows)

drop table tpart_concurrent_dmls;
DROP
drop table tpart_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table should be serialized on QD: normal delete, split-update
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tpart_concurrent_dmls where c2 = 1;
DELETE 1
2&: update tpart_concurrent_dmls_1_prt_2 set c1 = 888 where c1 = 1;  <waiting ...>

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode          | granted 
---------------+--------------+-----------------------+---------------+---------
 -1            | relation-dml | tpart_concurrent_dmls | RowShareLock  | t       
 -1            | relation-dml | tpart_concurrent_dmls | ExclusiveLock | f       
(2 rows)

1: end;
END
2<:  <... completed>
UPDATE 0
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1 | c2 | c3 
----+----+----
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 17 | 17 | 17 
 18 | 18 | 18 
 4  | 4  | 4  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
 16 | 16 | 16 
 20 | 20 | 20 
 2  | 2  | 2  
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 19 | 19 | 19 
 3  | 3  | 3  
(19 rows)

drop table tpart_concurrent_dmls;
DROP

-- Test two operations on same table should be serialized on QD: split-update, split-update
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20

1: begin;
BEGIN
2: begin;
BEGIN

1: update tpart_concurrent_dmls set c1 = 888 where c1 = 1;
UPDATE 1
2&: update tpart_concurrent_dmls_1_prt_2 set c1 = 888 where c1 = 1;  <waiting ...>

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode          | granted 
---------------+--------------+-----------------------+---------------+---------
 -1            | relation-dml | tpart_concurrent_dmls | ExclusiveLock | t       
 -1            | relation-dml | tpart_concurrent_dmls | ExclusiveLock | f       
(2 rows)

1: end;
END
2<:  <... completed>
UPDATE 0
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1  | c2 | c3 
-----+----+----
 7   | 7  | 7  
 8   | 8  | 8  
 11  | 11 | 11 
 17  | 17 | 17 
 18  | 18 | 18 
 888 | 1  | 1  
 4   | 4  | 4  
 5   | 5  | 5  
 6   | 6  | 6  
 9   | 9  | 9  
 10  | 10 | 10 
 12  | 12 | 12 
 16  | 16 | 16 
 20  | 20 | 20 
 2   | 2  | 2  
 13  | 13 | 13 
 14  | 14 | 14 
 15  | 15 | 15 
 19  | 19 | 19 
 3   | 3  | 3  
(20 rows)

drop table tpart_concurrent_dmls;
DROP

-- Test two operations on same table should be serialized on QD: split-update, update whose plan contains motion
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
create table tpart_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20
insert into tpart_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: update tpart_concurrent_dmls set c2 = 777 from tpart_concurrent_dmls_auxiliary where tpart_concurrent_dmls.c3 = tpart_concurrent_dmls_auxiliary.c3;
UPDATE 2
2&: update tpart_concurrent_dmls_1_prt_2 set c1 = 888 where c1 = 1;  <waiting ...>

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode                  | granted 
---------------+--------------+-----------------------+-----------------------+---------
 -1            | relation-dml | tpart_concurrent_dmls | ExclusiveLock         | f       
 -1            | relation-dml | tpart_concurrent_dmls | ShareRowExclusiveLock | t       
(2 rows)

1: end;
END
2<:  <... completed>
UPDATE 1
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1  | c2  | c3 
-----+-----+----
 5   | 5   | 5  
 6   | 6   | 6  
 9   | 9   | 9  
 10  | 10  | 10 
 12  | 12  | 12 
 16  | 16  | 16 
 20  | 20  | 20 
 2   | 777 | 2  
 13  | 13  | 13 
 14  | 14  | 14 
 15  | 15  | 15 
 19  | 19  | 19 
 3   | 3   | 3  
 7   | 7   | 7  
 8   | 8   | 8  
 11  | 11  | 11 
 17  | 17  | 17 
 18  | 18  | 18 
 888 | 777 | 1  
 4   | 4   | 4  
(20 rows)
select * from tpart_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 1  | 1  | 1  
(2 rows)

drop table tpart_concurrent_dmls;
DROP
drop table tpart_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table should be serialized on QD: split-update, delete whose plan contains motion
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
create table tpart_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20
insert into tpart_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tpart_concurrent_dmls using tpart_concurrent_dmls_auxiliary where tpart_concurrent_dmls.c3 = tpart_concurrent_dmls_auxiliary.c3;
DELETE 2
2&: update tpart_concurrent_dmls_1_prt_2 set c1 = 888 where c1 = 1;  <waiting ...>

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode          | granted 
---------------+--------------+-----------------------+---------------+---------
 -1            | relation-dml | tpart_concurrent_dmls | ShareLock     | t       
 -1            | relation-dml | tpart_concurrent_dmls | ExclusiveLock | f       
(2 rows)

1: end;
END
2<:  <... completed>
UPDATE 0
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1 | c2 | c3 
----+----+----
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 19 | 19 | 19 
 3  | 3  | 3  
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 17 | 17 | 17 
 18 | 18 | 18 
 4  | 4  | 4  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
 16 | 16 | 16 
 20 | 20 | 20 
(18 rows)
select * from tpart_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 1  | 1  | 1  
(2 rows)

drop table tpart_concurrent_dmls;
DROP
drop table tpart_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table should be serialized on QD: update whose plan contains motion, update whose plan contains motion
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
create table tpart_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20
insert into tpart_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: update tpart_concurrent_dmls set c2 = 777 from tpart_concurrent_dmls_auxiliary where tpart_concurrent_dmls.c3 = tpart_concurrent_dmls_auxiliary.c3;
UPDATE 2
2&: update tpart_concurrent_dmls_1_prt_2 set c2 = 777 from tpart_concurrent_dmls_auxiliary where tpart_concurrent_dmls_1_prt_2.c3 = tpart_concurrent_dmls_auxiliary.c3;  <waiting ...>

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode                  | granted 
---------------+--------------+-----------------------+-----------------------+---------
 -1            | relation-dml | tpart_concurrent_dmls | ShareRowExclusiveLock | t       
 -1            | relation-dml | tpart_concurrent_dmls | ShareRowExclusiveLock | f       
(2 rows)

1: end;
END
2<:  <... completed>
UPDATE 1
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1 | c2  | c3 
----+-----+----
 7  | 7   | 7  
 8  | 8   | 8  
 11 | 11  | 11 
 17 | 17  | 17 
 18 | 18  | 18 
 4  | 4   | 4  
 5  | 5   | 5  
 6  | 6   | 6  
 9  | 9   | 9  
 10 | 10  | 10 
 12 | 12  | 12 
 16 | 16  | 16 
 20 | 20  | 20 
 2  | 777 | 2  
 13 | 13  | 13 
 14 | 14  | 14 
 15 | 15  | 15 
 19 | 19  | 19 
 1  | 777 | 1  
 3  | 3   | 3  
(20 rows)
select * from tpart_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 1  | 1  | 1  
(2 rows)

drop table tpart_concurrent_dmls;
DROP
drop table tpart_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table should be serialized on QD: update whose plan contains motion, delete whose plan contains motion
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
create table tpart_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20
insert into tpart_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tpart_concurrent_dmls using tpart_concurrent_dmls_auxiliary where tpart_concurrent_dmls.c3 = tpart_concurrent_dmls_auxiliary.c3;
DELETE 2
2&: update tpart_concurrent_dmls_1_prt_2 set c2 = 777 from tpart_concurrent_dmls_auxiliary where tpart_concurrent_dmls_1_prt_2.c3 = tpart_concurrent_dmls_auxiliary.c3;  <waiting ...>

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode                  | granted 
---------------+--------------+-----------------------+-----------------------+---------
 -1            | relation-dml | tpart_concurrent_dmls | ShareRowExclusiveLock | f       
 -1            | relation-dml | tpart_concurrent_dmls | ShareLock             | t       
(2 rows)

1: end;
END
2<:  <... completed>
UPDATE 0
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1 | c2 | c3 
----+----+----
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 17 | 17 | 17 
 18 | 18 | 18 
 4  | 4  | 4  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
 16 | 16 | 16 
 20 | 20 | 20 
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 19 | 19 | 19 
 3  | 3  | 3  
(18 rows)
select * from tpart_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 1  | 1  | 1  
 2  | 2  | 2  
(2 rows)

drop table tpart_concurrent_dmls;
DROP
drop table tpart_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table can be concurrent on QD: normal update, normal delete
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tpart_concurrent_dmls where c2 = 1;
DELETE 1
2: update tpart_concurrent_dmls_1_prt_2 set c2 =666 where c2 = 2;
UPDATE 0

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode             | granted 
---------------+--------------+-----------------------+------------------+---------
 -1            | relation-dml | tpart_concurrent_dmls | RowShareLock     | t       
 -1            | relation-dml | tpart_concurrent_dmls | RowExclusiveLock | t       
(2 rows)

1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1 | c2 | c3 
----+----+----
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 19 | 19 | 19 
 3  | 3  | 3  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
 16 | 16 | 16 
 20 | 20 | 20 
 2  | 2  | 2  
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 17 | 17 | 17 
 18 | 18 | 18 
 4  | 4  | 4  
(19 rows)

drop table tpart_concurrent_dmls;
DROP

-- Test two operations on same table can be concurrent on QD: normal update, insert
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20

1: begin;
BEGIN
2: begin;
BEGIN

1: insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 5)i;
INSERT 5
2: update tpart_concurrent_dmls_1_prt_2 set c2 =666 where c2 = 2;
UPDATE 0

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode             | granted 
---------------+--------------+-----------------------+------------------+---------
 -1            | relation-dml | tpart_concurrent_dmls | RowExclusiveLock | t       
(1 row)

1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1 | c2 | c3 
----+----+----
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
 16 | 16 | 16 
 20 | 20 | 20 
 5  | 5  | 5  
 2  | 2  | 2  
 2  | 2  | 2  
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 19 | 19 | 19 
 1  | 1  | 1  
 1  | 1  | 1  
 3  | 3  | 3  
 3  | 3  | 3  
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 17 | 17 | 17 
 18 | 18 | 18 
 4  | 4  | 4  
 4  | 4  | 4  
(25 rows)

drop table tpart_concurrent_dmls;
DROP

-- Test two operations on same table can be concurrent on QD: normal update, normal update
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20

1: begin;
BEGIN
2: begin;
BEGIN

1: update tpart_concurrent_dmls set c2 = 999 where c2 = 1;
UPDATE 1
2: update tpart_concurrent_dmls_1_prt_2 set c2 =666 where c2 = 2;
UPDATE 0

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode             | granted 
---------------+--------------+-----------------------+------------------+---------
 -1            | relation-dml | tpart_concurrent_dmls | RowExclusiveLock | t       
 -1            | relation-dml | tpart_concurrent_dmls | RowExclusiveLock | t       
(2 rows)

1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1 | c2  | c3 
----+-----+----
 13 | 13  | 13 
 14 | 14  | 14 
 15 | 15  | 15 
 19 | 19  | 19 
 1  | 999 | 1  
 3  | 3   | 3  
 7  | 7   | 7  
 8  | 8   | 8  
 11 | 11  | 11 
 17 | 17  | 17 
 18 | 18  | 18 
 4  | 4   | 4  
 5  | 5   | 5  
 6  | 6   | 6  
 9  | 9   | 9  
 10 | 10  | 10 
 12 | 12  | 12 
 16 | 16  | 16 
 20 | 20  | 20 
 2  | 2   | 2  
(20 rows)

drop table tpart_concurrent_dmls;
DROP

-- Test two operations on same table can be concurrent on QD: normal delete, normal delete
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tpart_concurrent_dmls where c2 = 1;
DELETE 1
2: delete from tpart_concurrent_dmls_1_prt_2 where c2 = 2;
DELETE 0

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode         | granted 
---------------+--------------+-----------------------+--------------+---------
 -1            | relation-dml | tpart_concurrent_dmls | RowShareLock | t       
 -1            | relation-dml | tpart_concurrent_dmls | RowShareLock | t       
(2 rows)

1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1 | c2 | c3 
----+----+----
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
 16 | 16 | 16 
 20 | 20 | 20 
 2  | 2  | 2  
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 19 | 19 | 19 
 3  | 3  | 3  
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 17 | 17 | 17 
 18 | 18 | 18 
 4  | 4  | 4  
(19 rows)

drop table tpart_concurrent_dmls;
DROP

-- Test two operations on same table can be concurrent on QD: normal delete, update whose plan contains motion
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
create table tpart_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20
insert into tpart_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tpart_concurrent_dmls where c2 = 8;
DELETE 1
2: update tpart_concurrent_dmls_1_prt_2 set c2 = 777 from tpart_concurrent_dmls_auxiliary where tpart_concurrent_dmls_1_prt_2.c3 = tpart_concurrent_dmls_auxiliary.c3;
UPDATE 1

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode                  | granted 
---------------+--------------+-----------------------+-----------------------+---------
 -1            | relation-dml | tpart_concurrent_dmls | ShareRowExclusiveLock | t       
 -1            | relation-dml | tpart_concurrent_dmls | RowShareLock          | t       
(2 rows)

1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1 | c2  | c3 
----+-----+----
 13 | 13  | 13 
 14 | 14  | 14 
 15 | 15  | 15 
 19 | 19  | 19 
 1  | 777 | 1  
 3  | 3   | 3  
 7  | 7   | 7  
 11 | 11  | 11 
 17 | 17  | 17 
 18 | 18  | 18 
 4  | 4   | 4  
 5  | 5   | 5  
 6  | 6   | 6  
 9  | 9   | 9  
 10 | 10  | 10 
 12 | 12  | 12 
 16 | 16  | 16 
 20 | 20  | 20 
 2  | 2   | 2  
(19 rows)
select * from tpart_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 1  | 1  | 1  
(2 rows)

drop table tpart_concurrent_dmls;
DROP
drop table tpart_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table can be concurrent on QD: normal delete, insert
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tpart_concurrent_dmls where c2 = 1;
DELETE 1
2: insert into tpart_concurrent_dmls_1_prt_2 values (1,1,1);
INSERT 1

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode         | granted 
---------------+--------------+-----------------------+--------------+---------
 -1            | relation-dml | tpart_concurrent_dmls | RowShareLock | t       
(1 row)

1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1 | c2 | c3 
----+----+----
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 17 | 17 | 17 
 18 | 18 | 18 
 4  | 4  | 4  
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 19 | 19 | 19 
 1  | 1  | 1  
 3  | 3  | 3  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
 16 | 16 | 16 
 20 | 20 | 20 
 2  | 2  | 2  
(20 rows)

drop table tpart_concurrent_dmls;
DROP

-- Test two operations on same table can be concurrent on QD: normal delete, delete whose plan contains motion
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
create table tpart_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20
insert into tpart_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tpart_concurrent_dmls where c2 = 1;
DELETE 1
2: delete from tpart_concurrent_dmls_1_prt_2 using tpart_concurrent_dmls_auxiliary where tpart_concurrent_dmls_1_prt_2.c3 > tpart_concurrent_dmls_auxiliary.c3 + 10;
DELETE 0

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode         | granted 
---------------+--------------+-----------------------+--------------+---------
 -1            | relation-dml | tpart_concurrent_dmls | ShareLock    | t       
 -1            | relation-dml | tpart_concurrent_dmls | RowShareLock | t       
(2 rows)

1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1 | c2 | c3 
----+----+----
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 19 | 19 | 19 
 3  | 3  | 3  
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 17 | 17 | 17 
 18 | 18 | 18 
 4  | 4  | 4  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
 16 | 16 | 16 
 20 | 20 | 20 
 2  | 2  | 2  
(19 rows)
select * from tpart_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 1  | 1  | 1  
(2 rows)

drop table tpart_concurrent_dmls;
DROP
drop table tpart_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table can be concurrent on QD: split-update, insert
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20

1: begin;
BEGIN
2: begin;
BEGIN

1: insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 5)i;
INSERT 5
2: update tpart_concurrent_dmls_1_prt_2 set c1 = 888 where c1 = 1;
UPDATE 1

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode          | granted 
---------------+--------------+-----------------------+---------------+---------
 -1            | relation-dml | tpart_concurrent_dmls | ExclusiveLock | t       
(1 row)

1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1  | c2 | c3 
-----+----+----
 13  | 13 | 13 
 14  | 14 | 14 
 15  | 15 | 15 
 19  | 19 | 19 
 1   | 1  | 1  
 3   | 3  | 3  
 3   | 3  | 3  
 7   | 7  | 7  
 8   | 8  | 8  
 11  | 11 | 11 
 17  | 17 | 17 
 18  | 18 | 18 
 888 | 1  | 1  
 4   | 4  | 4  
 4   | 4  | 4  
 5   | 5  | 5  
 6   | 6  | 6  
 9   | 9  | 9  
 10  | 10 | 10 
 12  | 12 | 12 
 16  | 16 | 16 
 20  | 20 | 20 
 5   | 5  | 5  
 2   | 2  | 2  
 2   | 2  | 2  
(25 rows)

drop table tpart_concurrent_dmls;
DROP

-- Test two operations on same table can be concurrent on QD: update whose plan contains motion, insert
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
create table tpart_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20
insert into tpart_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 5)i;
INSERT 5
2: update tpart_concurrent_dmls_1_prt_2 set c2 = 777 from tpart_concurrent_dmls_auxiliary where tpart_concurrent_dmls_1_prt_2.c3 = tpart_concurrent_dmls_auxiliary.c3;
UPDATE 1

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode                  | granted 
---------------+--------------+-----------------------+-----------------------+---------
 -1            | relation-dml | tpart_concurrent_dmls | ShareRowExclusiveLock | t       
(1 row)

1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1 | c2  | c3 
----+-----+----
 5  | 5   | 5  
 6  | 6   | 6  
 9  | 9   | 9  
 10 | 10  | 10 
 12 | 12  | 12 
 16 | 16  | 16 
 20 | 20  | 20 
 5  | 5   | 5  
 2  | 2   | 2  
 2  | 2   | 2  
 13 | 13  | 13 
 14 | 14  | 14 
 15 | 15  | 15 
 19 | 19  | 19 
 1  | 1   | 1  
 1  | 777 | 1  
 3  | 3   | 3  
 3  | 3   | 3  
 7  | 7   | 7  
 8  | 8   | 8  
 11 | 11  | 11 
 17 | 17  | 17 
 18 | 18  | 18 
 4  | 4   | 4  
 4  | 4   | 4  
(25 rows)
select * from tpart_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 1  | 1  | 1  
 2  | 2  | 2  
(2 rows)

drop table tpart_concurrent_dmls;
DROP
drop table tpart_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table can be concurrent on QD: delete whose plan contains motion, insert
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
create table tpart_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20
insert into tpart_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 5)i;
INSERT 5
2: delete from tpart_concurrent_dmls_1_prt_2 using tpart_concurrent_dmls_auxiliary where tpart_concurrent_dmls_1_prt_2.c3 > tpart_concurrent_dmls_auxiliary.c3 + 10;
DELETE 0

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode      | granted 
---------------+--------------+-----------------------+-----------+---------
 -1            | relation-dml | tpart_concurrent_dmls | ShareLock | t       
(1 row)

1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1 | c2 | c3 
----+----+----
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 19 | 19 | 19 
 1  | 1  | 1  
 1  | 1  | 1  
 3  | 3  | 3  
 3  | 3  | 3  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
 16 | 16 | 16 
 20 | 20 | 20 
 5  | 5  | 5  
 2  | 2  | 2  
 2  | 2  | 2  
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 17 | 17 | 17 
 18 | 18 | 18 
 4  | 4  | 4  
 4  | 4  | 4  
(25 rows)
select * from tpart_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 1  | 1  | 1  
(2 rows)

drop table tpart_concurrent_dmls;
DROP
drop table tpart_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table can be concurrent on QD: delete whose plan contains motion, delete whose plan contains motion
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
create table tpart_concurrent_dmls_auxiliary(c1 int, c2 int, c3 int) distributed by (c1);
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20
insert into tpart_concurrent_dmls_auxiliary select i,i,i from generate_series(1, 2)i;
INSERT 2

1: begin;
BEGIN
2: begin;
BEGIN

1: delete from tpart_concurrent_dmls using tpart_concurrent_dmls_auxiliary where tpart_concurrent_dmls.c3 = tpart_concurrent_dmls_auxiliary.c3;
DELETE 2
2: delete from tpart_concurrent_dmls_1_prt_2 using tpart_concurrent_dmls_auxiliary where tpart_concurrent_dmls_1_prt_2.c3 > tpart_concurrent_dmls_auxiliary.c3 + 10;
DELETE 0

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype     | relation              | mode      | granted 
---------------+--------------+-----------------------+-----------+---------
 -1            | relation-dml | tpart_concurrent_dmls | ShareLock | t       
 -1            | relation-dml | tpart_concurrent_dmls | ShareLock | t       
(2 rows)

1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1 | c2 | c3 
----+----+----
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 17 | 17 | 17 
 18 | 18 | 18 
 4  | 4  | 4  
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 19 | 19 | 19 
 3  | 3  | 3  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
 16 | 16 | 16 
 20 | 20 | 20 
(18 rows)
select * from tpart_concurrent_dmls_auxiliary;
 c1 | c2 | c3 
----+----+----
 2  | 2  | 2  
 1  | 1  | 1  
(2 rows)

drop table tpart_concurrent_dmls;
DROP
drop table tpart_concurrent_dmls_auxiliary;
DROP

-- Test two operations on same table can be concurrent on QD: insert, insert
create table tpart_concurrent_dmls(c1 int, c2 int, c3 int) distributed by (c1) partition by range (c3) ( start (1) end (5) every (1), default partition extra );
CREATE
insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 20)i;
INSERT 20

1: begin;
BEGIN
2: begin;
BEGIN

1: insert into tpart_concurrent_dmls select i,i,i from generate_series(1, 5)i;
INSERT 5
2: insert into tpart_concurrent_dmls_1_prt_2 values (1,1,1);
INSERT 1

select * from (select gp_segment_id, locktype, relation::regclass::text, mode, granted from pg_locks where locktype = 'relation-dml')x where relation like 'tpart_%';
 gp_segment_id | locktype | relation | mode | granted 
---------------+----------+----------+------+---------
(0 rows)

1: end;
END
2: end;
END

1q: ... <quitting>
2q: ... <quitting>

select * from tpart_concurrent_dmls;
 c1 | c2 | c3 
----+----+----
 7  | 7  | 7  
 8  | 8  | 8  
 11 | 11 | 11 
 17 | 17 | 17 
 18 | 18 | 18 
 4  | 4  | 4  
 4  | 4  | 4  
 13 | 13 | 13 
 14 | 14 | 14 
 15 | 15 | 15 
 19 | 19 | 19 
 1  | 1  | 1  
 1  | 1  | 1  
 1  | 1  | 1  
 3  | 3  | 3  
 3  | 3  | 3  
 5  | 5  | 5  
 6  | 6  | 6  
 9  | 9  | 9  
 10 | 10 | 10 
 12 | 12 | 12 
 16 | 16 | 16 
 20 | 20 | 20 
 5  | 5  | 5  
 2  | 2  | 2  
 2  | 2  | 2  
(26 rows)

drop table tpart_concurrent_dmls;
DROP

