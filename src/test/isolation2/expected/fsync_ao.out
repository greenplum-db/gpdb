-- This test validates that AO tables are sync'ed by checkpoint.
-- It simulates the following scenario.
--
--   * Start with a clean slate - ensure that all files are flushed by checkpointer.
--   * Write two tables (one is ao and another is aoco).
--   * Resume checkpointer and let it fsync the two dirty AO relations and their auxiliary tables.
--   * Verify that 6 files (gp_fastsequence, ao data files, aoseg files) were fsync'ed by checkpointer.
--   * Verify that those files were also fsync-ed by restartpoint on mirror.

-- Set the GUC to perform replay of checkpoint records immediately.  It speeds up the test.
-- Set fsync on since we need to test the fsync code logic.

-- start_ignore
! gpconfig -c create_restartpoint_on_ckpt_record_replay -v on --skipvalidation;
20191121:17:04:15:089644 gpconfig:host67:pguo-[INFO]:-completed successfully with parameters '-c create_restartpoint_on_ckpt_record_replay -v on --skipvalidation'

! gpconfig -c fsync -v on --skipvalidation;
20191121:17:04:16:089780 gpconfig:host67:pguo-[INFO]:-completed successfully with parameters '-c fsync -v on --skipvalidation'

! gpstop -u;
20191121:17:04:16:089916 gpstop:host67:pguo-[INFO]:-Starting gpstop with args: -u
20191121:17:04:16:089916 gpstop:host67:pguo-[INFO]:-Gathering information and validating the environment...
20191121:17:04:16:089916 gpstop:host67:pguo-[INFO]:-Obtaining Greenplum Master catalog information
20191121:17:04:16:089916 gpstop:host67:pguo-[INFO]:-Obtaining Segment details from master...
20191121:17:04:16:089916 gpstop:host67:pguo-[INFO]:-Greenplum Version: 'postgres (Greenplum Database) 7.0.0-alpha.0+dev.5193.g47b7daada9 build dev'
20191121:17:04:16:089916 gpstop:host67:pguo-[INFO]:-Signalling all postmaster processes to reload

-- end_ignore

create table fsync_ao(a int, b int) with (appendoptimized = true) distributed by (a);
CREATE
create table fsync_co(a int, b int) with (appendoptimized = true, orientation = column) distributed by (a);
CREATE
insert into fsync_ao select i, i from generate_series(1,20)i;
INSERT 20
insert into fsync_co select i, i from generate_series(1,20)i;
INSERT 20

-- Reset all faults.
--
-- NOTICE: important.
--
-- we use gp_inject_fault_infinite here instead of
-- gp_inject_fault so cache of pg_proc that contains
-- gp_inject_fault_infinite is loaded before checkpoint and
-- the following gp_inject_fault_infinite don't dirty the
-- buffer again. TODO: gp_inject_fault_infinite vs gp_inject_fault
select gp_inject_fault_infinite('all', 'reset', dbid) from gp_segment_configuration where content = 0;
 gp_inject_fault_infinite 
--------------------------
 Success:                 
 Success:                 
(2 rows)

-- Skip hint bits setting on primaries so that no fsync request due to hint
-- bits happen in the below tests.
select gp_inject_fault_infinite('set_hint_bits', 'skip', dbid) from gp_segment_configuration where role = 'p' and content = 0;
 gp_inject_fault_infinite 
--------------------------
 Success:                 
(1 row)

-- Fault to check that mirror has flushed pending fsync requests.
select gp_inject_fault_infinite('restartpoint_guts', 'skip', dbid) from gp_segment_configuration where role = 'm' and content = 0;
 gp_inject_fault_infinite 
--------------------------
 Success:                 
(1 row)

-- Start with a clean slate.
checkpoint;
CHECKPOINT

-- Wait until restartpoint flush happens.
select gp_wait_until_triggered_fault('restartpoint_guts', 1, dbid) from gp_segment_configuration where content=0 and role='m';
 gp_wait_until_triggered_fault 
-------------------------------
 Success:                      
(1 row)

-- We have just created a checkpoint.  The next checkpoint will be triggered
-- only after 5 minutes or after CheckPointSegments wal segments.  Neither of
-- that can happen until this test calls explicit checkpoint.

-- Write ao and co data files including aoseg & gp_fastsequence.
-- These should be fsync-ed by checkpoint & restartpoint.
insert into fsync_ao select i, i from generate_series(1,20)i;
INSERT 20
insert into fsync_co select i, i from generate_series(1,20)i;
INSERT 20

-- Inject fault to count relfiles fsync'ed by checkpointer on primary as well
-- as mirror.
select gp_inject_fault_infinite('fsync_counter', 'skip', dbid) from gp_segment_configuration where content = 0;
 gp_inject_fault_infinite 
--------------------------
 Success:                 
 Success:                 
(2 rows)

checkpoint;
CHECKPOINT

-- Wait until restartpoint happens again.
select gp_wait_until_triggered_fault('restartpoint_guts', 2, dbid) from gp_segment_configuration where content=0 and role='m';
 gp_wait_until_triggered_fault 
-------------------------------
 Success:                      
(1 row)

-- Validate that the number of files fsync'ed by checkpointer.
-- `num times hit` is corresponding to the number of files synced by
-- `fsync_counter` fault type.
select gp_inject_fault('fsync_counter', 'status', dbid) from gp_segment_configuration where content=0;
 gp_inject_fault                                                                                                                                                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Success: fault name:'fsync_counter' fault type:'skip' ddl statement:'' database name:'' table name:'' start occurrence:'1' end occurrence:'-1' extra arg:'0' fault injection state:'triggered'  num times hit:'6' 
 
 Success: fault name:'fsync_counter' fault type:'skip' ddl statement:'' database name:'' table name:'' start occurrence:'1' end occurrence:'-1' extra arg:'0' fault injection state:'triggered'  num times hit:'6' 
 
(2 rows)

-- Checkpoint after drop table should be successful. It validates that the drop
-- removed the fsync requests enqued by the previous insert from
-- pendingOpsTable.
insert into fsync_co select i, i from generate_series(1,20)i;
INSERT 20
drop table fsync_co;
DROP
checkpoint;
CHECKPOINT
-- Wait until restartpoint happens again.
select gp_wait_until_triggered_fault('restartpoint_guts', 3, dbid) from gp_segment_configuration where content=0 and role='m';
 gp_wait_until_triggered_fault 
-------------------------------
 Success:                      
(1 row)

-- Test vacuum compaction with more than one segment file per table.  Perform
-- concurrent inserts before vacuum to get multiple segment files.  Validation
-- criterion is the checkpoint command succeeds on primary and the
-- restartpoint_guts fault point is reached on the mirror.
create table fsync_co(a int, b int) with (appendoptimized = true, orientation = column) distributed by (a);
CREATE
1: begin;
BEGIN
1: insert into fsync_ao select i, i from generate_series(1,20)i;
INSERT 20
1: insert into fsync_co select i, i from generate_series(1,20)i;
INSERT 20
insert into fsync_ao select i, i from generate_series(1,20)i;
INSERT 20
insert into fsync_co select i, i from generate_series(1,20)i;
INSERT 20
1: end;
END
-- expect two segment files for each table (ao table) or each column (co table).
select segno, state from gp_toolkit.__gp_aoseg('fsync_ao');
 segno | state 
-------+-------
 1     | 1     
 2     | 1     
(2 rows)
select segno, column_num, physical_segno, state from gp_toolkit.__gp_aocsseg('fsync_co');
 segno | column_num | physical_segno | state 
-------+------------+----------------+-------
 1     | 0          | 1              | 1     
 1     | 1          | 129            | 1     
 2     | 0          | 2              | 1     
 2     | 1          | 130            | 1     
(4 rows)
vacuum fsync_ao;
VACUUM
vacuum fsync_co;
VACUUM
checkpoint;
CHECKPOINT
-- Wait until restartpoint happens again.
select gp_wait_until_triggered_fault('restartpoint_guts', 4, dbid) from gp_segment_configuration where content=0 and role='m';
 gp_wait_until_triggered_fault 
-------------------------------
 Success:                      
(1 row)

-- Checkpoint after drop database should be successful. It validates that the drop
-- removed the fsync requests enqued by the previous insert from
-- pendingOpsTable.
create database fsync_ao_db;
CREATE
2:@db_name fsync_ao_db: create table fsync_ao(a int, b int) with (appendoptimized = true) distributed by (a);
CREATE
2:@db_name fsync_ao_db: create table fsync_co(a int, b int) with (appendoptimized = true, orientation = column) distributed by (a);
CREATE
2:@db_name fsync_ao_db: insert into fsync_ao select i, i from generate_series(1,20)i;
INSERT 20
2:@db_name fsync_ao_db: insert into fsync_co select i, i from generate_series(1,20)i;
INSERT 20
2q: ... <quitting>
drop database fsync_ao_db;
DROP
checkpoint;
CHECKPOINT
-- Wait until restartpoint happens again.
select gp_wait_until_triggered_fault('restartpoint_guts', 5, dbid) from gp_segment_configuration where content=0 and role='m';
 gp_wait_until_triggered_fault 
-------------------------------
 Success:                      
(1 row)

-- Reset all faults.
select gp_inject_fault('all', 'reset', dbid) from gp_segment_configuration where content = 0;
 gp_inject_fault 
-----------------
 Success:        
 Success:        
(2 rows)


-- start_ignore
! gpconfig -r create_restartpoint_on_ckpt_record_replay --skipvalidation;
20191121:17:04:19:089989 gpconfig:host67:pguo-[INFO]:-completed successfully with parameters '-r create_restartpoint_on_ckpt_record_replay --skipvalidation'

! gpconfig -r fsync --skipvalidation;
20191121:17:04:19:090125 gpconfig:host67:pguo-[INFO]:-completed successfully with parameters '-r fsync --skipvalidation'

! gpstop -u;
20191121:17:04:19:090261 gpstop:host67:pguo-[INFO]:-Starting gpstop with args: -u
20191121:17:04:19:090261 gpstop:host67:pguo-[INFO]:-Gathering information and validating the environment...
20191121:17:04:19:090261 gpstop:host67:pguo-[INFO]:-Obtaining Greenplum Master catalog information
20191121:17:04:19:090261 gpstop:host67:pguo-[INFO]:-Obtaining Segment details from master...
20191121:17:04:19:090261 gpstop:host67:pguo-[INFO]:-Greenplum Version: 'postgres (Greenplum Database) 7.0.0-alpha.0+dev.5193.g47b7daada9 build dev'
20191121:17:04:19:090261 gpstop:host67:pguo-[INFO]:-Signalling all postmaster processes to reload

-- end_ignore
